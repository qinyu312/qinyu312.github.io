{"posts":[{"title":"TypeScript","content":"typescript是javascript的超集，二者最本质的区别就体现在名字上面， type意为类型，从前的javascript，由于历史遗留及语言定位问题，一直以来虽然独霸前端技术栈，但也一直深受诟病。中小型项目尚可，真要在大型项目的场景中使用，就会暴露出许多问题，例如，定义变量类型不够明确，不会抛出异常报错信息，处理复杂业务能力欠佳等。而typescript的到来填补了许多坑。 环境搭建 首先，typescript是使用 node.js进行编写的javascript的超集，所以运行typescript需要先安装 node.js 环境，官网下载安装即可，安装完成之后，需要借助 node.js 的包管理器 npm ，进行typescript的全局安装，命令行指令如下 npm install -g typescript 安装完成之后就可以创建 以 .ts 为结尾的ts文件，需要注意的是，浏览器是不支持解析ts文件的，所以我们写完 ts代码后，还需要将 ts 文件编译为 js文件，在可以在浏览器中执行，例如 test.ts 文件，如果需要执行，就需要在当前文件的命令行下执行命令 tsc test.ts 然后 test.ts 同级目录下就会输出一个 test.js 的编译好的 js文件，html代码中引入 js文件， 既可以正常执行，值得注意的是，现在的 ts 文件，每次修改后都需要重新编译为 js 文件。 语法学习 ts 可以指定变量或者函数传参的类型，这点在大型项目中尤为重要，大型项目动辄一个js文件上千上万行代码，而js定义变量和函数传参等写法上又十分随意，时常会有类型错误导致程序异常，导致项目过大难以维护，加上js本身的机制上并不会抛出异常，所以遇到类型错误难以捕获，维护成本大大增加，使用ts之后，虽然前期写法上略显多余和臃肿，但是为之后的项目维护提前布局，从而提高了效率。 基本写法 &lt;!-- 在ts文件中定义一个变量,变量后面紧跟冒号加数据类型，即可指定当前变量的数据类型 --&gt; let a:string = 'hello ts' &lt;!-- 当给 a 指定了数据类型为字符串 string 后，再次修改 a 的 值为 number 123时，程序就会抛出异常，告诉你此处需要的是一个字符串，而不是number类型 --&gt; a = 123 &lt;!-- 此时，在命令行中输入编译命令， tsc test.ts 将文件编译为 js文件时，也会抛出错误信息，但是编译器依然会帮你将错误的ts语法代码编译为 js文件 --&gt; &lt;!-- 函数传参时指定参数的类型可以有效防止传入的值与所需类型不一致的问题，例如此处，一个求和的函数，需要传入两个数字，进行相加得到结果，如果指定参数类型为 number ,但调用时传入其他类型的参数就会直接抛出异常，如果不在函数参数里指定数据类型，那么如果传入的是一个数字和一个字符串，那么就会进行字符串的拼串操作，得到的会是一个字符串，而非我们希望的数字 --&gt; function sum(a:number, b:number) { return a + b; } let res = sum(2 , 7) &lt;!-- 联合类型 \b在 ts中， ｜\b 表示或的意思，什么或者什么，\b所以a的值只可以在 male 和 demale之间才可以，否则，就会抛出异常。 ｜ \b既可以用来连接字面量，也可以用来连接类型 --&gt; let a: &quot;male&quot; | &quot;famale&quot;\b let b: false | string &lt;!-- any 表示任意类型，定义为any的变量，可以是任意类型。但是当一个变量设置为any类型后，相当于是对这个变量关闭了 ts 的类型检测，之后不管赋值什么类型都不会抛出异常。 所以不建议使用--&gt; let c:any c = 'hello' c = 12 c = true &lt;!-- 当声名一个变量，但是不去赋值的时候，ts 解析器无法知道变量的数据类型，\b就会隐式的将 变量类型设置为 any , --&gt; let d &lt;!-- 当你暂时不知道变量的类型设置为什么比较好时，any并不是首选项，还可以使用 unknown, 表示未知类型的值，他的效果和 any 一样， 但\b是他们在使用上会有很大的差异， \b举个例子，现在有一个变量 e的值为 string 类型， 变量 f \b只声名未赋值，也就是 any 类型， 当把 f 赋值给e的时候，由于f是any类型，也就是任意类型，\b它显然是符合 e 的类型条件的，所以并不会报错，但是此时，f 就把自己的类型 any 也带给了 e ,导致 e 的类型\b从 string \b变成了 any ,\b 污染了其他变量。 而 unknown\b 类型的变量实际上就是一个类型安全的 any ，\b因为它不能直接赋值给其他变量 --&gt; let e = 'hello' let f e = f 当需要把 unknown 变量赋值给其他变量时， 可以先做一个类型判断后再进行赋值操作 if(typeof e === 'string') { e = f } 还可以使用类型断言的方式强行指定类型 e = f as string &lt;!-- 或者 --&gt; e = &lt;string&gt; f; &lt;!-- void \b为空的， 以函数为例，当给函数的返回值设置为 void 类型时，如果返回的值不为空类型（underfind 或者 null ）就会报错 --&gt; function fn():void { return ; } &lt;!-- never 类型，表示永远不会又返回结果。 \b适用于没有返回值的函数使用，比如专门用来捕获抛出异常的函数 --&gt; function fn1(): never { return } &lt;!-- object 对象类型 { } 用来指定对象中可以包含哪些类型的属性--&gt; let g: {name: string} g = {name: 'suibianshenme '} &lt;!-- [ccc: string]: string\b表示任意名称的字符串和 字符串类型的值 --&gt; let h: {name: string, [ccc: string]: string} h = {name: 'suibianshenme ', ddd: 'sdhu'} ","link":"https://qinyu312.github.io/post/typescript/"},{"title":"地图定位相关","content":"JS获取当前地理位置(经纬度) if(navigator.geolocation) { navigator.geolocation.getCurrentPosition( function (position) { console.log( position.coords.longitude ); console.log( position.coords.latitude ); }, function (e) { throw(e.message); } ) } 微信小程序获取当前地理位置(经纬度) wx.getLocation({ altitude: 'altitude', isHighAccuracy: true, success(res) { // 手机经纬度定位更加精准，需要截取到小数点后六位 var currentLatitude = (res.latitude).toFixed(6); //纬度 var currentLongitude = (res.longitude).toFixed(6); //经度 console.log(currentLatitude , currentLongitude) this.setData({ // 经度 longitude: currentLongitude, // 纬度 latitude: currentLatitude }) } }) 微信小程序通过经纬度逆推获取当前城市信息 首先需要去腾讯位置服务官网，申请开发者密钥 开通webserviceAPI服务：在控制台 -&gt; key管理 -&gt; 设置（使用该功能的key）-&gt; 勾选webserviceAPI -&gt; 保存。(小程序SDK需要用到webserviceAPI的部分服务，所以使用该功能的KEY需要具备相应的权限) 下载微信小程序JavaScriptSDK，微信小程序JavaScriptSDK v1.1 JavaScriptSDK v1.2 安全域名设置，在小程序管理后台 -&gt; 开发 -&gt; 开发管理 -&gt; 开发设置 -&gt; “服务器域名” 中设置request合法域名，添加https://apis.map.qq.com 示例如下 getAddress() { var that = this &lt;!-- 调用微信小程序获取经纬度API --&gt; wx.getLocation({ altitude: 'altitude', isHighAccuracy: true, success(res) { // 手机经纬度定位更加精准，需要截取到小数点后六位 var currentLatitude = (res.latitude).toFixed(6); //纬度 var currentLongitude = (res.longitude).toFixed(6); //经度 &lt;!-- 将经纬度存储在data中 --&gt; that.setData({ // 经度 longitude: currentLongitude, // 纬度 latitude: currentLatitude }) // 逆解析接口 /ws/geocoder/v1 &lt;!-- 定义一个变量用于拼接地址逆解析接口，key值是腾讯位置服务中注册后生成的 key --&gt; var qqMapApi = 'http://apis.map.qq.com/ws/geocoder/v1/' + &quot;?location=&quot; + that.data.latitude + ',' + that.data.longitude + &quot;&amp;key=&quot; + 'ZHHBZ-MCN6D-HUX4Y-PL7SW-KM4TQ-WYBDZ' + &quot;&amp;get_poi=1&quot;; &lt;!-- \b拼接完成后作为参数使用 --&gt; that.getSkys(qqMapApi); } }) }, &lt;!-- 调用接口将参数作为 url 发送请求 --&gt; getSkys(qqMapApi){ const that = this wx.request({ url: qqMapApi, header: { 'Content-Type': 'application/json' }, data: {}, method:'GET', success: (res) =&gt; { &lt;!-- 获取的\b返回值数据就是传入的经纬度提取到的 各级地理数据信息 --&gt; if (res.statusCode == 200 &amp;&amp; res.data.status == 0) { // 从返回值中提取需要的业务地理信息数据 国家、省、市、县区、街道 // that.setData({ nation: res.data.result.address_component.nation }); // that.setData({ province: res.data.result.address_component.province }); that.setData({ city: res.data.result.address_component.city }); // that.setData({ district: res.data.result.address_component.district }); // that.setData({ street: res.data.result.address_component.street }); wx.request({ url: &quot;http://wthrcdn.etouch.cn/weather_mini&quot;, data: {city: res.data.result.address_component.city}, // data: {city: '昆明'}, method: 'GET', success: res =&gt; { var low = res.data.data.forecast[0].low.split(' ', 2)[1] var high = res.data.data.forecast[0].high.split(' ', 2)[1] var skyTitle = low + '~' + high + ' ' + res.data.data.forecast[0].type var skyType = res.data.data.forecast[0].type this.setData({ skyType: skyType, skyTitle: skyTitle }) console.log(skyTitle) } }) } } }) }, 最后得到所需要的位置信息 ","link":"https://qinyu312.github.io/post/di-tu-ding-wei-xiang-guan/"},{"title":"2.5基金日报","content":"最近几天新能源和军工又又又被锤肿了，可能受春运回家核酸检测和疫苗接种的影响，医药最近几天走势大好，月初几天美股游戏驿站事件，A股也是一片哀嚎一片绿，但是白酒却逆势上扬，让我想起一句话，白酒生，万物死。今天新能源和军工大跌，理性加一些仓位，个人觉得新能源是长期利好，也是未来的发展趋势，军工在今年的十四五规划中也有望大放异彩，医药方面，由于人口老龄化加速及医疗水平提高，可作为长期投资，半导体5G方面谨慎上车，有色金属可适当上车。 ","link":"https://qinyu312.github.io/post/25-ji-jin-ri-bao/"},{"title":"AES加密前端操作","content":"aes前端加密 最近在开发微信小程序，由于是国企项目，上线前都需要做好几次安全漏洞扫描，所以数据接口都需要二次封装并进行加解密的操作来确保安全性，最后和后端同事商议，使用aes进行加密，原理是前端请求的后端接口，除统一域名前缀部分外，后面接口部分全部使用公共参数 例如common 进行替换，然后将接口名称，接口所需参数等信息，通过 aes 加密后传输给后端，后端拿到加密后的字符串，通过解密算法得到接口名称及参数，来调用对用的接口，然后将返回值同样经过加密后返回给前端，前端拿到加密串后解密，得到JSON对象，转换后得到接口数据进行页面渲染。 具体操作如下： 将加解密方法操作封装在 public.js 和 aes.js 两个文件中 &lt;!-- public.js --&gt; var CryptoJS = require('./aes.js'); //引用AES源码js var key = CryptoJS.enc.Utf8.parse(&quot;richeninfo202121&quot;); //十六位十六进制数作为秘钥 var iv = CryptoJS.enc.Utf8.parse('richeninfo202121');//十六位十六进制数作为秘钥偏移量 //解密方法 function Decrypt(word) { var encryptedHexStr = CryptoJS.enc.Hex.parse(word); var srcs = CryptoJS.enc.Base64.stringify(encryptedHexStr); var decrypt = CryptoJS.AES.decrypt(srcs, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); var decryptedStr = decrypt.toString(CryptoJS.enc.Utf8); return decryptedStr.toString(); } //加密方法 function Encrypt(word) { var srcs = CryptoJS.enc.Utf8.parse(word); var encrypted = CryptoJS.AES.encrypt(srcs, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); return encrypted.ciphertext.toString().toUpperCase(); } //暴露接口 module.exports.Decrypt = Decrypt; module.exports.Encrypt = Encrypt; &lt;!-- aes.js --&gt; /** * [description] CryptoJS v3.1.2 * [description] zhuangzhudada sort out */ var CryptoJS = CryptoJS || function(u, p) { var d = {}, l = d.lib = {}, s = function() {}, t = l.Base = { extend: function(a) { s.prototype = this; var c = new s; a &amp;&amp; c.mixIn(a); c.hasOwnProperty(&quot;init&quot;) || (c.init = function() { c.$super.init.apply(this, arguments) }); c.init.prototype = c; c.$super = this; return c }, create: function() { var a = this.extend(); a.init.apply(a, arguments); return a }, init: function() {}, mixIn: function(a) { for (var c in a) a.hasOwnProperty(c) &amp;&amp; (this[c] = a[c]); a.hasOwnProperty(&quot;toString&quot;) &amp;&amp; (this.toString = a.toString) }, clone: function() { return this.init.prototype.extend(this) } }, r = l.WordArray = t.extend({ init: function(a, c) { a = this.words = a || []; this.sigBytes = c != p ? c : 4 * a.length }, toString: function(a) { return (a || v).stringify(this) }, concat: function(a) { var c = this.words, e = a.words, j = this.sigBytes; a = a.sigBytes; this.clamp(); if (j % 4) for (var k = 0; k &lt; a; k++) c[j + k &gt;&gt;&gt; 2] |= (e[k &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (k % 4) &amp; 255) &lt;&lt; 24 - 8 * ((j + k) % 4); else if (65535 &lt; e.length) for (k = 0; k &lt; a; k += 4) c[j + k &gt;&gt;&gt; 2] = e[k &gt;&gt;&gt; 2]; else c.push.apply(c, e); this.sigBytes += a; return this }, clamp: function() { var a = this.words, c = this.sigBytes; a[c &gt;&gt;&gt; 2] &amp;= 4294967295 &lt;&lt; - 8 * (c % 4); a.length = u.ceil(c / 4) }, clone: function() { var a = t.clone.call(this); a.words = this.words.slice(0); return a }, random: function(a) { for (var c = [], e = 0; e &lt; a; e += 4) c.push(4294967296 * u.random() | 0); return new r.init(c, a) } }), w = d.enc = {}, v = w.Hex = { stringify: function(a) { var c = a.words; a = a.sigBytes; for (var e = [], j = 0; j &lt; a; j++) { var k = c[j &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (j % 4) &amp; 255; e.push((k &gt;&gt;&gt; 4).toString(16)); e.push((k &amp; 15).toString(16)) } return e.join(&quot;&quot;) }, parse: function(a) { for (var c = a.length, e = [], j = 0; j &lt; c; j += 2) e[j &gt;&gt;&gt; 3] |= parseInt(a.substr(j, 2), 16) &lt;&lt; 24 - 4 * (j % 8); return new r.init(e, c / 2) } }, b = w.Latin1 = { stringify: function(a) { var c = a.words; a = a.sigBytes; for (var e = [], j = 0; j &lt; a; j++) e.push(String.fromCharCode(c[j &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (j % 4) &amp; 255)); return e.join(&quot;&quot;) }, parse: function(a) { for (var c = a.length, e = [], j = 0; j &lt; c; j++) e[j &gt;&gt;&gt; 2] |= (a.charCodeAt(j) &amp; 255) &lt;&lt; 24 - 8 * (j % 4); return new r.init(e, c) } }, x = w.Utf8 = { stringify: function(a) { try { return decodeURIComponent(escape(b.stringify(a))) } catch (c) { throw Error(&quot;Malformed UTF-8 data&quot;); } }, parse: function(a) { return b.parse(unescape(encodeURIComponent(a))) } }, q = l.BufferedBlockAlgorithm = t.extend({ reset: function() { this._data = new r.init; this._nDataBytes = 0 }, _append: function(a) { &quot;string&quot; == typeof a &amp;&amp; (a = x.parse(a)); this._data.concat(a); this._nDataBytes += a.sigBytes }, _process: function(a) { var c = this._data, e = c.words, j = c.sigBytes, k = this.blockSize, b = j / (4 * k), b = a ? u.ceil(b) : u.max((b | 0) - this._minBufferSize, 0); a = b * k; j = u.min(4 * a, j); if (a) { for (var q = 0; q &lt; a; q += k) this._doProcessBlock(e, q); q = e.splice(0, a); c.sigBytes -= j } return new r.init(q, j) }, clone: function() { var a = t.clone.call(this); a._data = this._data.clone(); return a }, _minBufferSize: 0 }); l.Hasher = q.extend({ cfg: t.extend(), init: function(a) { this.cfg = this.cfg.extend(a); this.reset() }, reset: function() { q.reset.call(this); this._doReset() }, update: function(a) { this._append(a); this._process(); return this }, finalize: function(a) { a &amp;&amp; this._append(a); return this._doFinalize() }, blockSize: 16, _createHelper: function(a) { return function(b, e) { return (new a.init(e)).finalize(b) } }, _createHmacHelper: function(a) { return function(b, e) { return (new n.HMAC.init(a, e)).finalize(b) } } }); var n = d.algo = {}; return d }(Math); (function() { var u = CryptoJS, p = u.lib.WordArray; u.enc.Base64 = { stringify: function(d) { var l = d.words, p = d.sigBytes, t = this._map; d.clamp(); d = []; for (var r = 0; r &lt; p; r += 3) for (var w = (l[r &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (r % 4) &amp; 255) &lt;&lt; 16 | (l[r + 1 &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * ((r + 1) % 4) &amp; 255) &lt;&lt; 8 | l[r + 2 &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * ((r + 2) % 4) &amp; 255, v = 0; 4 &gt; v &amp;&amp; r + 0.75 * v &lt; p; v++) d.push(t.charAt(w &gt;&gt;&gt; 6 * (3 - v) &amp; 63)); if (l = t.charAt(64)) for (; d.length % 4;) d.push(l); return d.join(&quot;&quot;) }, parse: function(d) { var l = d.length, s = this._map, t = s.charAt(64); t &amp;&amp; (t = d.indexOf(t), -1 != t &amp;&amp; (l = t)); for (var t = [], r = 0, w = 0; w &lt; l; w++) if (w % 4) { var v = s.indexOf(d.charAt(w - 1)) &lt;&lt; 2 * (w % 4), b = s.indexOf(d.charAt(w)) &gt;&gt;&gt; 6 - 2 * (w % 4); t[r &gt;&gt;&gt; 2] |= (v | b) &lt;&lt; 24 - 8 * (r % 4); r++ } return p.create(t, r) }, _map: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot; } })(); (function(u) { function p(b, n, a, c, e, j, k) { b = b + (n &amp; a | ~n &amp; c) + e + k; return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n } function d(b, n, a, c, e, j, k) { b = b + (n &amp; c | a &amp; ~c) + e + k; return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n } function l(b, n, a, c, e, j, k) { b = b + (n ^ a ^ c) + e + k; return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n } function s(b, n, a, c, e, j, k) { b = b + (a ^ (n | ~c)) + e + k; return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n } for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 &gt; x; x++) b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0; r = r.MD5 = v.extend({ _doReset: function() { this._hash = new w.init([1732584193, 4023233417, 2562383102, 271733878]) }, _doProcessBlock: function(q, n) { for (var a = 0; 16 &gt; a; a++) { var c = n + a, e = q[c]; q[c] = (e &lt;&lt; 8 | e &gt;&gt;&gt; 24) &amp; 16711935 | (e &lt;&lt; 24 | e &gt;&gt;&gt; 8) &amp; 4278255360 } var a = this._hash.words, c = q[n + 0], e = q[n + 1], j = q[n + 2], k = q[n + 3], z = q[n + 4], r = q[n + 5], t = q[n + 6], w = q[n + 7], v = q[n + 8], A = q[n + 9], B = q[n + 10], C = q[n + 11], u = q[n + 12], D = q[n + 13], E = q[n + 14], x = q[n + 15], f = a[0], m = a[1], g = a[2], h = a[3], f = p(f, m, g, h, c, 7, b[0]), h = p(h, f, m, g, e, 12, b[1]), g = p(g, h, f, m, j, 17, b[2]), m = p(m, g, h, f, k, 22, b[3]), f = p(f, m, g, h, z, 7, b[4]), h = p(h, f, m, g, r, 12, b[5]), g = p(g, h, f, m, t, 17, b[6]), m = p(m, g, h, f, w, 22, b[7]), f = p(f, m, g, h, v, 7, b[8]), h = p(h, f, m, g, A, 12, b[9]), g = p(g, h, f, m, B, 17, b[10]), m = p(m, g, h, f, C, 22, b[11]), f = p(f, m, g, h, u, 7, b[12]), h = p(h, f, m, g, D, 12, b[13]), g = p(g, h, f, m, E, 17, b[14]), m = p(m, g, h, f, x, 22, b[15]), f = d(f, m, g, h, e, 5, b[16]), h = d(h, f, m, g, t, 9, b[17]), g = d(g, h, f, m, C, 14, b[18]), m = d(m, g, h, f, c, 20, b[19]), f = d(f, m, g, h, r, 5, b[20]), h = d(h, f, m, g, B, 9, b[21]), g = d(g, h, f, m, x, 14, b[22]), m = d(m, g, h, f, z, 20, b[23]), f = d(f, m, g, h, A, 5, b[24]), h = d(h, f, m, g, E, 9, b[25]), g = d(g, h, f, m, k, 14, b[26]), m = d(m, g, h, f, v, 20, b[27]), f = d(f, m, g, h, D, 5, b[28]), h = d(h, f, m, g, j, 9, b[29]), g = d(g, h, f, m, w, 14, b[30]), m = d(m, g, h, f, u, 20, b[31]), f = l(f, m, g, h, r, 4, b[32]), h = l(h, f, m, g, v, 11, b[33]), g = l(g, h, f, m, C, 16, b[34]), m = l(m, g, h, f, E, 23, b[35]), f = l(f, m, g, h, e, 4, b[36]), h = l(h, f, m, g, z, 11, b[37]), g = l(g, h, f, m, w, 16, b[38]), m = l(m, g, h, f, B, 23, b[39]), f = l(f, m, g, h, D, 4, b[40]), h = l(h, f, m, g, c, 11, b[41]), g = l(g, h, f, m, k, 16, b[42]), m = l(m, g, h, f, t, 23, b[43]), f = l(f, m, g, h, A, 4, b[44]), h = l(h, f, m, g, u, 11, b[45]), g = l(g, h, f, m, x, 16, b[46]), m = l(m, g, h, f, j, 23, b[47]), f = s(f, m, g, h, c, 6, b[48]), h = s(h, f, m, g, w, 10, b[49]), g = s(g, h, f, m, E, 15, b[50]), m = s(m, g, h, f, r, 21, b[51]), f = s(f, m, g, h, u, 6, b[52]), h = s(h, f, m, g, k, 10, b[53]), g = s(g, h, f, m, B, 15, b[54]), m = s(m, g, h, f, e, 21, b[55]), f = s(f, m, g, h, v, 6, b[56]), h = s(h, f, m, g, x, 10, b[57]), g = s(g, h, f, m, t, 15, b[58]), m = s(m, g, h, f, D, 21, b[59]), f = s(f, m, g, h, z, 6, b[60]), h = s(h, f, m, g, C, 10, b[61]), g = s(g, h, f, m, j, 15, b[62]), m = s(m, g, h, f, A, 21, b[63]); a[0] = a[0] + f | 0; a[1] = a[1] + m | 0; a[2] = a[2] + g | 0; a[3] = a[3] + h | 0 }, _doFinalize: function() { var b = this._data, n = b.words, a = 8 * this._nDataBytes, c = 8 * b.sigBytes; n[c &gt;&gt;&gt; 5] |= 128 &lt;&lt; 24 - c % 32; var e = u.floor(a / 4294967296); n[(c + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 15] = (e &lt;&lt; 8 | e &gt;&gt;&gt; 24) &amp; 16711935 | (e &lt;&lt; 24 | e &gt;&gt;&gt; 8) &amp; 4278255360; n[(c + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 14] = (a &lt;&lt; 8 | a &gt;&gt;&gt; 24) &amp; 16711935 | (a &lt;&lt; 24 | a &gt;&gt;&gt; 8) &amp; 4278255360; b.sigBytes = 4 * (n.length + 1); this._process(); b = this._hash; n = b.words; for (a = 0; 4 &gt; a; a++) c = n[a], n[a] = (c &lt;&lt; 8 | c &gt;&gt;&gt; 24) &amp; 16711935 | (c &lt;&lt; 24 | c &gt;&gt;&gt; 8) &amp; 4278255360; return b }, clone: function() { var b = v.clone.call(this); b._hash = this._hash.clone(); return b } }); t.MD5 = v._createHelper(r); t.HmacMD5 = v._createHmacHelper(r) })(Math); (function() { var u = CryptoJS, p = u.lib, d = p.Base, l = p.WordArray, p = u.algo, s = p.EvpKDF = d.extend({ cfg: d.extend({ keySize: 4, hasher: p.MD5, iterations: 1 }), init: function(d) { this.cfg = this.cfg.extend(d) }, compute: function(d, r) { for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length &lt; q;) { n &amp;&amp; s.update(n); var n = s.update(d).finalize(r); s.reset(); for (var a = 1; a &lt; p; a++) n = s.finalize(n), s.reset(); b.concat(n) } b.sigBytes = 4 * q; return b } }); u.EvpKDF = function(d, l, p) { return s.create(p).compute(d, l) } })(); CryptoJS.lib.Cipher || function(u) { var p = CryptoJS, d = p.lib, l = d.Base, s = d.WordArray, t = d.BufferedBlockAlgorithm, r = p.enc.Base64, w = p.algo.EvpKDF, v = d.Cipher = t.extend({ cfg: l.extend(), createEncryptor: function(e, a) { return this.create(this._ENC_XFORM_MODE, e, a) }, createDecryptor: function(e, a) { return this.create(this._DEC_XFORM_MODE, e, a) }, init: function(e, a, b) { this.cfg = this.cfg.extend(b); this._xformMode = e; this._key = a; this.reset() }, reset: function() { t.reset.call(this); this._doReset() }, process: function(e) { this._append(e); return this._process() }, finalize: function(e) { e &amp;&amp; this._append(e); return this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function(e) { return { encrypt: function(b, k, d) { return (&quot;string&quot; == typeof k ? c : a).encrypt(e, b, k, d) }, decrypt: function(b, k, d) { return (&quot;string&quot; == typeof k ? c : a).decrypt(e, b, k, d) } } } }); d.StreamCipher = v.extend({ _doFinalize: function() { return this._process(!0) }, blockSize: 1 }); var b = p.mode = {}, x = function(e, a, b) { var c = this._iv; c ? this._iv = u : c = this._prevBlock; for (var d = 0; d &lt; b; d++) e[a + d] ^= c[d] }, q = (d.BlockCipherMode = l.extend({ createEncryptor: function(e, a) { return this.Encryptor.create(e, a) }, createDecryptor: function(e, a) { return this.Decryptor.create(e, a) }, init: function(e, a) { this._cipher = e; this._iv = a } })).extend(); q.Encryptor = q.extend({ processBlock: function(e, a) { var b = this._cipher, c = b.blockSize; x.call(this, e, a, c); b.encryptBlock(e, a); this._prevBlock = e.slice(a, a + c) } }); q.Decryptor = q.extend({ processBlock: function(e, a) { var b = this._cipher, c = b.blockSize, d = e.slice(a, a + c); b.decryptBlock(e, a); x.call(this, e, a, c); this._prevBlock = d } }); b = b.CBC = q; q = (p.pad = {}).Pkcs7 = { pad: function(a, b) { for (var c = 4 * b, c = c - a.sigBytes % c, d = c &lt;&lt; 24 | c &lt;&lt; 16 | c &lt;&lt; 8 | c, l = [], n = 0; n &lt; c; n += 4) l.push(d); c = s.create(l, c); a.concat(c) }, unpad: function(a) { a.sigBytes -= a.words[a.sigBytes - 1 &gt;&gt;&gt; 2] &amp; 255 } }; d.BlockCipher = v.extend({ cfg: v.cfg.extend({ mode: b, padding: q }), reset: function() { v.reset.call(this); var a = this.cfg, b = a.iv, a = a.mode; if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor; else c = a.createDecryptor, this._minBufferSize = 1; this._mode = c.call(a, this, b &amp;&amp; b.words) }, _doProcessBlock: function(a, b) { this._mode.processBlock(a, b) }, _doFinalize: function() { var a = this.cfg.padding; if (this._xformMode == this._ENC_XFORM_MODE) { a.pad(this._data, this.blockSize); var b = this._process(!0) } else b = this._process(!0), a.unpad(b); return b }, blockSize: 4 }); var n = d.CipherParams = l.extend({ init: function(a) { this.mixIn(a) }, toString: function(a) { return (a || this.formatter).stringify(this) } }), b = (p.format = {}).OpenSSL = { stringify: function(a) { var b = a.ciphertext; a = a.salt; return (a ? s.create([1398893684, ]).concat(a).concat(b) : b).toString(r) }, parse: function(a) { a = r.parse(a); var b = a.words; if (1398893684 == b[0] &amp;&amp; 1701076831 == b[1]) { var c = s.create(b.slice(2, 4)); b.splice(0, 4); a.sigBytes -= 16 } return n.create({ ciphertext: a, salt: c }) } }, a = d.SerializableCipher = l.extend({ cfg: l.extend({ format: b }), encrypt: function(a, b, c, d) { d = this.cfg.extend(d); var l = a.createEncryptor(c, d); b = l.finalize(b); l = l.cfg; return n.create({ ciphertext: b, key: c, iv: l.iv, algorithm: a, mode: l.mode, padding: l.padding, blockSize: a.blockSize, formatter: d.format }) }, decrypt: function(a, b, c, d) { d = this.cfg.extend(d); b = this._parse(b, d.format); return a.createDecryptor(c, d).finalize(b.ciphertext) }, _parse: function(a, b) { return &quot;string&quot; == typeof a ? b.parse(a, this) : a } }), p = (p.kdf = {}).OpenSSL = { execute: function(a, b, c, d) { d || (d = s.random(8)); a = w.create({ keySize: b + c }).compute(a, d); c = s.create(a.words.slice(b), 4 * c); a.sigBytes = 4 * b; return n.create({ key: a, iv: c, salt: d }) } }, c = d.PasswordBasedCipher = a.extend({ cfg: a.cfg.extend({ kdf: p }), encrypt: function(b, c, d, l) { l = this.cfg.extend(l); d = l.kdf.execute(d, b.keySize, b.ivSize); l.iv = d.iv; b = a.encrypt.call(this, b, c, d.key, l); b.mixIn(d); return b }, decrypt: function(b, c, d, l) { l = this.cfg.extend(l); c = this._parse(c, l.format); d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt); l.iv = d.iv; return a.decrypt.call(this, b, c, d.key, l) } }) }(); (function() { for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 &gt; c; c++) a[c] = 128 &gt; c ? c &lt;&lt; 1 : c &lt;&lt; 1 ^ 283; for (var e = 0, j = 0, c = 0; 256 &gt; c; c++) { var k = j ^ j &lt;&lt; 1 ^ j &lt;&lt; 2 ^ j &lt;&lt; 3 ^ j &lt;&lt; 4, k = k &gt;&gt;&gt; 8 ^ k &amp; 255 ^ 99; l[e] = k; s[k] = e; var z = a[e], F = a[z], G = a[F], y = 257 * a[k] ^ 16843008 * k; t[e] = y &lt;&lt; 24 | y &gt;&gt;&gt; 8; r[e] = y &lt;&lt; 16 | y &gt;&gt;&gt; 16; w[e] = y &lt;&lt; 8 | y &gt;&gt;&gt; 24; v[e] = y; y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e; b[k] = y &lt;&lt; 24 | y &gt;&gt;&gt; 8; x[k] = y &lt;&lt; 16 | y &gt;&gt;&gt; 16; q[k] = y &lt;&lt; 8 | y &gt;&gt;&gt; 24; n[k] = y; e ? (e = z ^ a[a[a[G ^ z]]], j ^= a[a[j]]) : e = j = 1 } var H = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54 ], d = d.AES = p.extend({ _doReset: function() { for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; j &lt; a; j++) if (j &lt; d) e[j] = c[j]; else { var k = e[j - 1]; j % d ? 6 &lt; d &amp;&amp; 4 == j % d &amp;&amp; (k = l[k &gt;&gt;&gt; 24] &lt;&lt; 24 | l[k &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | l[k &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | l[k &amp; 255]) : (k = k &lt;&lt; 8 | k &gt;&gt;&gt; 24, k = l[k &gt;&gt;&gt; 24] &lt;&lt; 24 | l[k &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | l[k &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | l[k &amp; 255], k ^= H[j / d | 0] &lt;&lt; 24); e[j] = e[j - d] ^ k } c = this._invKeySchedule = []; for (d = 0; d &lt; a; d++) j = a - d, k = d % 4 ? e[j] : e[j - 4], c[d] = 4 &gt; d || 4 &gt;= j ? k : b[l[k &gt;&gt;&gt; 24]] ^ x[l[k &gt;&gt;&gt; 16 &amp; 255]] ^ q[l[k &gt;&gt;&gt; 8 &amp; 255]] ^ n[l[k &amp; 255]] }, encryptBlock: function(a, b) { this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l) }, decryptBlock: function(a, c) { var d = a[c + 1]; a[c + 1] = a[c + 3]; a[c + 3] = d; this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s); d = a[c + 1]; a[c + 1] = a[c + 3]; a[c + 3] = d }, _doCryptBlock: function(a, b, c, d, e, j, l, f) { for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; r &lt; m; r++) var q = d[g &gt;&gt;&gt; 24] ^ e[h &gt;&gt;&gt; 16 &amp; 255] ^ j[k &gt;&gt;&gt; 8 &amp; 255] ^ l[n &amp; 255] ^ c[p++], s = d[h &gt;&gt;&gt; 24] ^ e[k &gt;&gt;&gt; 16 &amp; 255] ^ j[n &gt;&gt;&gt; 8 &amp; 255] ^ l[g &amp; 255] ^ c[p++], t = d[k &gt;&gt;&gt; 24] ^ e[n &gt;&gt;&gt; 16 &amp; 255] ^ j[g &gt;&gt;&gt; 8 &amp; 255] ^ l[h &amp; 255] ^ c[p++], n = d[n &gt;&gt;&gt; 24] ^ e[g &gt;&gt;&gt; 16 &amp; 255] ^ j[h &gt;&gt;&gt; 8 &amp; 255] ^ l[k &amp; 255] ^ c[p++], g = q, h = s, k = t; q = (f[g &gt;&gt;&gt; 24] &lt;&lt; 24 | f[h &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[k &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[n &amp; 255]) ^ c[p++]; s = (f[h &gt;&gt;&gt; 24] &lt;&lt; 24 | f[k &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[n &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[g &amp; 255]) ^ c[p++]; t = (f[k &gt;&gt;&gt; 24] &lt;&lt; 24 | f[n &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[g &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[h &amp; 255]) ^ c[p++]; n = (f[n &gt;&gt;&gt; 24] &lt;&lt; 24 | f[g &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[h &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[k &amp; 255]) ^ c[p++]; a[b] = q; a[b + 1] = s; a[b + 2] = t; a[b + 3] = n }, keySize: 8 }); u.AES = p._createHelper(d) })(); module.exports = CryptoJS 需要使用加密操作的接口文件中，引入已经封装加解密方法进行接口的加解密操作 &lt;!-- 引入方法 --&gt; const CryptoJS = require('./utils/public'); &lt;!-- 拼接需要调用的接口名称和所需的参数信息 --&gt; var data = '{&quot;url&quot;: &quot;/login/sendSMS&quot;, &quot;openid&quot;: &quot;'+ wx.getStorageSync('openid') +'&quot;, &quot;userName&quot;: &quot;'+ this.data.oaName +'&quot;, &quot;userMobile&quot;: &quot;'+ this.data.tel +'&quot;}'; &lt;!-- 使用CryptoJS.Encryp将拼接的信息进行加密，得到密文字符串 --&gt; var encrypt = CryptoJS.Encrypt(data) &lt;!-- 此处微信小程序为例，请求调用 --&gt; request({ &lt;!-- url处填写和后端协商好的固定接口地址，接口的二次封装 --&gt; url: 'http://localhost:8080/miniprogram-union/common', &lt;!-- data处传拼接和加密好的接口名称和参数信息 --&gt; data: encrypt, method: &quot;POST&quot;, }).then(result =&gt; { &lt;!-- 通过CryptoJS.Decrypt解密方法解密后端传过来的返回值--&gt; var res = CryptoJS.Decrypt(result.data); &lt;!-- 解密得到的值一般为 JSON 对象形式，需要转为js对象 --&gt; var smsInfo = JSON.parse(res) &lt;!-- 微信小程序中将得到的数据放到data中并在页面渲染 --&gt; this.setData({ smsInfoList: smsInfo.data }) }) ","link":"https://qinyu312.github.io/post/jia-mi-cao-zuo/"},{"title":"后端代码本地打包运行","content":"zsh: command not found: mvn 解决命令 source ~/.bash_profile 以Mac环境为例，需要先检查本地是否安装Maven mvn -v 安装mvn后，由于下载较慢，建议配置阿里云打包，进入maven目录下的 conf 文件下，打开settings.xml 文件，添加以下代码 &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 进入后端代码所在的项目目录下，运行Maven打包命令 mvn package -DskipTests 停止运行命令 mvn clean 运行完成命令后会在项目文件夹下得到一个target文件，target文件下的war就可以在本地 tomcat 运行了需要下载安装 Tomcat 来运行一个war包 4. 将后端项目代码中已经配置好的 xxx.war 文件拷贝至 tomcat文件目录下的 webapps下 5. 命令行进入到 Tomcat 下的 bin 目录 命令行启动 startup.sh sudo sh ./startup.sh 命令行结束运行 sudo sh ./shutdown.sh 命令行查看 Tomcat所有进程 ps -ef|grep java 命令行强制终止 某些 Tomcat进程 kill -9 端口号 startup.sh 启动后就可以在浏览器输入 localhost:8080测试 Tomcat 启动的情况 把接口请求处的测试地址换成 localhost:8080 调用接口测试，数据正常返回，本地调用成功 ","link":"https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-ben-di-ce-shi-jie-kou/"},{"title":"微信小程序开发随记","content":"button 无法设置宽高 当前版本的微信小程序，在.wxss文件里设置Button宽度无效,调整不会被应用到元素上 .btn { width: 80%; height: 80rpx; } 第一种方式是把 app.json里的 style: v2语句删掉。 这样虽然也可以解决问题，但会导致全局的样式变化。 第二种方式可以很便捷的解决问题，就是直接在 button标签的行内添加样式 &lt;button style=&quot;width: 80%; height: 80rpx&quot;&gt;提交&lt;/button&gt; 按钮宽高生效 微信小程序跳转操作 &lt;!-- 1. 跳转到页面后左上角不会有返回角标及操作，但是不可以跳转到根级别的tab页面 --&gt; wx.redirectTo({ url: '/pages/oa_login/index', }) &lt;!-- 2. 这个方法之能跳转到 app.json 里面定义的 主 tab页面，如首页，我的这种 --&gt; wx.switchTab({ url: '/pages/index/index', }) &lt;!-- 3. 页面跳转且会有返回操作，但是不可以跳转到根级别的tab页面 --&gt; wx.navigataTo({ url: '/pages/oa_login/index', }) &lt;!-- 绝对路径跳转，一般用于页面token失效需要重新跳转到登陆页面使用 --&gt; wx.reLaunch({ //绝对路径跳转 url: &quot;/pages/health_page/health_list/index&quot;, }); 微信小程序轻提示 wx.showToast({ title: info.message, icon: 'none', duration: 1500 }) 微信小程序返回上一页面数据不刷新解决 当你在某活动详情页调用方法后数据发生改变，然后返回上一个页面，活动列表中的数据没有发生更新，此时可以使用以下两种方式 简单粗暴的 onShow:function() {}方法中调用 获取列表数据的方法 ，但是会重新加载整个页面，增加开销且比较慢。 onShow: function() { this.onLoad(); } 在子页面中进行某些操作的时候，后台刷新父页面，此时返回父页面数据已更新且不会重新加载，比较推荐的用法，快速且不会有多余消耗 &lt;!-- 父页面定义更新方法 --&gt; changeData: function() { this.onLoad(); }, &lt;!-- 子页面某处触发方法 --&gt; changeParentData: function() { var pages = getCurrentPages(); //当前页面栈 if(pages.length &gt; 1) { var beforePage = pages[pages.length - 2] //获取上一个页面的实例对象 beforePage.changeData() // 触发父页面中的更新方法 console.log('更新成功了吗？？？') } }, 微信小程序获取当前经纬度定位信息 在微信小程序开发者工具中测试获取到的经纬度信息有较大的偏差，不够准确，手机上测试相对较为精准，后续会持续优化精准度。 { &quot;pages&quot;:[ &quot;pages/index/index&quot;, ], &lt;!-- 是否允许获取定位信息 --&gt; &quot;permission&quot;: { &quot;scope.userLocation&quot;: { &quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot; } }, } &lt;!-- 在需要获取定位信息的 js 里面调用微信获取经纬度位置的API wx.getLocation({}) --&gt; onLoad: function(options) { // 获取当前经纬度定位信息API wx.getLocation({ altitude: 'altitude', isHighAccuracy: true, success(res) { &lt;!-- 返回定位信息 longitude字段为经度 latitude为纬度--&gt; console.log(res) this.setData({ // 经度 longitude: res.longitude, // 纬度 latitude: res.latitude }) } }) } 微信小程序时间戳转换成微信时间规范 getUnionList() { &lt;!-- 参数加密请求 --&gt; var data = '{&quot;url&quot;: &quot;/data/infoList&quot;, &quot;userId&quot;: &quot;'+ wx.getStorageSync('userId') +'&quot;}'; var encrypt = CryptoJS.Encrypt(data) request({ url: '', data: encrypt, method: &quot;POST&quot;, }) .then(result =&gt; { var res = CryptoJS.Decrypt(result.data); var unionInfo = JSON.parse(res) unionInfo.data.forEach(element =&gt; { let daySec, dayMin, dayHour, dayS let timeNow = new Date().getTime() let ts = (timeNow - element.mienTime) / 1000 dayS = Math.round(ts / (24 * 60 * 60)) dayHour = Math.round(ts / (60 * 60)) dayMin = Math.round(ts / 60) daySec = Math.round(ts) if (dayS &gt; 7 &amp;&amp; dayS &lt; 365) { var date=new Date(parseInt(element.infoDate)); var mon = date.getMonth()+1; var day = date.getDate(); element.infoDate = mon+'/'+day; return mon+'/'+day; } else if (dayS &gt; 2 &amp;&amp; dayS &lt; 7) { element.infoDate = `${dayS} 天以前` return `${dayS} 天以前` } else if(dayS &gt; 0 &amp;&amp; dayS &lt; 2) { element.infoDate = `${dayS} 天以前` return `${dayS} 天以前` } else if (dayS &lt;= 0 &amp;&amp; dayHour &gt; 0) { element.infoDate = `${dayHour} 小时以前` return `${dayHour} 小时以前` } else if (dayHour &lt;= 0 &amp;&amp; dayMin &gt; 0) { element.infoDate = `${dayMin} 分钟以前` return `${dayMin} 分钟以前` } else if (dayMin &lt;= 0 &amp;&amp; daySec &gt;= 0) { element.infoDate = '刚刚' return '刚刚' } else { var date=new Date(parseInt(element.infoDate)); var year=date.getFullYear(); var mon = date.getMonth()+1; var day = date.getDate(); element.infoDate = year+'/'+mon+'/'+day; return year+'/'+mon+'/'+day; } }); console.log(unionInfo) this.setData({ unionList: unionInfo.data, }) }) }, ","link":"https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-kai-fa/"},{"title":"Angular项目避坑指南","content":"最近收到一个新的需求，有一个Angular项目需要兼容到 IE8 以上版本，实在让我又惊又喜，惊的是都 2020年了，还甩不掉 IE8 这颗烫手山芋；喜的是第一次接触 Angular项目，不知道又会学到什么新的知识呢。拉到项目代码后，本地启动，果然给我来了迎头痛击。 首先确认本地安装有Node.js环境后，全局安装 Angular-cli ，也就是Angular脚手架,命令行输入： cnpm install -g @angular/cli 然后就是老步骤，下载node_modules 依赖包 cnpm install 之后直接 ng serve 启动命令有点别具一格的简洁，直接芜湖🛫️ ng serve 接下来，就是见证 奇迹（打脸）的时刻 我敲完命令一回车，啪的一下满屏飙红报错，很快啊，我就看到是依赖包的问题，按照传统功夫的看到为止，我没有看下去，上去就是一个卸载依赖，一个 cnpm install ，我大意了啊，没有删完，接着又是飙红报错。Angular 不讲武德，来欺，为难我入行一年多点的小前端，希望它以后耗子尾汁！ 最后在 node_modules 下的 less-loader 加上一句 javascriptEnabled: true ，问题得到解决 项目成功启动，再来解决兼容IE8的问题，Angular，官方文档浏览器兼容部分我们可以看到， IE 10, 11, 9，也就是说连官方都放弃去做IE9一下的兼容了。 忍不住又想吐槽IE一把，但是客户需求在身，只能硬着头皮做了，因为Angular在国内市场的使用还不是特别频繁，所以我在百度没有什么收获之后，决定翻墙去 Google ，Angular 也不亏是 Google的亲儿子。方案当然是有的。需要将Angular版本降低至 1.2一以下可以对IE8进行兼容适配。然后就是传统功夫的卸载新版本，安装旧版本。 &lt;!-- 卸载新版本 --&gt; cnpm uninstall -g @angular/cli &lt;!-- 安装新版本 --&gt; cnpm install -g @angular/cli/1.1 问题得到解决，兼容是好了，样式又乱的简直是乱他妈妈给乱开门 - 乱到家了。不说了，我要去调样式了！ ","link":"https://qinyu312.github.io/post/angular-xiang-mu-bi-keng-zhi-nan/"},{"title":"React各种零碎知识合集","content":"React里的事件 &lt;!-- onChange事件 --&gt; this.handleChange = this.handleChange.bind(this) handleChange(event) { this.setState({value: event.target.value}) } &lt;textarea onChange={ this.handleChange } /&gt; &lt;!-- onSubmit事件 --&gt; this.handleSubmit = this,handleSubmit(this) handleSubmit(event) { alert('提交' + this.state.value + '成功!') event.preventDefault() &lt;!-- 清除默认事件 --&gt; } &lt;form onSubmit= { this.handleSubmit }&gt;&lt;/form&gt; ","link":"https://qinyu312.github.io/post/js-ge-chong-ling-sui-zhi-shi-he-ji/"},{"title":"关于各种浏览器兼容(持续更新中)","content":"IE条件注释 IE10以下版本可用，IE11已经取消支持 &lt;!--[if lte IE 8]&gt; &lt;script src=&quot;/js/html5.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/css3-mediaqueries.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;/css/ie8.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; &lt;![endif]--&gt; 因为IE11不支持条件注释，可以使用正则判断 var browser = navigator.appName; var ie11 = !!navigator.userAgent.match(/Trident\\/7\\./); if (browser == 'Microsoft Internet Explorer' || ie11 == true) { //do something } IE9部分页面不显示的问题 IE9是不支持 console.log 打印输出语句的，在非开发者模式下会阻塞不会执行后面的内容 IE9 及以下 IE浏览器不支持placeholder属性 引入 jquery和用于解决这个属性兼容的CDN &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.ijquery.cn/js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.ijquery.cn/js/jquery.placeholder.min.js&quot;&gt;&lt;/script&gt; &lt;%--兼容IE9及以下input输入框，textarea文本框不支持提示文本placeholder属性的问题--%&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $('input, textarea').placeholder(); }); &lt;/script&gt; 上面这种方法在HTML文件中亲测有效，但是不知道为什么在前后端不分离JSP项目中不会生效，以某国企老项目为例，需要在每个页面的JS代码中加上 &lt;!-- css代码 --&gt; .phcolor{ color:#999; } &lt;!-- js代码 --&gt; // placeholder兼容IE9 $(function(){ //判断浏览器是否支持placeholder属性 supportPlaceholder='placeholder'in document.createElement('input'), placeholder=function(input){ var text = input.attr('placeholder'), defaultValue = input.defaultValue; if(!defaultValue){ input.val(text).addClass(&quot;phcolor&quot;); } input.focus(function(){ if(input.val() == text){ $(this).val(&quot;&quot;); } }); input.blur(function(){ if(input.val() == &quot;&quot;){ $(this).val(text).addClass(&quot;phcolor&quot;); } }); //输入的字符不为灰色 input.keydown(function(){ $(this).removeClass(&quot;phcolor&quot;); }); }; //当浏览器不支持placeholder属性时，调用placeholder函数 if(!supportPlaceholder){ $('input').each(function(){ text = $(this).attr(&quot;placeholder&quot;); if($(this).attr(&quot;type&quot;) == &quot;text&quot;){ placeholder($(this)); } }); } }); 换行word-wrap与word-break兼容ie和火狐、chrome word-wrap控制换行，使用break-word时，会强制进行换行，中文没问题，英文语句没问题，长串的英文不会生效。 word-break控制是否断词 normal是默认情况，英文单词不被拆开 break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题。 keep-all，是指Chinese, Japanese, and Korean不断词。即只用此时，不用word-wrap，中文就不会换行了。（英文语句正常。） 所以，要做到英文和中文等强制换行，需要组合使用如下 &lt;p style=&quot;word-wrap: break-word; word-break: break-all&quot;&gt;&lt;/p&gt; JS判断移动端浏览器还是PC浏览器 window.parent.location.href = /Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent) ? &quot;${context}/erpGuaranteeFlowController/findErpGuaranteeApprovalNew.do&quot; : &quot;${context}/erpItosController/toDoList&quot;; var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) &gt; 0) { flag = false; break; } } if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) { &lt;!-- 移动端设备 --&gt; h5flag = false } else { &lt;!-- pc端设备 --&gt; h5flag = true } ","link":"https://qinyu312.github.io/post/guan-yu-ge-chong-ie-jian-rong/"},{"title":"初识React","content":"搭建React项目 在装有node.js的基础上，命令行输入命令 npx create-react-app item-name 即可创建一个React项目，项目结构如下 JSX语法 src文件下的index.js是项目的入口文件，文件中先后引入了react和react-dom两个库。 ReactDOM.render(&lt;h2&gt;hello react&lt;/h2&gt;, document.getElementById('root')); ReactDOM实例通过render方法，将前面的h2标签元素，添加到root元素中，而id为root的元素是public文件的index.html文件的元素。 JSX语法由JavaScript语法 和 XML语法组成，通俗来说就是，当我们在JSX语句中遇到 &lt;&gt; 的形式的，按照XML的形式来解析，因为他们是标签；遇到 {} 按照javaScript来解析，表示JS语法。 const a = ( &lt;div&gt; &lt;p&gt;hello react&lt;/p&gt; &lt;/div&gt; ) 如果存在标签结构，并且标签结构需要换行的话，可以使用 （）的形式进行表示 React 元素渲染 这里通过一个实例了解react的元素渲染 &lt;!-- 首先定义一个方法 --&gt; function nowTime() { const ele = ( &lt;!-- 使用()的形式，可以换行写标签语法 --&gt; &lt;h2&gt;get now time&lt;/h2&gt; &lt;!-- 定义一个获取当前时间的方法 --&gt; &lt;h1&gt;now time is { new Date().toLocalTimeString() } &lt;/h1&gt; ) &lt;!-- 渲染这个获取当前时间的方法 --&gt; reactDOM.render(ele, document.getElementById('root)); } &lt;!-- 定时器每隔一秒会调用一次该方法，实现实时更新当前时间 --&gt; setInterval(() =&gt; { nowTime() },1000) React 组件 关于Ract组件，区别于vue的以 .vue为后缀结尾的文件，\bReact的组件可以是以 .js 为后缀的文件，也可以是 .jsx 为\b后缀的文件\b命名。编写React组件的时候，创建 .js 的组件是没有代码语法提示的，而创建 .jsx 组件文件是有代码语法提示的。 创建React组件分别有两种方式，第一种是通过 类的形式创建组件，第二种是通过Hook的形式创建。并且组件之间是可以互相引入和使用的，以标签的形式存在！ &lt;!-- 第一种写法 --&gt; &lt;!-- 创建一个React组件首先需要引入 React 库 --&gt; import React from 'react' &lt;!-- 创建\b一个类App继承React所提供的Component组件的对象 --&gt; class App extends React Component { &lt;!-- rander(){} 渲染函数 --&gt; render() { &lt;p&gt;\b渲染函数中写你需要这个组件展示的内容，或者要做什么&lt;/p&gt; } } &lt;!-- 导出组件 --&gt; export default App &lt;!-- 第二种写法 --&gt; import React from 'react' export default class App extends React.Component{ render() { return { &lt;div&gt; &lt;p&gt;直接导出并继承React下的Component对象&lt;/p&gt; &lt;/div&gt; } } } &lt;!-- 函数组件 --&gt; function fun(props) { return ( &lt;div&gt; &lt;h3&gt;函数组件&lt;/h3&gt; &lt;/div&gt; ) } &lt;!-- ES6 class类组件 --&gt; class App extends React.Component { render() { return ( &lt;div&gt; &lt;h3&gt;ES6 class类创建组件&lt;/h3&gt; &lt;/div&gt; ) } } 然后在需要使用的地方引入该组件,并将其放置在渲染函数中渲染即可。 import 'App' from './App.jsx' ReactDOM.render(&lt;App /&gt;, document.getElementById('root)); Props组件动态传参 React里面的组件传参通过 props 父组件传递参数给子组件 &lt;!-- 子组件 --&gt; import React from 'react' export default class Son extends React.Component { render() { return { &lt;div&gt; &lt;ul&gt; { &lt;!-- 子组件中 通过this.props的方式获取父组件传递过来的数据，也就是arr ,然后通过map来遍历获取到的数据--&gt; this.props.arr.map((element, index) =&gt; { &lt;!-- 将遍历得到的数据放在li标签中渲染返回，key值需要绑定index唯一值，否则会抛出语法error --&gt; return &lt;li key={ index }&gt;{ element }&lt;/li&gt; }) } &lt;/ul&gt; &lt;/div&gt; } } } import React from 'react' &lt;!-- 引入子组件 --&gt; import Son from './son' export default class Father extends React.Component { render() { &lt;!-- 父组件定义两个数组，用于传递给子组件使用 --&gt; const arrOne = ['Vue' , 'React', 'Angular'], arrTwo = ['Java', 'Pythen', 'C++'] return ( &lt;!-- 在两个子组件中分别传入不同的数据 --&gt; &lt;Son arr={ arrOne } /&gt; &lt;Son arr={ arrTwo } /&gt; ) } } 子组件传递参数给父组件 &lt;!-- 父组件 --&gt; import React from 'react' import Son from './son' export defaul{t class Father React.Component { &lt;!-- 首先定义\bstate用来存储\btitle的状态 --&gt; constructor() { super(); this.state = { title: ‘最初的标题’ } } clickChange = () =&gt; { this.setState({ title: '最后的标题' }) } render() { return ( &lt;div&gt; 父子组件传参 &lt;/div&gt; &lt;!-- 使用子组件,title最开始为 ‘最初的标题’， changeFatherProps 被子组件中的点击事件触发从而执行父组件中的clickChange方法，完成对标题的修改 --&gt; &lt;son title={ this.state.title } changeFatherProps={ this.clickChange } /&gt; ) } } &lt;!-- 子组件 --&gt; import React from 'react' export defaul{t class Father React.Component { changeFather = () =&gt; { &lt;!-- 通过 this.props 的方式 --&gt; this.prpos.changFatherProps() } render() { return &lt;div&gt; 父子组件传参 &lt;!-- \b点击button事件会触发父组件中方法的执行，将标题修改 --&gt; &lt;button onClick={ this.changeFather }&gt;点击传参修改&lt;button&gt; &lt;/div&gt; } } state 状态 &lt;!-- 通过this.state定义保存数据和状态 --&gt; this.state = { flag: true, count: 10, } &lt;!-- 需要修改状态值的时候通过 this.setState({})的方式进行修改 --&gt; this.setState({ flag: false, count: this.state.count ++ }) 生命周期函数 随着我们对React理解和使用的原来越多，生命周期会越来越有参考价值 生命周期函数包括: componentWillMount: 在组件创建之前执行 componentDidMount: 在\b组件渲染之后执行 shouldComponentUpdata: 返回\b true 和 false, true代表允许改变， false代表不允许改变 componentWillUpdata: 数据在改变之前执行（state, props） conponentDidUpdata: 代表数据修改完成（state, props） conponentWillReveiceProps: props发生改变时执行的生命周期函数 conponentWillUnMount: 组件卸载前执行 探讨关于 setState 更新是同步操作还是异步操作的问题 setState会引起视图的重绘 官方文档解答:在可控的情况下是异步的，在不可控的情况下是同步的 create-react-app 按需加载Antd 组件 命令行输入 cnpm run eject 拉取React的配置文件 文件被修改时，会抛出异常，由于GIt的原因导致,此时找到文件目录，按下shift + command + . 显示隐藏文件，删除 .git 文件，重新 cnpm run eject即可，安装完成后目录多出了两个文件，分别是config和script文件，config文件就是webpack配置文件 安装一个依赖文件 cnpm install babel-plugin-import --save-dev React-Router React路由也分为两种路由模式： BrowserRouter 和 HashRouter 两者的区别在于 HashRouter使用的是锚点链接的形式，表现为 # 的形式， # 号后面为跳转的二级路由地址 而BrowserRouter 则使用了HTML5的新特性，主要是 history.push() 实现。 实际开发中， BrowserRouter 会在项目上线之后存在一些问题，就是需要后台配合做一些配置处理和重定向，否则会很容易跳转到 404 页面，而 HashRouter 则不会有这个问题。 &lt;!-- 安装 react-router --&gt; cnpm install react-router-dom -save &lt;!-- 使用 react-router --&gt; import {BrowserRouter as Router, Link,NavLink, Route, Redirect} from &quot;react-router-dom&quot; &lt;!-- 引入 react-router 相关的组件 --&gt; function App() { render() { return( &lt;div&gt; &lt;!-- 在 Router盒子中嵌套 Route盒子，在Route中定义路由路径和路径对应的页面 --&gt; &lt;Router&gt; &lt;switch&gt; &lt;Route path=&quot;/login&quot; component={ Login }&gt;&lt;/Route&gt; &lt;Route path=&quot;/home&quot; component={ Home }&gt;&lt;/Route&gt; &lt;Route path=&quot;/home/detail&quot; exact={ true } component={ detail }&gt;&lt;/Route&gt; &lt;Route path=&quot;/demo&quot; render={ () =&gt; &lt;div&gt;简约写法，不需要创建页面和组件，直接路由显示render函数中定义路由\b页面内容即可&lt;/div&gt;}&lt;/Route&gt; &lt;!-- 简约写法，不需要创建页面和组件，直接路由显示render函数中定义路由\b页面内容即可 --&gt; &lt;/switch&gt; &lt;!-- 当路由规则包裹在switch内的时，\b路由就不会同时显示多个，\b而是按照当前路径进行匹配 --&gt; &lt;/Router&gt; &lt;!-- 路由匹配规则之，如果一个页面上同时存在 路径为 /home 和 /home/detail 两个组件，两个组件都会显示，因为 /home 是包含 /home/detail , 但是正常情况下访问 /home下的/detail是不应该显示上一级组件也就是 /home的，这个时候就需要使用到 路由规则的精准匹配， 使用 exace = { true } 即可开启精准匹配，就不会匹配到下一级路由，只会匹配到 /home 这一个, strict = { true } 可以更加精确的匹配路由，而且使用的时候strice需要和exace一起使用才可以生效，而exace不需要组合使用也可以生效 --&gt; &lt;Link to=&quot;/login&quot;&gt;go login now&lt;/Link&gt; &lt;!-- Link 点击跳转到 to 后面的路由页面 --&gt; &lt;NavLink to=&quot;/login&quot; activeClassName=&quot;setActive&quot;&gt;&lt;/NavLink&gt; &lt;!-- NavLink顾名思义，导航跳转，\b后为当前选中的菜单导航添加一个名为active的class样式，给你这个样式添加颜色或者背景选中时便会添加该样式,activeClassName可以修改样式名称，默认是active --&gt; &lt;Redirect from=&quot;/happy&quot; to=&quot;/login&quot;&gt;&lt;/Redirect&gt; &lt;!-- Redirect可以实现路由重新向，当你访问 的地址是属性中的from，也就是要去的路由为 ‘/happy',\b他会直接重定向到 to所给定的路由地址 --&gt; &lt;/Router&gt; &lt;/div&gt; ) } } &lt;!-- 处于用户体验方面的考虑，我们一般还会在路由匹配中加入 404 等页面，将不存在的路径以更友好地\b方式提醒用户 --&gt; &lt;button&gt;跳转&lt;/button&gt; &lt;!-- 跳转的方法有 两种 props.history.push('/home') 和 props.history.replace('/home') 区别在于， push方法的页面跳转是叠加的，也就是说点击浏览器左上角的返回上一个页面依然有效，因为历史数据被保留； 而replace方法是替换的，所以不会存有历史跳转记录 --&gt; Redux数据\b管理方案 (类似于Vuex) ","link":"https://qinyu312.github.io/post/chu-shi-react/"},{"title":"Ant Design for vue","content":"Ant design for vue按需加载报错问题解决 Ant Design for Vue 官网有详细的按需加载教程，但是在使用之后，项目启动会抛出如下错误 ERROR Failed to compile with 1 error error in ./node_modules/ant-design-vue/es/button/style/index.less Syntax Error: // https://github.com/ant-design/ant-motion/issues/44 .bezierEasingMixin(); ^ Inline JavaScript is not enabled. Is it set in your options? 此时需要把 babel.config.js 配置文件中 module.exports = { presets: [ '@vue/cli-plugin-babel/preset' ], plugins: [ [ &quot;import&quot;, { libraryName: &quot;ant-design-vue&quot;, libraryDirectory: &quot;es&quot;, style: true } ] ] } 的 style 处的 true 改为 &quot;css&quot;，项目即可正常启动并完成按需加载组件库 module.exports = { presets: [ '@vue/cli-plugin-babel/preset' ], plugins: [ [ &quot;import&quot;, { libraryName: &quot;ant-design-vue&quot;, libraryDirectory: &quot;es&quot;, style: &quot;css&quot; } ] ] } ","link":"https://qinyu312.github.io/post/ant-design-for-vue/"},{"title":"Fetch querystring解决跨域","content":"以前写数据接口，对接请求都是使用的Ajax，或者Axios之类的，最近在使用React进行开发，用到了fetch, 和querystring import qs from 'querystring' &lt;!-- get请求 --&gt; fetch(&quot;http://iwenwiki.com/api/blueberrypai/getChengpinInfo.php&quot;) .then(res =&gt; res.json()) .then(data =&gt; { console.log(data) }) &lt;!-- post请求 --&gt; fetch(&quot;http://iwenwiki.com/api/blueberrypai/login.php&quot;, { method: 'POST' , // 请求方式 headers: { // 请求头 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json, text/plain, */*', }, &lt;!-- body: &quot;user_id=iwen@qq.com&amp;password=iwen123&amp;verification_code=crfvw&quot; --&gt; &lt;!-- 此处传参使用字符串传参的方式，所以需要参数间 &amp; 分隔拼串 --&gt; &lt;!-- 如果不想写拼串，也可以直接引入 querystring来进行转换操作如下 --&gt; body: qs.stringify({ 'user_id': 'iwen@qq.com', 'password': 'iwen123', 'verification_code': 'crfvw' }) }) 跨域的解决方案 跨域一般分为两种场景： 开发环境下的跨域问题和生产环境下的跨域问题 此处以React项目开发环境下为例 componentDidMount() { fetch(&quot;http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0&quot;) .then(res =&gt; res.json()) .then(data =&gt; { console.log(data) }) .catch(error =&gt; { console.log(new Error(error)) }) } 此处请求会跨域 需要在 package.json 文件中配置 proxy 代理解决 配置完成 package.json 文件后需要将请求接口前面的已经被代理的地址去掉如下 componentDidMount() { fetch(&quot;/v1/restserver/ting?method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0&quot;) .then(res =&gt; res.json()) .then(data =&gt; { console.log(data) }) .catch(error =&gt; { console.log(new Error(error)) }) } 然后终止此项目进程，重新运行该项目即可使用代理解决跨域问题。打开浏览器调试，接口数据正常请求得到。 fetch 封装常用请求 工具类文件utils下创建 http.js 用于封装常用的请求方法 import qs from 'querystring' &lt;!-- 导出封装的 get 请求 --&gt; export function httpGet(url) { const result = fetch(url) return result } &lt;!-- 导出封装的 post 请求 --&gt; export function httpPost(url, params) { &lt;!-- params为post请求携带参数 --&gt; const result = fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json, text/plain, */*', }, body: qs.stringify(params) }) } 然后在 utils 同级创建一个 api 文件，用于管理接口，api 下新建一个 base.js ，用于向外暴露接口的前置接口地址公共部分(一般情况下接口地址的前半部分是一致的)，然后新建一个 index.js 用于定义业务接口请求统一管理，或者创建不同的功能分类 (如，登录的接口单独写在一个文件里，首页的接口单独写在一个文件里，便于维护) base.js const base = { baseUrl: 'http://iwenwiki.com/api' } index.js import {httpGet, httpPost} from '../utils/http' import base from './base' &lt;!-- 在下面定义各种业务接口 --&gt; const api = { &lt;!-- get请求 --&gt; getUserId() { return httpGet(base.baseUrl + '/blueberrypai/getChengpinInfo.php'); }, &lt;!-- post请求 --&gt; getLogin(params) { return httpPost(baseUrl + '/blueberrypai/login.php', params); } } &lt;!-- 定义完成后导出 api ,在需要调用处导入调用即可 --&gt; export default api 调用接口的文件下 import api from '../api' &lt;!-- get请求不用携带参数，直接获取并打印数据 --&gt; api.getUserId().then(res =&gt; res.json()).then(data =&gt; { console.log(data) }) &lt;!-- post请求调用接口时传入参数，获取并打印数据 --&gt; api.getLogin({ 'user_id': 'iwen@qq.com', 'password': 'iwen123', 'verification_code': 'crfvw' }).then(res =&gt; res.json()).then(data =&gt; { console.log(data) }) ","link":"https://qinyu312.github.io/post/fetch-shu-ju-jie-kou-qing-qiu/"},{"title":"js常用api集锦","content":"##数组API： var pageIds = new Array(); pageIds.push('A'); //数组长度 pageIds.length; //shift：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined var a = [1,2,3,4,5]; var b = a.shift(); //a：[2,3,4,5] b：1 //unshift：将参数添加到原数组开头，并返回数组的长度 var a = [1,2,3,4,5]; var b = a.unshift(-2,-1); //a：[-2,-1,1,2,3,4,5] b：7 //注：在IE6.0下测试返回值总为undefined，FF2.0下测试返回值为7，所以这个方法的返回值不可靠，需要用返回值时可用splice代替本方法来使用。 //pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined var a = [1,2,3,4,5]; var b = a.pop(); //a：[1,2,3,4] b：5 //push：将参数添加到原数组末尾，并返回数组的长度 var a = [1,2,3,4,5]; var b = a.push(6,7); //a：[1,2,3,4,5,6,7] b：7 //concat：返回一个新数组，是将参数添加到原数组中构成的 var a = [1,2,3,4,5]; var b = a.concat(6,7); //a：[1,2,3,4,5] b：[1,2,3,4,5,6,7] //splice(start,deleteCount,val1,val2,)：从start位置开始删除deleteCount项，并从该位置起插入val1,val2, var a = [1,2,3,4,5]; var b = a.splice(2,2,7,8,9); //a：[1,2,7,8,9,5] b：[3,4] var b = a.splice(0,1); //同shift a.splice(0,0,-2,-1); var b = a.length; //同unshift var b = a.splice(a.length-1,1); //同pop a.splice(a.length,0,6,7); var b = a.length; //同push //reverse：将数组反序 var a = [1,2,3,4,5]; var b = a.reverse(); //a：[5,4,3,2,1] b：[5,4,3,2,1] //sort(orderfunction)：按指定的参数对数组进行排序 var a = [1,2,3,4,5]; var b = a.sort(); //a：[1,2,3,4,5] b：[1,2,3,4,5] //slice(start,end)：返回从原数组中指定开始下标到结束下标之间的项组成的新数组 var a = [1,2,3,4,5]; var b = a.slice(2,5); //a：[1,2,3,4,5] b：[3,4,5] //join(separator)：将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符 var a = [1,2,3,4,5]; var b = a.join(&quot;|&quot;); //a：[1,2,3,4,5] b：&quot;1|2|3|4|5&quot; ##DOM常用API： getElementById(id) Node 返回指定结点的引用 getElementsByTagName(name) NodeList 返回文档中所有匹配的元素的集合 createElement(name) Node Node createTextNode(text) Node 创建一个纯文本结点 ownerDocument Document 指向这个节点所属的文档 documentElement Node 返回html节点 document.body Node 返回body节点 //element方法： getAttribute(attributeName) String 返回指定属性的值 setAttribute(attributeName,value) String 给属性赋值 removeAttribute(attributeName) String 移除指定属性和它的值 getElementsByTagName(name) NodeList 返回结点内所有匹配的元素的集合 //node方法： appendChild(child) Node 给指定结点添加一个新的子结点 removeChild(child) Node 移除指定结点的子结点 replaceChild(newChild,oldChild) Node 替换指定结点的子结点 insertBefore(newChild,refChild) Node 在同一层级的结点前面插入新结点 hasChildNodes() Boolean 如果结点有子结点则返回true //node属性： nodeName String 以字符串的格式存放结点的名称 nodeType String 以整型数据格式存放结点的类型 nodeValue String 以可用的格式存放结点的值 parentNode Node 指向结点的父结点的引用 childNodes NodeList 指向子结点的引用的集合 firstChild Node 指向子结点结合中的第一个子结点的引用 lastChild Node 指向子结点结合中的最后一个子结点的引用 previousSibling Node 指向前一个兄弟节点；如果这个节点就是兄弟节点，那么该值为null nextSibling Node 指向后一个兄弟节点；如果这个节点就是兄弟节点，那么该值为null ##数字方法API //·数字型(Number) //1.声明 var i = 1; var i = new Number(1); //2.字符串与数字间的转换 var i = 1; var str = i.toString(); //结果: &quot;1&quot; var str = new String(i); //结果: &quot;1&quot; i = parseInt(str); //结果: 1 i = parseFloat(str); //结果: 1.0 //注意: parseInt,parseFloat会把一个类似于&quot;32G&quot;的字符串,强制转换成32 //3.判断是否为有效的数字 var i = 123; var str = &quot;string&quot;; if( typeof i == &quot;number&quot; ){ } //true //某些方法(如:parseInt,parseFloat)会返回一个特殊的值NaN(Not a Number) //请注意第2点中的[注意],此方法不完全适合判断一个字符串是否是数字型!! i = parseInt(str); if( isNaN(i) ){ } //4.数字型比较 //此知识与[字符串比较]相同 ///5.小数转整数 var f = 1.5; var i = Math.round(f); //结果:2 (四舍五入) var i = Math.ceil(f); //结果:2 (返回大于f的最小整数) var i = Math.floor(f); //结果:1 (返回小于f的最大整数) //6.格式化显示数字 var i = 3.14159; //格式化为两位小数的浮点数 var str = i.toFixed(2); //结果: &quot;3.14&quot; //格式化为五位数字的浮点数(从左到右五位数字,不够补零) var str = i.toPrecision(5); //结果: &quot;3.1415&quot; //7.X进制数字的转换 //不是很懂 -.- var i = parseInt(&quot;0x1f&quot;,16); var i = parseInt(i,10); var i = parseInt(&quot;11010011&quot;,2); //8.随机数 //返回0-1之间的任意小数 var rnd = Math.random(); //返回0-n之间的任意整数(不包括n) var rnd = Math.floor(Math.random() * n) ##日期方法API //·日期型(Date) //1.声明 var myDate = new Date(); //系统当前时间 var myDate = new Date(yyyy, mm, dd, hh, mm, ss); var myDate = new Date(yyyy, mm, dd); var myDate = new Date(&quot;monthName dd, yyyy hh:mm:ss&quot;); var myDate = new Date(&quot;monthName dd, yyyy&quot;); var myDate = new Date(epochMilliseconds); //2.获取时间的某部份 var myDate = new Date(); myDate.getYear(); //获取当前年份(2位) myDate.getFullYear(); //获取完整的年份(4位,1970-????) myDate.getMonth(); //获取当前月份(0-11,0代表1月) myDate.getDate(); //获取当前日(1-31) myDate.getDay(); //获取当前星期X(0-6,0代表星期天) myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数) 时间戳！！ myDate.getHours(); //获取当前小时数(0-23) myDate.getMinutes(); //获取当前分钟数(0-59) myDate.getSeconds(); //获取当前秒数(0-59) myDate.getMilliseconds(); //获取当前毫秒数(0-999) myDate.toLocaleDateString(); //获取当前日期 myDate.toLocaleTimeString(); //获取当前时间 myDate.toLocaleString( ); //获取日期与时间 //3.计算之前或未来的时间 var myDate = new Date(); myDate.setDate(myDate.getDate() + 10); //当前时间加10天 //类似的方法都基本相同,以set开头,具体参考第2点 //4.计算两个日期的偏移量 var i = daysBetween(beginDate,endDate); //返回天数 var i = beginDate.getTimezoneOffset(endDate); //返回分钟数 //5.检查有效日期 //checkDate() 只允许&quot;mm-dd-yyyy&quot;或&quot;mm/dd/yyyy&quot;两种格式的日期 if( checkDate(&quot;2006-01-01&quot;) ){ } //正则表达式(自己写的检查 yyyy-mm-dd, yy-mm-dd, yyyy/mm/dd, yy/mm/dd 四种) var r = /^(\\d{2}|\\d{4})[/-]\\d{1,2}[/-]\\d{1,2}$/; if( r.test( myString ) ){ } ##字符串方法API //·字符串(String) //1.声明 var myString = new String(&quot;Every good boy does fine.&quot;); var myString = &quot;Every good boy does fine.&quot;; //2.字符串连接 var myString = &quot;Every &quot; + &quot;good boy &quot; + &quot;does fine.&quot;; var myString = &quot;Every &quot;; myString += &quot;good boy does fine.&quot;; //3.截取字符串 //截取第 6 位开始的字符 var myString = &quot;Every good boy does fine.&quot;; var section = myString.substring(6); //结果: &quot;good boy does fine.&quot; //截取第 0 位开始至第 10 位为止的字符 var myString = &quot;Every good boy does fine.&quot;; var section = myString.substring(0,10); //结果: &quot;Every good&quot; //截取从第 11 位到倒数第 6 位为止的字符 var myString = &quot;Every good boy does fine.&quot;; var section = myString.slice(11,-6); //结果: &quot;boy does&quot; //从第 6 位开始截取长度为 4 的字符 var myString = &quot;Every good boy does fine.&quot;; var section = myString.substr(6,4); //结果: &quot;good&quot; //4.转换大小写 var myString = &quot;Hello&quot;; var lcString = myString.toLowerCase(); //结果: &quot;hello&quot; var ucString = myString.toUpperCase(); //结果: &quot;HELLO&quot; //5.字符串比较 var aString = &quot;Hello!&quot;; var bString = new String(&quot;Hello!&quot;); if( aString == &quot;Hello!&quot; ){ } //结果: true if( aString == bString ){ } //结果: true if( aString === bString ){ } //结果: false (两个对象不同,尽管它们的值相同) //6.检索字符串 var myString = &quot;hello everybody.&quot;; // 如果检索不到会返回-1,检索到的话返回在该串中的起始位置 if( myString.indexOf(&quot;every&quot;) &gt; -1 ){ } //结果: true ////7.查找替换字符串 var myString = &quot;I is your father.&quot;; var result = myString.replace(&quot;is&quot;,&quot;am&quot;); //结果: &quot;I am your father.&quot; //8.特殊字符: //\\b : 后退符 \\t : 水平制表符 //\\n : 换行符 \\v : 垂直制表符 //\\f : 分页符 \\r : 回车符 //&quot; : 双引号 ' : 单引号 //\\ : 反斜杆 //9.将字符转换成Unicode编码 var myString = &quot;hello&quot;; var code = myString.charCodeAt(3); //返回&quot;l&quot;的Unicode编码(整型) var char = String.fromCharCode(66); //返回Unicode为66的字符 //10.将字符串转换成URL编码 var myString = &quot;hello all&quot;; var code = encodeURI(myString); //结果: &quot;hello%20all&quot; var str = decodeURI(code); //结果: &quot;hello all&quot; //相应的还有: encodeURIComponent() decodeURIComponent() ##数学方法API Math.abs(num) : 返回num的绝对值 Math.acos(num) : 返回num的反余弦值 Math.asin(num) : 返回num的反正弦值 Math.atan(num) : 返回num的反正切值 Math.atan2(y,x) : 返回y除以x的商的反正切值 Math.ceil(num) : 返回大于num的最小整数 Math.cos(num) : 返回num的余弦值 Math.exp(x) : 返回以自然数为底,x次幂的数 Math.floor(num) : 返回小于num的最大整数 10.Math.log(num) : 返回num的自然对数 11.Math.max(num1,num2) : 返回num1和num2中较大的一个 12.Math.min(num1,num2) : 返回num1和num2中较小的一个 13.Math.pow(x,y) : 返回x的y次方的值 14.Math.random() : 返回0到1之间的一个随机数 15.Math.round(num) : 返回num四舍五入后的值 16.Math.sin(num) : 返回num的正弦值 17.Math.sqrt(num) : 返回num的平方根 18.Math.tan(num) : 返回num的正切值 19.Math.E : 自然数(2.718281828459045) 20.Math.LN2 : 2的自然对数(0.6931471805599453) 21.Math.LN10 : 10的自然对数(2.302585092994046) 22.Math.LOG2E : log 2 为底的自然数(1.4426950408889634) 23.Math.LOG10E : log 10 为底的自然数(0.4342944819032518) 24.Math.PI : π(3.141592653589793) 25.Math.SQRT1_2 : 1/2的平方根(0.7071067811865476) 26.Math.SQRT2 : 2的平方根(1.4142135623730951) 获取时间戳字符串 new Date() &lt;!-- new一个data对象，当前日期和时间 --&gt; let time = Date.parse(new Date()) toLocaleString() &lt;!-- 方法可根据本地时间把 Date 对象转换为字符串，并返回结果 --&gt; sessionStorage存取 var cun = sessionStorage.setItem('cun') var qu = sessionStorage.getItem('qu') var cun1 = localStorage.setItem('cun1') var qu1 = localStorage.getItem('qu1') 常用正则 &lt;!-- 身份证 --&gt; let idCardReg = /^(\\d{15}$|^\\d{18}$|^\\d{17}(\\d|X|x))$/; &lt;!-- 手机号 --&gt; let phoneReg = /(^1\\d{10}$)|(^[0-9]\\d{7}$)/; &lt;!-- 银行卡 16 - 19位数字 --&gt; let pattern = /^([1-9]{1})(\\d{16}|\\d{19})$/; 防抖 (debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。 &lt;!-- 1. --&gt; function debounce(fn, wait, immediate) { let timer = null return function() { let args = arguments let context = this if (immediate &amp;&amp; !timer) { fn.apply(context, args) } if (timer) clearTimeout(timer) timer = setTimeout(() =&gt; { fn.apply(context, args) }, wait) } } &lt;!-- 2. --&gt; function debounce(func, wait) { let timeout = null return function() { let context = this let args = arguments if (timeout) clearTimeout(timeout) timeout = setTimeout(() =&gt; { func.apply(context, args) }, wait) } } 节流(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可 &lt;!-- 1. --&gt; function throttle(fn, wait, immediate) { let timer = null let callNow = immediate return function() { let context = this, args = arguments if (callNow) { fn.apply(context, args) callNow = false } if (!timer) { timer = setTimeout(() =&gt; { fn.apply(context, args) timer = null }, wait) } } } &lt;!-- 2. --&gt; function throttle(func, wait) { let timeout = null return function() { let context = this let args = arguments if (!timeout) { timeout = setTimeout(() =&gt; { timeout = null func.apply(context, args) }, wait) } } } &lt;!-- 3. --&gt; function throttle(func, wait) { var prev = 0; return function() { let now = Date.now(); let context = this; let args = arguments; if (now - prev &gt; wait) { func.apply(context, args); prev = now; } } } js 定时器有以下两个方法： setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。 setTimeout() ：在指定的毫秒数后调用函数或计算表达式 setTimeout (function() { alert(456) },2000) &lt;!-- ES61写法 --&gt; setTimeout(() =&gt; { }2000) ##手机号中间四位隐藏 this.newTel = this.tel.substr(0,3) + &quot;****&quot; + this.tel.substr(7); 数组扁平化 对于[1, [1,2], [1,2,3]]这样多层嵌套的数组，我们如何将其扁平化为[1, 1, 2, 1, 2, 3]这样的一维数组呢： // 1.ES6的flat() const arr = [1, [1,2], [1,2,3]] arr.flat(Infinity) // [1, 1, 2, 1, 2, 3] // 2.序列化后正则 const arr = [1, [1,2], [1,2,3]] const str = `[${JSON.stringify(arr).replace(/(\\[|\\])/g, '')}]` JSON.parse(str) // [1, 1, 2, 1, 2, 3] // 3.递归 对于树状结构的数据，最直接的处理方式就是递归 const arr = [1, [1,2], [1,2,3]] function flat(arr) { let result = [] for (const item of arr) { item instanceof Array ? result = result.concat(flat(item)) : result.push(item) } return result } flat(arr) // [1, 1, 2, 1, 2, 3] // 4.reduce()递归 const arr = [1, [1,2], [1,2,3]] function flat(arr) { return arr.reduce((prev, cur) =&gt; { return prev.concat(cur instanceof Array ? flat(cur) : cur) }, []) } flat(arr) // [1, 1, 2, 1, 2, 3] // 5.迭代+展开运算符 let arr = [1, [1,2], [1,2,3]] while (arr.some(Array.isArray)) { arr = [].concat(...arr); } console.log(arr) // [1, 1, 2, 1, 2, 3] 延迟函数delay const delay = ms =&gt; new Promise((resolve, reject) =&gt; setTimeout(resolve, ms)) const getData = status =&gt; new Promise((resolve, reject) =&gt; { status ? resolve('done') : reject('fail') }) const getRes = async (data) =&gt; { try { const res = await getData(data) const timestamp = new Date().getTime() await delay(1000) console.log(res, new Date().getTime() - timestamp) } catch (error) { console.log(error) } } getRes(true) // 隔了1秒 分割指定长度的元素数组 const listChunk = (list, size = 1, cacheList = []) =&gt; { const tmp = [...list] if (size &lt;= 0) { return cacheList } while (tmp.length) { cacheList.push(tmp.splice(0, size)) } return cacheList } console.log(listChunk([1, 2, 3, 4, 5, 6, 7, 8, 9])) // [[1], [2], [3], [4], [5], [6], [7], [8], [9]] console.log(listChunk([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)) // [[1, 2, 3], [4, 5, 6], [7, 8, 9]] console.log(listChunk([1, 2, 3, 4, 5, 6, 7, 8, 9], 0)) // [] console.log(listChunk([1, 2, 3, 4, 5, 6, 7, 8, 9], -1)) // [] 函数柯里化 const curring = fn =&gt; { const { length } = fn const curried = (...args) =&gt; { return (args.length &gt;= length ? fn(...args) : (...args2) =&gt; curried(...args.concat(args2))) } return curried } const listMerge = (a, b, c) =&gt; [a, b, c] const curried = curring(listMerge) console.log(curried(1)(2)(3)) // [1, 2, 3] console.log(curried(1, 2)(3)) // [1, 2, 3] console.log(curried(1, 2, 3)) // [1, 2, 3] 字符串前面空格去除与替换 const trimStart = str =&gt; str.replace(new RegExp('^([\\\\s]*)(.*)$'), '$2') console.log(trimStart(' abc ')) // abc console.log(trimStart('123 ')) // 123 字符串后面空格去除与替换 const trimEnd = str =&gt; str.replace(new RegExp('^(.*?)([\\\\s]*)$'), '$1') console.log(trimEnd(' abc ')) // abc console.log(trimEnd('123 ')) // 123 去除字符串中的html代码 const removeHTML = (str = '') =&gt; str.replace(/&lt;[\\/\\!]*[^&lt;&gt;]*&gt;/ig, '') console.log(removeHTML('&lt;h1&gt;哈哈哈哈&lt;呵呵呵&lt;/h1&gt;')) // 哈哈哈哈&lt;呵呵呵 判断屏幕是否旋转 function orientationChange() { switch (window.orientation) { case 0: alert(&quot;肖像模式 0,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height); break; case -90: alert(&quot;左旋 -90,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height); break; case 90: alert(&quot;右旋 90,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height); break; case 180: alert(&quot;风景模式 180,screen-width: &quot; + screen.width + &quot;; screen-height:&quot; + screen.height); break; }; }; jquery 去除字符串首尾空格 var str = ' 123 ' var res = $.trim(str) ","link":"https://qinyu312.github.io/post/chang-yong-api-ji-jin/"},{"title":"常用接口随记","content":"天气接口，get 请求， 参数 city 为全国各城市名称，返回最近一周天气情况 http://wthrcdn.etouch.cn/weather_mini?city=上海市 ","link":"https://qinyu312.github.io/post/chang-yong-jie-kou-sui-ji/"},{"title":"各种CSS积累","content":"隐藏textarea input等输入框边框和选中出现边框 textarea { border: solid 0px; outline:none; } textarea 输入时光标直接定位到后面，且不会展示placeholder文本 这种情况是默认有空格在输入框中，解决方案比较奇葩，需要将标签写在同一行即可解决问题 &lt;!-- 错误写法 --&gt; &lt;textarea placeholder=&quot;请输入文本&quot;&gt; &lt;/textarea&gt; &lt;!-- 正确写法 --&gt; &lt;textarea placeholder=&quot;请输入文本&quot;&gt;&lt;/textarea&gt; 图片或者页面 bulingbuling闪动效果 .flicker { /*width: 300px; */ /* 宽度 */ /*height: 300px; */ /* 高度 */ /*border:#666 1px solid;*/ /*border-radius:50%;*/ opacity: 0.1; /* 不透明度 */ overflow: hidden; /* 溢出隐藏 */ /* margin: 25% auto; */ /* 外边距 */ /* IE10、Firefox and Opera，IE9以及更早的版本不支持 */ animation-name: breath; /* 动画名称 */ animation-duration: 700ms; /* 动画时长3秒 */ animation-timing-function: ease-in-out; /* 动画速度曲线：以低速开始和结束 */ animation-iteration-count: infinite; /* 播放次数：无限 */ /* Safari and Chrome */ -webkit-animation-name: breath; /* 动画名称 */ -webkit-animation-duration: 3000ms; /* 动画时长3秒 */ -webkit-animation-timing-function: ease-in-out; /* 动画速度曲线：以低速开始和结束 */ -webkit-animation-iteration-count: infinite; /* 播放次数：无限 */ } @keyframes breath { from { opacity: 0.1; } /* 动画开始时的不透明度 */ 50% { opacity: 1; } /* 动画50% 时的不透明度 */ to { opacity: 0.1; } /* 动画结束时的不透明度 */ } @-webkit-keyframes breath { from { opacity: 0.1; } /* 动画开始时的不透明度 */ 50% { opacity: 1; } /* 动画50% 时的不透明度 */ to { opacity: 0.1; } /* 动画结束时的不透明度 */ } 去除textarea右下角角标 textarea { resize : none; } 内容溢出显示滚动条 &lt;!-- x轴上内容超出显示滚动条 --&gt; overflow-x: auto; &lt;!-- y轴上内容超出显示滚动条 --&gt; overflow-y: auto; &lt;!-- 滚动条设置样式 --&gt; &lt;!-- 设置滚动条的样式 --&gt; ::-webkit-scrollbar{ width: 6px; } &lt;!-- 滚动槽 --&gt; ::-webkit-scrollbar-track{ -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3) ; border-radius: 10px; } &lt;!-- 滚动条滑块 --&gt; ::-webkit-scrollbar-thumb { border-radius: 10px; background: rgba(0, 0, 0, 0.1); -webkit-box-shadow: inset 0 0 2px #4d4b4b; } ::-webkit-scrollbar-thumb:window-inactive { background: rgba(255, 0, 0, 0.4); } 当你想触发的事件被遮罩层挡住无法触发时 之前做提交表单的时候，因为html原生提供的radio样式不满足客户要求，需要将基础样式替换成美工提供的小角标，我的思路比较简单，就是将小角标定位在默认控件的上面，遮罩住，然后点击时，通过判断点击是左右两个单选项的哪一个，来进行角标图片的切换即可，但是写完之后，发现当我点击右侧控件试图切换角标时，发现由于角标遮罩在控件上面，导致无法正常进行切换，控件并未触发。最后在一篇大佬的博客上找到了解决方案。当上面元素遮盖下面元素时无法触发下面元素的点击事件，需要给遮盖层加一个css属性 ： pointer-events: none html &lt;label&gt;性 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 别 &lt;input onclick=&quot;clickSelect()&quot; style=&quot;position: relative; width: 30px; height: 30px; margin-left: 50px; margin-right: 20px;&quot; type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;true&quot; value=&quot;male&quot;&gt; &lt;image id=&quot;iconSelect1&quot; width=&quot;30px&quot; height=&quot;30px&quot; style=&quot;position: absolute; margin: 10px 0 0 -58px;&quot; src=&quot;./image/selectA.png&quot;&gt;&lt;/image&gt; &lt;/input&gt;先生 &lt;input onclick=&quot;clickSelect()&quot; style=&quot; position: relative; width: 30px; height: 30px; margin-left: 50px; margin-right: 20px;&quot; type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt; &lt;image id=&quot;iconSelect2&quot; width=&quot;30px&quot; height=&quot;30px&quot; style=&quot;pointer-events: none; position: absolute; margin: 10px 0 0 -58px;&quot; src=&quot;./image/select.png&quot;&gt;&lt;/image&gt; &lt;/input&gt;女士 &lt;/label&gt; js function clickSelect() { var radioVal = $('input:radio:checked').val(); console.log('=====&gt;', radioVal) if(radioVal == 'female') { $(&quot;#iconSelect2&quot;).attr('src', './image/selectA.png'); $(&quot;#iconSelect1&quot;).attr('src', './image/select.png'); } else { $(&quot;#iconSelect1&quot;).attr('src', './image/selectA.png'); $(&quot;#iconSelect2&quot;).attr('src', './image/select.png'); } } pointer-events是css3的一个属性，指定在什么情况下元素可以成为鼠标事件的target（包括鼠标的样式） 有两个常用属性 auto——效果和没有定义pointer-events属性相同，鼠标不会穿透当前层。在SVG中，该值和visiblePainted的效果相同。 none——元素永远不会成为鼠标事件的target（目标）。但是，当其后代元素的pointer-events属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。实际上默认就可以穿透当前层，因为pointer-events默认为auto ","link":"https://qinyu312.github.io/post/ge-chong-css-ji-lei/"},{"title":"vue-router 路由守卫","content":"有一段时间没有写过 vue 的项目了，最近工作中需要自己搭建，所以简单分享一下vue-router路由守卫! 项目中很常见的一种场景，需求是，用户打开网址进入线上地址，首先是登录页面，用户需要账号密码验证码等手段通过验证和赋权，才可以进入到包括首页，各种管理等内容页面，未登录之前，通过修改路由来进行跳转，如果确实存在此路由，会跳转到登录页面进行登录，如果没有这个路由，会跳转到 404 页面。而成功完成登录后再进行路由地址修改则可以正常跳转！ 这里就需要用到通配符匹配和 路由守卫等操作了 通配符 * 一般用于菜单路由匹配的最后面，为什么要放在最后面呢？因为放在前面会把写在它之后的路由菜单全部匹配进去，就相当于在小河的上游筑起水坝蓄水，那下游自然就没水了，所以通配符相当于确保没有漏网之鱼的作用，凡是没有被定义的路由，都会被它拦截，转而跳转到首页或者404等页面。 &lt;!-- router 下的 index.js --&gt; export default new Router({ routes: [ { path:'/home', name:'home', component:home }, //通配符的使用 { path: '/detail-*', component:detail }, { path: '/*', component:notFound } ] }) beforeEach() 前置路由守卫 当你随意修改路由地址上的路由菜单进行跳转，比如在 '/login' 修改为 '/home'却可以正常跳转时，在尚未登录赋权的情况下就可以进入程序主页面，是一种很不安全的操作，就需要用到路由守卫了！全局前置路由守卫用于路由跳转之前执行，他有三个参数 'to' 参数，表示你当前正要跳转到哪里去，也就是目标页面路由， 'from'参数表示，从哪里来的，也就是当前页面， next() 方法，一定需要调用，继续往下执行的函数。 &lt;!-- 在 roter 文件下的路由配置处， 将meta下的 requireAuth 设置为 true作为此菜单不可不登录直接跳转的标记 --&gt; { path: '/home', meta:{ requireAuth: true } } &lt;!-- main.js --&gt; beforeEach((to, form, next) =&gt; { console.log(to) console.log(from) &lt;!-- 如果要去的这个页面的路由配置中 meta.requireAuth 为 true的话 --&gt; if(to.meta.requireAuth) { &lt;!-- 判断本地存储是否有token令牌，如果有并且令牌合法，调用 next() 方法继续执行 --&gt; if(localStorage.getItem('access_token')) { next(); } else { &lt;!-- 否则就直接调用next()方法跳转回登录页面重新登录 --&gt; next({ path: '/login' }) } } else { next(); } }) 设置完成之后保存并运行项目就会发现，在路径处修改路由不会直接跳转而是会自动拦截。 ","link":"https://qinyu312.github.io/post/vue-router-lu-you-shou-wei/"},{"title":"记个人博客之旅","content":"前端开发小菜🐦，借助Gridea平台搭建属于自己的个人博客正式通🚗，🎉🎉🎉🎉🎉🎉🎉🎉🎉 在这里，我将不定时分享不定时内容，更多的是对工作👨🏻‍🔧 技术👨🏻‍💻 生活🚶🏻等方面的积累收获与感悟，期待与你共同进步！ 饮水思源，第一次写博客的内容就决定是分享Gridea + Github快速搭建个人博客类网站！ 安装Gridea 首先需要安装Gridea客户端，附官网地址 Gridea 因为只满足于日常个人写作轻量级使用，所以选择使用最简单的Github Pages部署，这边就不详细讲解域名，服务器，备案等等配置，感兴趣的建议参考这位大佬的博客观看学习https://aoizz.com 创建git仓库 Gridea安装完成后，登录Github，创建一个空白仓库，用于存储个人博客内容。 配置Gridea 打开Gridea客户端，在远程菜单中，对Github Pages进行配置如下，平台选择Github Pages，如果需要使用自己的服务器和域名也可以选择SFTP，这里不做赘述，域名直接填写之前创建的Github空白仓库的地址即可，仓库名称同上，分支，仓库用户名，邮箱几项按自己的填写即可，令牌创建地址 创建完成的令牌复制到令牌选项框。CNAME处填写自己的仓库名称。至此，Gridea中的Github Pages配置基本完成，点击保存和同步后，就可以输入你的域名进行访问了！ 芜湖！起飞 更加贴心的是， Gridea还为广大个人博主提供了各种风格迥异的博客模版，可以让大家更加专注于写出高质量博客，而不用过于关注样式布局方面的问题。当然，如果你追求极致和个性化，也可以自己定制你的博客。更多主题 使用主题 进入官网下载主题到本地，然后解压后将文件放到Gridea所在的本地地址路径下的themes文件夹下 然后在Gridea客户端的主题菜单里就可以看到你下载的新主题啦。选中后即可同步预览效果！ 那关于个人博客的简单搭建就介绍完了，有兴趣的小伙伴可以动手尝试一下，期待你们精美的博客和优质的作品！ ヽ｀、ヽ｀｀、ヽ｀ヽ｀、、ヽ ｀ヽ 、ヽ｀🌙｀ヽヽ｀ヽ、ヽ｀ヽ｀、ヽ｀｀、ヽ 、｀｀、 ｀、ヽ｀ 、｀ ヽ｀ヽ、ヽ ｀、ヽ｀｀、ヽ、｀｀、｀、ヽ｀｀、 、ヽヽ｀、｀、、ヽヽ、｀｀、 、 ヽ｀、ヽ｀｀、ヽ｀ヽ｀、、ヽ ｀ヽ 、ヽ｀｀ヽ、｀🏡｀ヽ｀、、🚶｀ヽ｀、 ","link":"https://qinyu312.github.io/post/ji-yi-ci-bu-tong-xun-chang-de-ge-ren-blog-da-jian/"}]}