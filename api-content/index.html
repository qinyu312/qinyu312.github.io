{"posts":[{"title":"vue-router 路由守卫","content":"有一段时间没有写过 vue 的项目了，最近工作中需要自己搭建，所以简单分享一下vue-router路由守卫! 项目中很常见的一种场景，需求是，用户打开网址进入线上地址，首先是登录页面，用户需要账号密码验证码等手段通过验证和赋权，才可以进入到包括首页，各种管理等内容页面，未登录之前，通过修改路由来进行跳转，如果确实存在此路由，会跳转到登录页面进行登录，如果没有这个路由，会跳转到 404 页面。而成功完成登录后再进行路由地址修改则可以正常跳转！ 这里就需要用到通配符匹配和 路由守卫等操作了 通配符 * 一般用于菜单路由匹配的最后面，为什么要放在最后面呢？因为放在前面会把写在它之后的路由菜单全部匹配进去，就相当于在小河的上游筑起水坝蓄水，那下游自然就没水了，所以通配符相当于确保没有漏网之鱼的作用，凡是没有被定义的路由，都会被它拦截，转而跳转到首页或者404等页面。 &lt;!-- router 下的 index.js --&gt; export default new Router({ routes: [ { path:'/home', name:'home', component:home }, //通配符的使用 { path: '/detail-*', component:detail }, { path: '/*', component:notFound } ] }) beforeEach() 前置路由守卫 当你随意修改路由地址上的路由菜单进行跳转，比如在 '/login' 修改为 '/home'却可以正常跳转时，在尚未登录赋权的情况下就可以进入程序主页面，是一种很不安全的操作，就需要用到路由守卫了！全局前置路由守卫用于路由跳转之前执行，他有三个参数 'to' 参数，表示你当前正要跳转到哪里去，也就是目标页面路由， 'from'参数表示，从哪里来的，也就是当前页面， next() 方法，一定需要调用，继续往下执行的函数。 &lt;!-- 在 roter 文件下的路由配置处， 将meta下的 requireAuth 设置为 true作为此菜单不可不登录直接跳转的标记 --&gt; { path: '/home', meta:{ requireAuth: true } } &lt;!-- main.js --&gt; beforeEach((to, form, next) =&gt; { console.log(to) console.log(from) &lt;!-- 如果要去的这个页面的路由配置中 meta.requireAuth 为 true的话 --&gt; if(to.meta.requireAuth) { &lt;!-- 判断本地存储是否有token令牌，如果有并且令牌合法，调用 next() 方法继续执行 --&gt; if(localStorage.getItem('access_token')) { next(); } else { &lt;!-- 否则就直接调用next()方法跳转回登录页面重新登录 --&gt; next({ path: '/login' }) } } else { next(); } }) ","link":"https://qinyu312.github.io/post/vue-router-lu-you-shou-wei/"},{"title":"初识React","content":"搭建React项目 在装有node.js的基础上，命令行输入命令 npx create-react-app item-name 即可创建一个React项目，项目结构如下 JSX语法 src文件下的index.js是项目的入口文件，文件中先后引入了react和react-dom两个库。 ReactDOM.render(&lt;h2&gt;hello react&lt;/h2&gt;, document.getElementById('root')); ReactDOM实例通过render方法，将前面的h2标签元素，添加到root元素中，而id为root的元素是public文件的index.html文件的元素。 JSX语法由JavaScript语法 和 XML语法组成，通俗来说就是，当我们在JSX语句中遇到 &lt;&gt; 的形式的，按照XML的形式来解析，因为他们是标签；遇到 {} 按照javaScript来解析，表示JS语法。 const a = ( &lt;div&gt; &lt;p&gt;hello react&lt;/p&gt; &lt;/div&gt; ) 如果存在标签结构，并且标签结构需要换行的话，可以使用 （）的形式进行表示 React 元素渲染 这里通过一个实例了解react的元素渲染 &lt;!-- 首先定义一个方法 --&gt; function nowTime() { const ele = ( &lt;!-- 使用()的形式，可以换行写标签语法 --&gt; &lt;h2&gt;get now time&lt;/h2&gt; &lt;!-- 定义一个获取当前时间的方法 --&gt; &lt;h1&gt;now time is { new Date().toLocalTimeString() } &lt;/h1&gt; ) &lt;!-- 渲染这个获取当前时间的方法 --&gt; reactDOM.render(ele, document.getElementById('root)); } &lt;!-- 定时器每隔一秒会调用一次该方法，实现实时更新当前时间 --&gt; setInterval(() =&gt; { nowTime() },1000) React 组件 关于Ract组件，区别于vue的以 .vue为后缀结尾的文件，\bReact的组件可以是以 .js 为后缀的文件，也可以是 .jsx 为\b后缀的文件\b命名。编写React组件的时候，创建 .js 的组件是没有代码语法提示的，而创建 .jsx 组件文件是有代码语法提示的。 创建React组件分别有两种方式，第一种是通过 类的形式创建组件，第二种是通过Hook的形式创建。并且组件之间是可以互相引入和使用的，以标签的形式存在！ &lt;!-- 第一种写法 --&gt; &lt;!-- 创建一个React组件首先需要引入 React 库 --&gt; import React from 'react' &lt;!-- 创建\b一个类App继承React所提供的Component组件的对象 --&gt; class App extends React Component { &lt;!-- rander(){} 渲染函数 --&gt; render() { &lt;p&gt;\b渲染函数中写你需要这个组件展示的内容，或者要做什么&lt;/p&gt; } } &lt;!-- 导出组件 --&gt; export default App &lt;!-- 第二种写法 --&gt; import React from 'react' export default class App extends React.Component{ render() { return { &lt;div&gt; &lt;p&gt;直接导出并继承React下的Component对象&lt;/p&gt; &lt;/div&gt; } } } &lt;!-- 函数组件 --&gt; function fun(props) { return ( &lt;div&gt; &lt;h3&gt;函数组件&lt;/h3&gt; &lt;/div&gt; ) } &lt;!-- ES6 class类组件 --&gt; class App extends React.Component { render() { return ( &lt;div&gt; &lt;h3&gt;ES6 class类创建组件&lt;/h3&gt; &lt;/div&gt; ) } } 然后在需要使用的地方引入该组件,并将其放置在渲染函数中渲染即可。 import 'App' from './App.jsx' ReactDOM.render(&lt;App /&gt;, document.getElementById('root)); Props组件动态传参 React里面的组件传参通过 props 父组件传递参数给子组件 &lt;!-- 子组件 --&gt; import React from 'react' export default class Son extends React.Component { render() { return { &lt;div&gt; &lt;ul&gt; { &lt;!-- 子组件中 通过this.props的方式获取父组件传递过来的数据，也就是arr ,然后通过map来遍历获取到的数据--&gt; this.props.arr.map((element, index) =&gt; { &lt;!-- 将遍历得到的数据放在li标签中渲染返回，key值需要绑定index唯一值，否则会抛出语法error --&gt; return &lt;li key={ index }&gt;{ element }&lt;/li&gt; }) } &lt;/ul&gt; &lt;/div&gt; } } } import React from 'react' &lt;!-- 引入子组件 --&gt; import Son from './son' export default class Father extends React.Component { render() { &lt;!-- 父组件定义两个数组，用于传递给子组件使用 --&gt; const arrOne = ['Vue' , 'React', 'Angular'], arrTwo = ['Java', 'Pythen', 'C++'] return ( &lt;!-- 在两个子组件中分别传入不同的数据 --&gt; &lt;Son arr={ arrOne } /&gt; &lt;Son arr={ arrTwo } /&gt; ) } } 子组件传递参数给父组件 &lt;!-- 父组件 --&gt; import React from 'react' import Son from './son' export defaul{t class Father React.Component { &lt;!-- 首先定义\bstate用来存储\btitle的状态 --&gt; constructor() { super(); this.state = { title: ‘最初的标题’ } } clickChange = () =&gt; { this.setState({ title: '最后的标题' }) } render() { return ( &lt;div&gt; 父子组件传参 &lt;/div&gt; &lt;!-- 使用子组件,title最开始为 ‘最初的标题’， changeFatherProps 被子组件中的点击事件触发从而执行父组件中的clickChange方法，完成对标题的修改 --&gt; &lt;son title={ this.state.title } changeFatherProps={ this.clickChange } /&gt; ) } } &lt;!-- 子组件 --&gt; import React from 'react' export defaul{t class Father React.Component { changeFather = () =&gt; { &lt;!-- 通过 this.props 的方式 --&gt; this.prpos.changFatherProps() } render() { return &lt;div&gt; 父子组件传参 &lt;!-- \b点击button事件会触发父组件中方法的执行，将标题修改 --&gt; &lt;button onClick={ this.changeFather }&gt;点击传参修改&lt;button&gt; &lt;/div&gt; } } state 状态 &lt;!-- 通过this.state定义保存数据和状态 --&gt; this.state = { flag: true, count: 10, } &lt;!-- 需要修改状态值的时候通过 this.setState({})的方式进行修改 --&gt; this.setState({ flag: false, count: this.state.count ++ }) 生命周期函数 随着我们对React理解和使用的原来越多，生命周期会越来越有参考价值 生命周期函数包括: componentWillMount: 在组件创建之前执行 componentDidMount: 在\b组件渲染之后执行 shouldComponentUpdata: 返回\b true 和 false, true代表允许改变， false代表不允许改变 componentWillUpdata: 数据在改变之前执行（state, props） conponentDidUpdata: 代表数据修改完成（state, props） conponentWillReveiceProps: props发生改变时执行的生命周期函数 conponentWillUnMount: 组件卸载前执行 ","link":"https://qinyu312.github.io/post/chu-shi-react/"},{"title":"记个人博客之旅","content":"前端开发小菜🐦，借助Gridea平台搭建属于自己的个人博客正式通🚗，🎉🎉🎉🎉🎉🎉🎉🎉🎉 在这里，我将不定时分享不定时内容，更多的是对工作👨🏻‍🔧 技术👨🏻‍💻 生活🚶🏻等方面的积累收获与感悟，期待与你共同进步！ 饮水思源，第一次写博客的内容就决定是分享Gridea + Github快速搭建个人博客类网站！ 安装Gridea 首先需要安装Gridea客户端，附官网地址 Gridea 因为只满足于日常个人写作轻量级使用，所以选择使用最简单的Github Pages部署，这边就不详细讲解域名，服务器，备案等等配置，感兴趣的建议参考这位大佬的博客观看学习https://aoizz.com 创建git仓库 Gridea安装完成后，登录Github，创建一个空白仓库，用于存储个人博客内容。 配置Gridea 打开Gridea客户端，在远程菜单中，对Github Pages进行配置如下，平台选择Github Pages，如果需要使用自己的服务器和域名也可以选择SFTP，这里不做赘述，域名直接填写之前创建的Github空白仓库的地址即可，仓库名称同上，分支，仓库用户名，邮箱几项按自己的填写即可，令牌创建地址 创建完成的令牌复制到令牌选项框。CNAME处填写自己的仓库名称。至此，Gridea中的Github Pages配置基本完成，点击保存和同步后，就可以输入你的域名进行访问了！ 芜湖！起飞 更加贴心的是， Gridea还为广大个人博主提供了各种风格迥异的博客模版，可以让大家更加专注于写出高质量博客，而不用过于关注样式布局方面的问题。当然，如果你追求极致和个性化，也可以自己定制你的博客。更多主题 使用主题 进入官网下载主题到本地，然后解压后将文件放到Gridea所在的本地地址路径下的themes文件夹下 然后在Gridea客户端的主题菜单里就可以看到你下载的新主题啦。选中后即可同步预览效果！ 那关于个人博客的简单搭建就介绍完了，有兴趣的小伙伴可以动手尝试一下，期待你们精美的博客和优质的作品！ ヽ｀、ヽ｀｀、ヽ｀ヽ｀、、ヽ ｀ヽ 、ヽ｀🌙｀ヽヽ｀ヽ、ヽ｀ヽ｀、ヽ｀｀、ヽ 、｀｀、 ｀、ヽ｀ 、｀ ヽ｀ヽ、ヽ ｀、ヽ｀｀、ヽ、｀｀、｀、ヽ｀｀、 、ヽヽ｀、｀、、ヽヽ、｀｀、 、 ヽ｀、ヽ｀｀、ヽ｀ヽ｀、、ヽ ｀ヽ 、ヽ｀｀ヽ、｀🏡｀ヽ｀、、🚶｀ヽ｀、 ","link":"https://qinyu312.github.io/post/ji-yi-ci-bu-tong-xun-chang-de-ge-ren-blog-da-jian/"}]}