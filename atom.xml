<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://qinyu312.github.io</id>
    <title>҉҉҈淸鷠҉҉҈、</title>
    <updated>2020-11-20T02:51:15.348Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://qinyu312.github.io"/>
    <link rel="self" href="https://qinyu312.github.io/atom.xml"/>
    <subtitle>万般皆苦，唯有自渡</subtitle>
    <logo>https://qinyu312.github.io/images/avatar.png</logo>
    <icon>https://qinyu312.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ҉҉҈淸鷠҉҉҈、</rights>
    <entry>
        <title type="html"><![CDATA[关于Mac数据恢复]]></title>
        <id>https://qinyu312.github.io/post/guan-yu-mac-shu-ju-hui-fu/</id>
        <link href="https://qinyu312.github.io/post/guan-yu-mac-shu-ju-hui-fu/">
        </link>
        <updated>2020-11-20T02:23:01.000Z</updated>
        <content type="html"><![CDATA[<pre><code>  相信很多使用Mac的小伙伴都有随手清理🗑️废纸篓的习惯，一个命名随意的📃文件，一个看似好像没有什么用的但又不知道以后会不会用到的文件，看着自己所剩无几的内存空间，最后咬咬牙狠下心来，拖入废纸篓，不仅如此还要清倒以毁尸灭迹，更有的小伙伴看到废纸篓有东西，哪怕只是一张图片也要一‘倒’为快，殊不知倒垃圾一时爽，倒完到处找。事后再想找到，悔之晚矣。
</code></pre>
<p><img src="https://qinyu312.github.io/post-images/1605840343066.jpg" alt="" loading="lazy"><br>
那今天就推荐大家一个Mac数据恢复比较好用的软件（亲测可用) <a href="https://www.tenorshare.com/products/mac-data-recovery.html">Tenorshare 4DDiG</a> 虽然它扫描起来比较慢，但是想想被误删的珍贵文件🌕🌗🌚！首先安装就不多说了，没人比你更懂安装！</p>
<h2 id="系统较高版本需要设置权限操作">系统较高版本需要设置权限操作</h2>
<figure data-type="image" tabindex="1"><img src="https://qinyu312.github.io/post-images/1605840000469.png" alt="" loading="lazy"></figure>
<p>重启电脑后再次打开Tenorshare 4DDiG就可以正常扫描文件了，点击需要扫描的文件，耐心(苦苦)等待即可</p>
<figure data-type="image" tabindex="2"><img src="https://qinyu312.github.io/post-images/1605840125782.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识React]]></title>
        <id>https://qinyu312.github.io/post/chu-shi-react/</id>
        <link href="https://qinyu312.github.io/post/chu-shi-react/">
        </link>
        <updated>2020-11-18T13:47:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="搭建react项目">搭建React项目</h2>
<p>在装有node.js的基础上，命令行输入命令</p>
<pre><code>npx create-react-app item-name
</code></pre>
<p>即可创建一个React项目，项目结构如下</p>
<figure data-type="image" tabindex="1"><img src="https://qinyu312.github.io/post-images/1605707465716.png" alt="" loading="lazy"></figure>
<h2 id="jsx语法">JSX语法</h2>
<p>src文件下的index.js是项目的入口文件，文件中先后引入了react和react-dom两个库。</p>
<pre><code>ReactDOM.render(&lt;h2&gt;hello react&lt;/h2&gt;, document.getElementById('root'));
</code></pre>
<p>ReactDOM实例通过render方法，将前面的h2标签元素，添加到root元素中，而id为root的元素是public文件的index.html文件的元素。<br>
JSX语法由JavaScript语法 和 XML语法组成，通俗来说就是，当我们在JSX语句中遇到 &lt;&gt; 的形式的，按照XML的形式来解析，因为他们是标签；遇到 {} 按照javaScript来解析，表示JS语法。</p>
<pre><code>const a = (
        &lt;div&gt;
            &lt;p&gt;hello react&lt;/p&gt;
        &lt;/div&gt;
) 
</code></pre>
<p>如果存在标签结构，并且标签结构需要换行的话，可以使用 （）的形式进行表示</p>
<h2 id="react-元素渲染">React 元素渲染</h2>
<p>这里通过一个实例了解react的元素渲染</p>
<pre><code>&lt;!-- 首先定义一个方法 --&gt;
function nowTime() {
    const ele = (
        &lt;!-- 使用()的形式，可以换行写标签语法 --&gt;
        &lt;h2&gt;get now time&lt;/h2&gt;  
        &lt;!-- 定义一个获取当前时间的方法 --&gt;
        &lt;h1&gt;now time is { new Date().toLocalTimeString() } &lt;/h1&gt;
    )
    &lt;!-- 渲染这个获取当前时间的方法 --&gt;
    reactDOM.render(ele, document.getElementById('root));
}
&lt;!-- 定时器每隔一秒会调用一次该方法，实现实时更新当前时间 --&gt;
setInterval(() =&gt; {
    nowTime()
},1000)

</code></pre>
<h2 id="react-组件">React 组件</h2>
<p>关于Ract组件，区别于vue的以 .vue为后缀结尾的文件，React的组件可以是以 .js 为后缀的文件，也可以是 .jsx 为后缀的文件命名。编写React组件的时候，创建 .js 的组件是没有代码语法提示的，而创建 .jsx 组件文件是有代码语法提示的。 创建React组件分别有两种方式，第一种是通过 类的形式创建组件，第二种是通过Hook的形式创建。并且组件之间是可以互相引入和使用的，以标签的形式存在！</p>
<pre><code>&lt;!-- 第一种写法 --&gt;
&lt;!-- 创建一个React组件首先需要引入 React 库 --&gt;
import React from 'react'
&lt;!-- 创建一个类App继承React所提供的Component组件的对象 --&gt;
class App extends React Component {
    &lt;!-- rander(){} 渲染函数 --&gt;
    render() {
        &lt;p&gt;渲染函数中写你需要这个组件展示的内容，或者要做什么&lt;/p&gt;
    }
}
&lt;!-- 导出组件 --&gt;
export default App

&lt;!-- 第二种写法 --&gt;
import React from 'react'

export default class App extends React.Component{
    render() {
        return {
            &lt;div&gt;
                &lt;p&gt;直接导出并继承React下的Component对象&lt;/p&gt;
            &lt;/div&gt;
        }
    }
}
</code></pre>
<pre><code>&lt;!-- 函数组件 --&gt;
function fun(props) {
    return (
        &lt;div&gt;
            &lt;h3&gt;函数组件&lt;/h3&gt;
        &lt;/div&gt;
    )
}
&lt;!-- ES6 class类组件 --&gt;
class App extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h3&gt;ES6 class类创建组件&lt;/h3&gt;  
            &lt;/div&gt;
        )
    }
}
</code></pre>
<p>然后在需要使用的地方引入该组件,并将其放置在渲染函数中渲染即可。</p>
<pre><code>import 'App' from './App.jsx'
ReactDOM.render(&lt;App /&gt;, document.getElementById('root));

</code></pre>
<h3 id="props组件动态传参">Props组件动态传参</h3>
<p>React里面的组件传参通过 props</p>
<pre><code>&lt;!-- 子组件 --&gt;
import React from 'react'
export default class Son extends React.Component {
    render() {
        return {
            &lt;div&gt;
                &lt;ul&gt;
                    {
                    &lt;!-- 子组件中 通过this.props的方式获取父组件传递过来的数据，也就是arr ,然后通过map来遍历获取到的数据--&gt;
                        this.props.arr.map((element, index) =&gt; {
                            &lt;!-- 将遍历得到的数据放在li标签中渲染返回，key值需要绑定index唯一值，否则会抛出语法error --&gt;
                            return &lt;li key={ index }&gt;{ element }&lt;/li&gt;
                        })
                    }
                &lt;/ul&gt;            
            &lt;/div&gt;
        }
    }
}
</code></pre>
<pre><code>import React from 'react'
&lt;!-- 引入子组件 --&gt;
import Son from './son'
export default class Father extends React.Component {
    render() {
        &lt;!-- 父组件定义两个数组，用于传递给子组件使用 --&gt;
        const arrOne = ['Vue' , 'React', 'Angular'],
                 arrTwo = ['Java', 'Pythen', 'C++']
        return (
            &lt;!-- 在两个子组件中分别传入不同的数据 --&gt;
            &lt;Son arr={ arrOne } /&gt;
            &lt;Son arr={ arrTwo } /&gt;
        )
    }
}
</code></pre>
<h2 id="state-状态">state 状态</h2>
<pre><code>&lt;!-- 通过this.state定义保存数据和状态 --&gt;
    this.state = {
        flag: true,
        count: 10,
    }
    &lt;!-- 需要修改状态值的时候通过 this.setState({})的方式进行修改 --&gt;
    this.setState({
        flag:  false,
        count: this.state.count ++
    })
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记个人博客之旅]]></title>
        <id>https://qinyu312.github.io/post/ji-yi-ci-bu-tong-xun-chang-de-ge-ren-blog-da-jian/</id>
        <link href="https://qinyu312.github.io/post/ji-yi-ci-bu-tong-xun-chang-de-ge-ren-blog-da-jian/">
        </link>
        <updated>2020-11-15T12:29:35.000Z</updated>
        <content type="html"><![CDATA[<pre><code>前端开发小菜🐦，借助Gridea平台搭建属于自己的个人博客正式通🚗，🎉🎉🎉🎉🎉🎉🎉🎉🎉  
在这里，我将不定时分享不定时内容，更多的是对工作👨🏻‍🔧 技术👨🏻‍💻 生活🚶🏻等方面的积累收获与感悟，期待与你共同进步！
</code></pre>
<p><img src="https://w.wallhaven.cc/full/5w/wallhaven-5w26x1.jpg" alt="avatar" loading="lazy"><br>
饮水思源，第一次写博客的内容就决定是分享Gridea + Github快速搭建个人博客类网站！</p>
<h2 id="安装gridea">安装Gridea</h2>
<p>首先需要安装Gridea客户端，附官网地址 <a href="https://gridea.dev/">Gridea</a><br>
因为只满足于日常个人写作轻量级使用，所以选择使用最简单的Github Pages部署，这边就不详细讲解域名，服务器，备案等等配置，感兴趣的建议参考这位大佬的博客观看学习<a href="https://aoizz.com/post/sha-gua-shi-cong-wu-dao-you-jian-li-yi-ge-bo-ke/">https://aoizz.com</a></p>
<figure data-type="image" tabindex="1"><img src="https://qinyu312.github.io/post-images/1605677874498.png" alt="" loading="lazy"></figure>
<h2 id="创建git仓库">创建git仓库</h2>
<p>Gridea安装完成后，登录Github，创建一个空白仓库，用于存储个人博客内容。</p>
<figure data-type="image" tabindex="2"><img src="https://qinyu312.github.io/post-images/1605680193617.png" alt="" loading="lazy"></figure>
<h2 id="配置gridea">配置Gridea</h2>
<p>打开Gridea客户端，在远程菜单中，对Github Pages进行配置如下，平台选择Github Pages，如果需要使用自己的服务器和域名也可以选择SFTP，这里不做赘述，域名直接填写之前创建的Github空白仓库的地址即可，仓库名称同上，分支，仓库用户名，邮箱几项按自己的填写即可，<a href="https://github.com/settings/tokens/new">令牌创建地址</a> 创建完成的令牌复制到令牌选项框。CNAME处填写自己的仓库名称。至此，Gridea中的Github Pages配置基本完成，点击保存和同步后，就可以输入你的域名进行访问了！</p>
<figure data-type="image" tabindex="3"><img src="https://qinyu312.github.io/post-images/1605681597177.png" alt="" loading="lazy"></figure>
<h2 id="芜湖起飞">芜湖！起飞</h2>
<p>更加贴心的是， Gridea还为广大个人博主提供了各种风格迥异的博客模版，可以让大家更加专注于写出高质量博客，而不用过于关注样式布局方面的问题。当然，如果你追求极致和个性化，也可以自己定制你的博客。<a href="https://gridea.dev/themes/">更多主题</a></p>
<figure data-type="image" tabindex="4"><img src="https://qinyu312.github.io/post-images/1605682923167.png" alt="" loading="lazy"></figure>
<h2 id="使用主题">使用主题</h2>
<p>进入官网下载主题到本地，然后解压后将文件放到Gridea所在的本地地址路径下的themes文件夹下</p>
<figure data-type="image" tabindex="5"><img src="https://qinyu312.github.io/post-images/1605683290929.png" alt="" loading="lazy"></figure>
<p>然后在Gridea客户端的主题菜单里就可以看到你下载的新主题啦。选中后即可同步预览效果！</p>
<figure data-type="image" tabindex="6"><img src="https://qinyu312.github.io/post-images/1605683207314.png" alt="" loading="lazy"></figure>
<p>那关于个人博客的简单搭建就介绍完了，有兴趣的小伙伴可以动手尝试一下，期待你们精美的博客和优质的作品！</p>
<p>ヽ｀、ヽ｀｀、ヽ｀ヽ｀、、ヽ ｀ヽ 、ヽ｀🌙｀ヽヽ｀ヽ、ヽ｀ヽ｀、ヽ｀｀、ヽ 、｀｀、 ｀、ヽ｀ 、｀ ヽ｀ヽ、ヽ ｀、ヽ｀｀、ヽ、｀｀、｀、ヽ｀｀、 、ヽヽ｀、｀、、ヽヽ、｀｀、 、 ヽ｀、ヽ｀｀、ヽ｀ヽ｀、、ヽ ｀ヽ 、ヽ｀｀ヽ、｀🏡｀ヽ｀、、🚶｀ヽ｀、</p>
]]></content>
    </entry>
</feed>