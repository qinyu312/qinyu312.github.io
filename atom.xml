<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://qinyu312.github.io</id>
    <title>҉҉҈淸鷠҉҉҈、</title>
    <updated>2021-01-29T09:12:15.883Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://qinyu312.github.io"/>
    <link rel="self" href="https://qinyu312.github.io/atom.xml"/>
    <subtitle>万般皆苦，唯有自渡</subtitle>
    <logo>https://qinyu312.github.io/images/avatar.png</logo>
    <icon>https://qinyu312.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, ҉҉҈淸鷠҉҉҈、</rights>
    <entry>
        <title type="html"><![CDATA[常用api集锦]]></title>
        <id>https://qinyu312.github.io/post/chang-yong-api-ji-jin/</id>
        <link href="https://qinyu312.github.io/post/chang-yong-api-ji-jin/">
        </link>
        <updated>2021-01-29T09:10:57.000Z</updated>
        <content type="html"><![CDATA[<p>##数组API：<br>
var pageIds = new Array();<br>
pageIds.push('A');<br>
//数组长度<br>
pageIds.length;<br>
//shift：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined<br>
var a = [1,2,3,4,5];<br>
var b = a.shift(); //a：[2,3,4,5] b：1<br>
//unshift：将参数添加到原数组开头，并返回数组的长度<br>
var a = [1,2,3,4,5];<br>
var b = a.unshift(-2,-1); //a：[-2,-1,1,2,3,4,5] b：7<br>
//注：在IE6.0下测试返回值总为undefined，FF2.0下测试返回值为7，所以这个方法的返回值不可靠，需要用返回值时可用splice代替本方法来使用。<br>
//pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined<br>
var a = [1,2,3,4,5];<br>
var b = a.pop(); //a：[1,2,3,4] b：5<br>
//push：将参数添加到原数组末尾，并返回数组的长度<br>
var a = [1,2,3,4,5];<br>
var b = a.push(6,7); //a：[1,2,3,4,5,6,7] b：7<br>
//concat：返回一个新数组，是将参数添加到原数组中构成的<br>
var a = [1,2,3,4,5];<br>
var b = a.concat(6,7); //a：[1,2,3,4,5] b：[1,2,3,4,5,6,7]<br>
//splice(start,deleteCount,val1,val2,)：从start位置开始删除deleteCount项，并从该位置起插入val1,val2,<br>
var a = [1,2,3,4,5];<br>
var b = a.splice(2,2,7,8,9); //a：[1,2,7,8,9,5] b：[3,4]<br>
var b = a.splice(0,1); //同shift<br>
a.splice(0,0,-2,-1); var b = a.length; //同unshift<br>
var b = a.splice(a.length-1,1); //同pop<br>
a.splice(a.length,0,6,7); var b = a.length; //同push<br>
//reverse：将数组反序<br>
var a = [1,2,3,4,5];<br>
var b = a.reverse(); //a：[5,4,3,2,1] b：[5,4,3,2,1]<br>
//sort(orderfunction)：按指定的参数对数组进行排序<br>
var a = [1,2,3,4,5];<br>
var b = a.sort(); //a：[1,2,3,4,5] b：[1,2,3,4,5]<br>
//slice(start,end)：返回从原数组中指定开始下标到结束下标之间的项组成的新数组<br>
var a = [1,2,3,4,5];<br>
var b = a.slice(2,5); //a：[1,2,3,4,5] b：[3,4,5]<br>
//join(separator)：将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符<br>
var a = [1,2,3,4,5];<br>
var b = a.join(&quot;|&quot;); //a：[1,2,3,4,5] b：&quot;1|2|3|4|5&quot;</p>
<p>##DOM常用API：<br>
getElementById(id) Node 返回指定结点的引用<br>
getElementsByTagName(name) NodeList 返回文档中所有匹配的元素的集合<br>
createElement(name) Node Node<br>
createTextNode(text) Node 创建一个纯文本结点<br>
ownerDocument Document 指向这个节点所属的文档<br>
documentElement Node 返回html节点<br>
document.body Node 返回body节点<br>
//element方法：<br>
getAttribute(attributeName) String 返回指定属性的值<br>
setAttribute(attributeName,value) String 给属性赋值<br>
removeAttribute(attributeName) String 移除指定属性和它的值<br>
getElementsByTagName(name) NodeList 返回结点内所有匹配的元素的集合<br>
//node方法：<br>
appendChild(child) Node 给指定结点添加一个新的子结点<br>
removeChild(child) Node 移除指定结点的子结点<br>
replaceChild(newChild,oldChild) Node 替换指定结点的子结点<br>
insertBefore(newChild,refChild) Node 在同一层级的结点前面插入新结点<br>
hasChildNodes() Boolean 如果结点有子结点则返回true<br>
//node属性：<br>
nodeName String 以字符串的格式存放结点的名称<br>
nodeType String 以整型数据格式存放结点的类型<br>
nodeValue String 以可用的格式存放结点的值<br>
parentNode Node 指向结点的父结点的引用<br>
childNodes NodeList 指向子结点的引用的集合<br>
firstChild Node 指向子结点结合中的第一个子结点的引用<br>
lastChild Node 指向子结点结合中的最后一个子结点的引用<br>
previousSibling Node 指向前一个兄弟节点；如果这个节点就是兄弟节点，那么该值为null<br>
nextSibling Node 指向后一个兄弟节点；如果这个节点就是兄弟节点，那么该值为null</p>
<p>##数字方法API<br>
//·数字型(Number)<br>
//1.声明<br>
var i = 1;<br>
var i = new Number(1);<br>
//2.字符串与数字间的转换<br>
var i = 1;<br>
var str = i.toString(); //结果: &quot;1&quot;<br>
var str = new String(i); //结果: &quot;1&quot;<br>
i = parseInt(str); //结果: 1<br>
i = parseFloat(str); //结果: 1.0<br>
//注意: parseInt,parseFloat会把一个类似于&quot;32G&quot;的字符串,强制转换成32<br>
//3.判断是否为有效的数字<br>
var i = 123; var str = &quot;string&quot;;<br>
if( typeof i == &quot;number&quot; ){ } //true<br>
//某些方法(如:parseInt,parseFloat)会返回一个特殊的值NaN(Not a Number)<br>
//请注意第2点中的[注意],此方法不完全适合判断一个字符串是否是数字型!!<br>
i = parseInt(str);<br>
if( isNaN(i) ){ }<br>
//4.数字型比较<br>
//此知识与[字符串比较]相同<br>
///5.小数转整数<br>
var f = 1.5;<br>
var i = Math.round(f); //结果:2 (四舍五入)<br>
var i = Math.ceil(f); //结果:2 (返回大于f的最小整数)<br>
var i = Math.floor(f); //结果:1 (返回小于f的最大整数)<br>
//6.格式化显示数字<br>
var i = 3.14159;<br>
//格式化为两位小数的浮点数<br>
var str = i.toFixed(2); //结果: &quot;3.14&quot;<br>
//格式化为五位数字的浮点数(从左到右五位数字,不够补零)<br>
var str = i.toPrecision(5); //结果: &quot;3.1415&quot;<br>
//7.X进制数字的转换<br>
//不是很懂 -.-<br>
var i = parseInt(&quot;0x1f&quot;,16);<br>
var i = parseInt(i,10);<br>
var i = parseInt(&quot;11010011&quot;,2);<br>
//8.随机数<br>
//返回0-1之间的任意小数<br>
var rnd = Math.random();<br>
//返回0-n之间的任意整数(不包括n)<br>
var rnd = Math.floor(Math.random() * n)</p>
<p>##日期方法API<br>
//·日期型(Date)<br>
//1.声明<br>
var myDate = new Date(); //系统当前时间<br>
var myDate = new Date(yyyy, mm, dd, hh, mm, ss);<br>
var myDate = new Date(yyyy, mm, dd);<br>
var myDate = new Date(&quot;monthName dd, yyyy hh:mm:ss&quot;);<br>
var myDate = new Date(&quot;monthName dd, yyyy&quot;);<br>
var myDate = new Date(epochMilliseconds);<br>
//2.获取时间的某部份<br>
var myDate = new Date();<br>
myDate.getYear(); //获取当前年份(2位)<br>
myDate.getFullYear(); //获取完整的年份(4位,1970-????)<br>
myDate.getMonth(); //获取当前月份(0-11,0代表1月)<br>
myDate.getDate(); //获取当前日(1-31)<br>
myDate.getDay(); //获取当前星期X(0-6,0代表星期天)<br>
myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数) 时间戳！！<br>
myDate.getHours(); //获取当前小时数(0-23)<br>
myDate.getMinutes(); //获取当前分钟数(0-59)<br>
myDate.getSeconds(); //获取当前秒数(0-59)<br>
myDate.getMilliseconds(); //获取当前毫秒数(0-999)<br>
myDate.toLocaleDateString(); //获取当前日期<br>
myDate.toLocaleTimeString(); //获取当前时间<br>
myDate.toLocaleString( ); //获取日期与时间<br>
//3.计算之前或未来的时间<br>
var myDate = new Date();<br>
myDate.setDate(myDate.getDate() + 10); //当前时间加10天<br>
//类似的方法都基本相同,以set开头,具体参考第2点<br>
//4.计算两个日期的偏移量<br>
var i = daysBetween(beginDate,endDate); //返回天数<br>
var i = beginDate.getTimezoneOffset(endDate); //返回分钟数<br>
//5.检查有效日期<br>
//checkDate() 只允许&quot;mm-dd-yyyy&quot;或&quot;mm/dd/yyyy&quot;两种格式的日期<br>
if( checkDate(&quot;2006-01-01&quot;) ){ }<br>
//正则表达式(自己写的检查 yyyy-mm-dd, yy-mm-dd, yyyy/mm/dd, yy/mm/dd 四种)<br>
var r = /^(\d{2}|\d{4})[/-]\d{1,2}[/-]\d{1,2}$/;<br>
if( r.test( myString ) ){ }</p>
<p>##字符串方法API<br>
//·字符串(String)<br>
//1.声明<br>
var myString = new String(&quot;Every good boy does fine.&quot;);<br>
var myString = &quot;Every good boy does fine.&quot;;<br>
//2.字符串连接<br>
var myString = &quot;Every &quot; + &quot;good boy &quot; + &quot;does fine.&quot;;<br>
var myString = &quot;Every &quot;; myString += &quot;good boy does fine.&quot;;<br>
//3.截取字符串<br>
//截取第 6 位开始的字符<br>
var myString = &quot;Every good boy does fine.&quot;;<br>
var section = myString.substring(6); //结果: &quot;good boy does fine.&quot;<br>
//截取第 0 位开始至第 10 位为止的字符<br>
var myString = &quot;Every good boy does fine.&quot;;<br>
var section = myString.substring(0,10); //结果: &quot;Every good&quot;<br>
//截取从第 11 位到倒数第 6 位为止的字符<br>
var myString = &quot;Every good boy does fine.&quot;;<br>
var section = myString.slice(11,-6); //结果: &quot;boy does&quot;<br>
//从第 6 位开始截取长度为 4 的字符<br>
var myString = &quot;Every good boy does fine.&quot;;<br>
var section = myString.substr(6,4); //结果: &quot;good&quot;<br>
//4.转换大小写<br>
var myString = &quot;Hello&quot;;<br>
var lcString = myString.toLowerCase(); //结果: &quot;hello&quot;<br>
var ucString = myString.toUpperCase(); //结果: &quot;HELLO&quot;<br>
//5.字符串比较<br>
var aString = &quot;Hello!&quot;;<br>
var bString = new String(&quot;Hello!&quot;);<br>
if( aString == &quot;Hello!&quot; ){ } //结果: true<br>
if( aString == bString ){ } //结果: true<br>
if( aString === bString ){ } //结果: false (两个对象不同,尽管它们的值相同)<br>
//6.检索字符串<br>
var myString = &quot;hello everybody.&quot;;<br>
// 如果检索不到会返回-1,检索到的话返回在该串中的起始位置<br>
if( myString.indexOf(&quot;every&quot;) &gt; -1 ){ } //结果: true<br>
////7.查找替换字符串<br>
var myString = &quot;I is your father.&quot;;<br>
var result = myString.replace(&quot;is&quot;,&quot;am&quot;); //结果: &quot;I am your father.&quot;<br>
//8.特殊字符:<br>
//\b : 后退符 \t : 水平制表符<br>
//\n : 换行符 \v : 垂直制表符<br>
//\f : 分页符 \r : 回车符<br>
//&quot; : 双引号 ' : 单引号<br>
//\ : 反斜杆<br>
//9.将字符转换成Unicode编码<br>
var myString = &quot;hello&quot;;<br>
var code = myString.charCodeAt(3); //返回&quot;l&quot;的Unicode编码(整型)<br>
var char = String.fromCharCode(66); //返回Unicode为66的字符<br>
//10.将字符串转换成URL编码<br>
var myString = &quot;hello all&quot;;<br>
var code = encodeURI(myString); //结果: &quot;hello%20all&quot;<br>
var str = decodeURI(code); //结果: &quot;hello all&quot;<br>
//相应的还有: encodeURIComponent() decodeURIComponent()</p>
<p>##数学方法API</p>
<ol>
<li>Math.abs(num) : 返回num的绝对值</li>
<li>Math.acos(num) : 返回num的反余弦值</li>
<li>Math.asin(num) : 返回num的反正弦值</li>
<li>Math.atan(num) : 返回num的反正切值</li>
<li>Math.atan2(y,x) : 返回y除以x的商的反正切值</li>
<li>Math.ceil(num) : 返回大于num的最小整数</li>
<li>Math.cos(num) : 返回num的余弦值</li>
<li>Math.exp(x) : 返回以自然数为底,x次幂的数</li>
<li>Math.floor(num) : 返回小于num的最大整数<br>
10.Math.log(num) : 返回num的自然对数<br>
11.Math.max(num1,num2) : 返回num1和num2中较大的一个<br>
12.Math.min(num1,num2) : 返回num1和num2中较小的一个<br>
13.Math.pow(x,y) : 返回x的y次方的值<br>
14.Math.random() : 返回0到1之间的一个随机数<br>
15.Math.round(num) : 返回num四舍五入后的值<br>
16.Math.sin(num) : 返回num的正弦值<br>
17.Math.sqrt(num) : 返回num的平方根<br>
18.Math.tan(num) : 返回num的正切值<br>
19.Math.E : 自然数(2.718281828459045)<br>
20.Math.LN2 : 2的自然对数(0.6931471805599453)<br>
21.Math.LN10 : 10的自然对数(2.302585092994046)<br>
22.Math.LOG2E : log 2 为底的自然数(1.4426950408889634)<br>
23.Math.LOG10E : log 10 为底的自然数(0.4342944819032518)<br>
24.Math.PI : π(3.141592653589793)<br>
25.Math.SQRT1_2 : 1/2的平方根(0.7071067811865476)<br>
26.Math.SQRT2 : 2的平方根(1.4142135623730951)</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序本地接口调用]]></title>
        <id>https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-ben-di-ce-shi-jie-kou/</id>
        <link href="https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-ben-di-ce-shi-jie-kou/">
        </link>
        <updated>2021-01-28T01:41:32.000Z</updated>
        <content type="html"><![CDATA[<p>以Mac环境为例，需要下载安装 Tomcat 来运行一个war包</p>
<ol>
<li>将后端项目代码中已经配置好的 xxx.war 文件拷贝至 tomcat文件目录下的 webapps下<br>
<img src="https://qinyu312.github.io/post-images/1611799120504.png" alt="" loading="lazy"></li>
<li>命令行进入到 Tomcat 下的 bin 目录</li>
<li></li>
</ol>
<p>命令行启动 startup.sh<br>
<img src="https://qinyu312.github.io/post-images/1611799131274.png" alt="" loading="lazy"><br>
<code>sudo sh ./startup.sh</code><br>
命令行结束运行<br>
<img src="https://qinyu312.github.io/post-images/1611799138646.png" alt="" loading="lazy"><br>
<code>sudo sh ./shutdown.sh</code><br>
命令行查看 Tomcat所有进程<br>
<img src="https://qinyu312.github.io/post-images/1611799147086.png" alt="" loading="lazy"><br>
<code>ps -ef|grep java</code><br>
命令行强制终止 某些 Tomcat进程<br>
<code>kill -9 端口号</code></p>
<ol start="4">
<li>startup.sh 启动后就可以在浏览器输入 localhost:8080测试 Tomcat 启动的情况</li>
<li>把接口调用处的测试地址换成 localhost:8080 调用接口测试，数据正常返回，本地调用成功</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序开发]]></title>
        <id>https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-kai-fa/</id>
        <link href="https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-kai-fa/">
        </link>
        <updated>2021-01-22T07:53:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="button-无法设置宽高">button 无法设置宽高</h2>
<p>当前版本的微信小程序，在.wxss文件里设置Button宽度无效,调整不会被应用到元素上</p>
<pre><code>.btn {
    width: 80%;
    height: 80rpx;
}
</code></pre>
<p>第一种方式是把 app.json里的  style: v2语句删掉。<br>
这样虽然也可以解决问题，但会导致全局的样式变化。<br>
第二种方式可以很便捷的解决问题，就是直接在 button标签的行内添加样式</p>
<pre><code>&lt;button style=&quot;width: 80%; height: 80rpx&quot;&gt;提交&lt;/button&gt;
</code></pre>
<p>按钮宽高生效</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[主流机型分辨率]]></title>
        <id>https://qinyu312.github.io/post/zhu-liu-ji-xing-fen-bian-lu/</id>
        <link href="https://qinyu312.github.io/post/zhu-liu-ji-xing-fen-bian-lu/">
        </link>
        <updated>2020-12-31T01:52:52.000Z</updated>
        <content type="html"><![CDATA[<p>iphone主流机型<br>
<img src="https://qinyu312.github.io/post-images/1609379604225.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇形怪状bug收集]]></title>
        <id>https://qinyu312.github.io/post/qi-xing-guai-zhuang-bug-shou-ji/</id>
        <link href="https://qinyu312.github.io/post/qi-xing-guai-zhuang-bug-shou-ji/">
        </link>
        <updated>2020-12-26T09:27:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pageslider无法触发默认事件解决">pageSlider无法触发默认事件解决</h2>
<p>最近在做原生内嵌的H5年报页面，需求是上下滚动翻页，于是用上了 pageSlider.js插件进行实现，写到最后一个页面，有一个收集反馈意见的文本框，这边使用到 <textarea>标签，但是开发完后发现，输入框并不能聚焦和输入，通过对比得出结论，是因为引用pageSlider的缘故，最后在 pageSlider.js文件的源码中，将移动鼠标后的默认事件清除给注释掉，问题得到解决<br>
<img src="https://qinyu312.github.io/post-images/1609211243421.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种CSS积累]]></title>
        <id>https://qinyu312.github.io/post/ge-chong-css-ji-lei/</id>
        <link href="https://qinyu312.github.io/post/ge-chong-css-ji-lei/">
        </link>
        <updated>2020-12-21T08:44:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="隐藏textarea-input等输入框边框和选中出现边框">隐藏textarea input等输入框边框和选中出现边框</h2>
<pre><code>textarea {
    border: solid 0px;
	outline:none;
}
</code></pre>
<h2 id="textarea-输入时光标直接定位到后面且不会展示placeholder文本">textarea 输入时光标直接定位到后面，且不会展示placeholder文本</h2>
<p>这种情况是默认有空格在输入框中，解决方案比较奇葩，需要将<textarea>标签写在同一行即可解决问题</p>
<pre><code>&lt;!-- 错误写法 --&gt;
&lt;textarea placeholder=&quot;请输入文本&quot;&gt;
&lt;/textarea&gt;
&lt;!-- 正确写法 --&gt;
&lt;textarea placeholder=&quot;请输入文本&quot;&gt;&lt;/textarea&gt;
</code></pre>
<h2 id="图片或者页面-bulingbuling闪动效果">图片或者页面 bulingbuling闪动效果</h2>
<pre><code>.flicker {
	    /*width: 300px;  */                                  /* 宽度 */
	    /*height: 300px; */                                   /* 高度 */
	    /*border:#666 1px solid;*/
	    /*border-radius:50%;*/
	    opacity: 0.1;                                   /* 不透明度 */
	    overflow: hidden;                               /* 溢出隐藏 */
	   /* margin: 25% auto; */                              /* 外边距 */
	  
	    /* IE10、Firefox and Opera，IE9以及更早的版本不支持 */
	    animation-name: breath;                         /* 动画名称 */
	    animation-duration: 700ms;                         /* 动画时长3秒 */
	    animation-timing-function: ease-in-out;         /* 动画速度曲线：以低速开始和结束 */
	    animation-iteration-count: infinite;            /* 播放次数：无限 */
	 
	    /* Safari and Chrome */
	    -webkit-animation-name: breath;                 /* 动画名称 */
	    -webkit-animation-duration: 3000ms;                 /* 动画时长3秒 */
	    -webkit-animation-timing-function: ease-in-out; /* 动画速度曲线：以低速开始和结束 */
	    -webkit-animation-iteration-count: infinite;    /* 播放次数：无限 */
	}
	 
	@keyframes breath {
	    from { opacity: 0.1; }                          /* 动画开始时的不透明度 */
	    50%  { opacity:   1; }                          /* 动画50% 时的不透明度 */
	    to   { opacity: 0.1; }                          /* 动画结束时的不透明度 */    
	}
	 
	@-webkit-keyframes breath {
	    from { opacity: 0.1; }                          /* 动画开始时的不透明度 */
	    50%  { opacity:   1; }                          /* 动画50% 时的不透明度 */
	    to   { opacity: 0.1; }                          /* 动画结束时的不透明度 */
	}
</code></pre>
<h2 id="去除textarea右下角角标">去除textarea右下角角标</h2>
<pre><code>textarea {
	resize : none;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS各种零碎知识合集]]></title>
        <id>https://qinyu312.github.io/post/js-ge-chong-ling-sui-zhi-shi-he-ji/</id>
        <link href="https://qinyu312.github.io/post/js-ge-chong-ling-sui-zhi-shi-he-ji/">
        </link>
        <updated>2020-12-09T02:37:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="react里的事件">React里的事件</h2>
<pre><code>&lt;!-- onChange事件 --&gt;
this.handleChange = this.handleChange.bind(this)
handleChange(event) {
    this.setState({value: event.target.value})
}
&lt;textarea onChange={ this.handleChange } /&gt;  

&lt;!-- onSubmit事件 --&gt;
this.handleSubmit = this,handleSubmit(this)
handleSubmit(event) {
    alert('提交' + this.state.value + '成功!')
    event.preventDefault()    
    &lt;!-- 清除默认事件 --&gt;
}
&lt;form onSubmit= { this.handleSubmit }&gt;&lt;/form&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fetch querystring  跨域解决 封装请求]]></title>
        <id>https://qinyu312.github.io/post/fetch-shu-ju-jie-kou-qing-qiu/</id>
        <link href="https://qinyu312.github.io/post/fetch-shu-ju-jie-kou-qing-qiu/">
        </link>
        <updated>2020-12-08T14:38:43.000Z</updated>
        <content type="html"><![CDATA[<p>以前写数据接口，对接请求都是使用的Ajax，或者Axios之类的，最近在使用React进行开发，用到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">fetch</a>, 和<a href="http://nodejs.cn/api/querystring.html">querystring</a></p>
<pre><code>import qs from 'querystring'
&lt;!-- get请求 --&gt;
fetch(&quot;http://iwenwiki.com/api/blueberrypai/getChengpinInfo.php&quot;)
.then(res =&gt; res.json())
.then(data =&gt; {
    console.log(data)
})

&lt;!-- post请求 --&gt;
fetch(&quot;http://iwenwiki.com/api/blueberrypai/login.php&quot;, {
    method: 'POST' ,   // 请求方式
    headers: {            // 请求头
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json, text/plain, */*',
    },
    &lt;!-- body: &quot;user_id=iwen@qq.com&amp;password=iwen123&amp;verification_code=crfvw&quot; --&gt;
    &lt;!-- 此处传参使用字符串传参的方式，所以需要参数间 &amp; 分隔拼串 --&gt;
    &lt;!-- 如果不想写拼串，也可以直接引入 querystring来进行转换操作如下 --&gt;
    body: qs.stringify({
        'user_id': 'iwen@qq.com',
        'password': 'iwen123',
        'verification_code': 'crfvw'
    })
})
</code></pre>
<h2 id="跨域的解决方案">跨域的解决方案</h2>
<p>跨域一般分为两种场景： 开发环境下的跨域问题和生产环境下的跨域问题<br>
此处以React项目开发环境下为例</p>
<pre><code>componentDidMount() {
    fetch(&quot;http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0&quot;)
    .then(res =&gt; res.json())
    .then(data =&gt; {
        console.log(data)
    })
    .catch(error =&gt; {
        console.log(new Error(error))
    })
}
</code></pre>
<p><img src="https://qinyu312.github.io/post-images/1607442245412.png" alt="" loading="lazy"><br>
此处请求会跨域<br>
需要在 package.json 文件中配置 proxy 代理解决<br>
<img src="https://qinyu312.github.io/post-images/1607442296763.png" alt="" loading="lazy"><br>
配置完成 package.json 文件后需要将请求接口前面的已经被代理的地址去掉如下</p>
<pre><code>componentDidMount() {
    fetch(&quot;/v1/restserver/ting?method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0&quot;)
    .then(res =&gt; res.json())
    .then(data =&gt; {
        console.log(data)
    })
    .catch(error =&gt; {
        console.log(new Error(error))
    })
}
</code></pre>
<p>然后终止此项目进程，重新运行该项目即可使用代理解决跨域问题。打开浏览器调试，接口数据正常请求得到。<br>
<img src="https://qinyu312.github.io/post-images/1607442458895.png" alt="" loading="lazy"></p>
<h2 id="fetch-封装常用请求">fetch 封装常用请求</h2>
<p>工具类文件utils下创建 http.js 用于封装常用的请求方法</p>
<pre><code>import qs from 'querystring'

&lt;!-- 导出封装的 get 请求 --&gt;
export function httpGet(url) {
    const result = fetch(url)
    return result
}

&lt;!-- 导出封装的 post 请求 --&gt;
export function httpPost(url, params) {
    &lt;!-- params为post请求携带参数 --&gt;
    const result = fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'application/json, text/plain, */*',
        },
        body: qs.stringify(params)
    })
}
</code></pre>
<p>然后在 utils 同级创建一个 api 文件，用于管理接口，api 下新建一个 base.js ，用于向外暴露接口的前置接口地址公共部分(一般情况下接口地址的前半部分是一致的)，然后新建一个 index.js 用于定义业务接口请求统一管理，或者创建不同的功能分类 (如，登录的接口单独写在一个文件里，首页的接口单独写在一个文件里，便于维护)<br>
base.js</p>
<pre><code>const base = {
    baseUrl: 'http://iwenwiki.com/api'
}
</code></pre>
<p>index.js</p>
<pre><code>import {httpGet, httpPost} from '../utils/http'
import base from './base'

&lt;!-- 在下面定义各种业务接口 --&gt;
const api = {
    &lt;!-- get请求 --&gt;
    getUserId() {
        return httpGet(base.baseUrl + '/blueberrypai/getChengpinInfo.php');
    },
    &lt;!-- post请求 --&gt;
    getLogin(params) {
        return httpPost(baseUrl + '/blueberrypai/login.php', params);
    }
}

&lt;!-- 定义完成后导出 api ,在需要调用处导入调用即可 --&gt;
export default api
</code></pre>
<p>调用接口的文件下</p>
<pre><code>import api from '../api'
&lt;!-- get请求不用携带参数，直接获取并打印数据 --&gt;
api.getUserId().then(res =&gt; res.json()).then(data =&gt; {
    console.log(data)
})
&lt;!-- post请求调用接口时传入参数，获取并打印数据 --&gt;
api.getLogin({
    'user_id': 'iwen@qq.com',
    'password': 'iwen123',
    'verification_code': 'crfvw'
}).then(res =&gt; res.json()).then(data =&gt; {
    console.log(data)
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于各种浏览器兼容(持续更新中)]]></title>
        <id>https://qinyu312.github.io/post/guan-yu-ge-chong-ie-jian-rong/</id>
        <link href="https://qinyu312.github.io/post/guan-yu-ge-chong-ie-jian-rong/">
        </link>
        <updated>2020-12-04T10:07:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ie条件注释">IE条件注释</h2>
<p>IE10以下版本可用，IE11已经取消支持</p>
<pre><code>&lt;!--[if lte IE 8]&gt; 	
        &lt;script src=&quot;/js/html5.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/js/css3-mediaqueries.js&quot;&gt;&lt;/script&gt;
        &lt;link href=&quot;/css/ie8.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
&lt;![endif]--&gt;
</code></pre>
<p>因为IE11不支持条件注释，可以使用正则判断</p>
<pre><code>var browser = navigator.appName;
var ie11 = !!navigator.userAgent.match(/Trident\/7\./);
if (browser == 'Microsoft Internet Explorer' || ie11 == true) {
    //do something
}
</code></pre>
<h2 id="ie9部分页面不显示的问题">IE9部分页面不显示的问题</h2>
<pre><code>IE9是不支持 console.log 打印输出语句的，在非开发者模式下会阻塞不会执行后面的内容
</code></pre>
<h2 id="ie9-及以下-ie浏览器不支持placeholder属性">IE9 及以下 IE浏览器不支持placeholder属性</h2>
<pre><code>引入 jquery和用于解决这个属性兼容的CDN
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.ijquery.cn/js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.ijquery.cn/js/jquery.placeholder.min.js&quot;&gt;&lt;/script&gt;

&lt;%--兼容IE9及以下input输入框，textarea文本框不支持提示文本placeholder属性的问题--%&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function(){ $('input, textarea').placeholder(); });
&lt;/script&gt;
</code></pre>
<p>上面这种方法在HTML文件中亲测有效，但是不知道为什么在前后端不分离JSP项目中不会生效，以某国企老项目为例，需要在每个页面的JS代码中加上</p>
<pre><code>	&lt;!-- css代码 --&gt;
    .phcolor{ 
			color:#999;
	}

    &lt;!-- js代码 --&gt;
	// placeholder兼容IE9
	$(function(){
	  //判断浏览器是否支持placeholder属性
	  supportPlaceholder='placeholder'in document.createElement('input'),
	  placeholder=function(input){
	    var text = input.attr('placeholder'),
	    defaultValue = input.defaultValue;
	    if(!defaultValue){
	      input.val(text).addClass(&quot;phcolor&quot;);
	    }
	    input.focus(function(){
	      if(input.val() == text){
	        $(this).val(&quot;&quot;);
	      }
	    });
	    input.blur(function(){
	      if(input.val() == &quot;&quot;){
	        $(this).val(text).addClass(&quot;phcolor&quot;);
	      }
	    });
	    //输入的字符不为灰色
	    input.keydown(function(){
	      $(this).removeClass(&quot;phcolor&quot;);
	    });
	  };
	  //当浏览器不支持placeholder属性时，调用placeholder函数
	  if(!supportPlaceholder){
	    $('input').each(function(){
	      text = $(this).attr(&quot;placeholder&quot;);
	      if($(this).attr(&quot;type&quot;) == &quot;text&quot;){
	        placeholder($(this));
	      }
	    });
	  }
	});
</code></pre>
<h2 id="换行word-wrap与word-break兼容ie和火狐-chrome">换行word-wrap与word-break兼容ie和火狐、chrome</h2>
<ol>
<li>word-wrap控制换行，使用break-word时，会强制进行换行，中文没问题，英文语句没问题，长串的英文不会生效。</li>
<li>word-break控制是否断词<br>
normal是默认情况，英文单词不被拆开<br>
break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题。<br>
keep-all，是指Chinese, Japanese, and Korean不断词。即只用此时，不用word-wrap，中文就不会换行了。（英文语句正常。）<br>
所以，要做到英文和中文等强制换行，需要组合使用如下</li>
</ol>
<pre><code>&lt;p style=&quot;word-wrap: break-word; word-break: break-all&quot;&gt;&lt;/p&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Angular项目避坑指南]]></title>
        <id>https://qinyu312.github.io/post/angular-xiang-mu-bi-keng-zhi-nan/</id>
        <link href="https://qinyu312.github.io/post/angular-xiang-mu-bi-keng-zhi-nan/">
        </link>
        <updated>2020-11-24T10:15:01.000Z</updated>
        <content type="html"><![CDATA[<p>最近收到一个新的需求，有一个Angular项目需要兼容到 IE8 以上版本，实在让我又惊又喜，惊的是都 2020年了，还甩不掉 IE8 这颗烫手山芋；喜的是第一次接触 Angular项目，不知道又会学到什么新的知识呢。拉到项目代码后，本地启动，果然给我来了迎头痛击。<br>
首先确认本地安装有Node.js环境后，全局安装 Angular-cli ，也就是Angular脚手架,命令行输入：</p>
<pre><code>cnpm install -g @angular/cli
</code></pre>
<p>然后就是老步骤，下载node_modules 依赖包</p>
<pre><code>cnpm install
</code></pre>
<p>之后直接 ng serve 启动命令有点别具一格的简洁，直接芜湖🛫️</p>
<pre><code>ng serve
</code></pre>
<p>接下来，就是见证 奇迹（打脸）的时刻<br>
<img src="https://qinyu312.github.io/post-images/1606213638697.png" alt="" loading="lazy"><br>
我敲完命令一回车，啪的一下满屏飙红报错，很快啊，我就看到是依赖包的问题，按照传统功夫的看到为止，我没有看下去，上去就是一个卸载依赖，一个 cnpm install ，我大意了啊，没有删完，接着又是飙红报错。Angular 不讲武德，来欺，为难我入行一年多点的小前端，希望它以后耗子尾汁！<br>
<img src="https://qinyu312.github.io/post-images/1606228631691.png" alt="" loading="lazy"><br>
最后在 node_modules 下的 less-loader 加上一句  javascriptEnabled: true  ，问题得到解决<br>
<img src="https://qinyu312.github.io/post-images/1606228810583.png" alt="" loading="lazy"></p>
<p>项目成功启动，再来解决兼容IE8的问题，<a href="https://angular.cn/guide/browser-support">Angular</a>，官方文档浏览器兼容部分我们可以看到， IE 10, 11, 9，也就是说连官方都放弃去做IE9一下的兼容了。<br>
<img src="https://qinyu312.github.io/post-images/1606461891938.png" alt="" loading="lazy"><br>
忍不住又想吐槽IE一把，但是客户需求在身，只能硬着头皮做了，因为Angular在国内市场的使用还不是特别频繁，所以我在百度没有什么收获之后，决定翻墙去 Google ，Angular 也不亏是 Google的亲儿子。方案当然是有的。需要将Angular版本降低至 1.2一以下可以对IE8进行兼容适配。然后就是传统功夫的卸载新版本，安装旧版本。</p>
<pre><code>&lt;!-- 卸载新版本 --&gt;
cnpm uninstall -g @angular/cli
&lt;!-- 安装新版本 --&gt;
cnpm install -g @angular/cli/1.1
</code></pre>
<p>问题得到解决，兼容是好了，样式又乱的简直是乱他妈妈给乱开门  -  乱到家了。不说了，我要去调样式了！<br>
<img src="https://qinyu312.github.io/post-images/1606462146562.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>