<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://qinyu312.github.io</id>
    <title>҉҉҈淸鷠҉҉҈、</title>
    <updated>2021-03-22T08:21:36.399Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://qinyu312.github.io"/>
    <link rel="self" href="https://qinyu312.github.io/atom.xml"/>
    <subtitle>万般皆苦，唯有自渡</subtitle>
    <logo>https://qinyu312.github.io/images/avatar.png</logo>
    <icon>https://qinyu312.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, ҉҉҈淸鷠҉҉҈、</rights>
    <entry>
        <title type="html"><![CDATA[测试用数据]]></title>
        <id>https://qinyu312.github.io/post/ce-shi-yong-shu-ju/</id>
        <link href="https://qinyu312.github.io/post/ce-shi-yong-shu-ju/">
        </link>
        <updated>2021-03-22T03:12:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线上视频资源测试用">线上视频资源测试用</h2>
<pre><code>https://v-cdn.zjol.com.cn/280443.mp4
https://v-cdn.zjol.com.cn/276982.mp4
https://v-cdn.zjol.com.cn/276984.mp4
https://v-cdn.zjol.com.cn/276985.mp4
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用小功能封装]]></title>
        <id>https://qinyu312.github.io/post/chang-yong-xiao-gong-neng-feng-zhuang/</id>
        <link href="https://qinyu312.github.io/post/chang-yong-xiao-gong-neng-feng-zhuang/">
        </link>
        <updated>2021-03-19T02:35:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="js-轻提示">js 轻提示</h2>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;style type=&quot;text/css&quot;&gt;
			@keyframes show {
			    0% {
			        opacity: 0;
			    }
			    100% {
			        opacity: 1;
			    }            
			}
			@keyframes hide {
			    0% {
			        opacity: 1;
			    }
			    100% {
			        opacity: 0;
			    }
			} 
			.toast_box {
			    /* width: 100%; */
			    position: absolute;
			    bottom: 50%;
				left: 50%;
			    /* justify-content: center; */
				z-index: 10;
				transform: translate(-50%, -50%);
			    display: none;
			}
			.toast_box p {
			    box-sizing: border-box;
			    padding: 10px 20px;
			    width: max-content;
				/* 提示框的背景色 */
			    background: #707070;
			    color: #fff;
			    font-size: 16px;
			    text-align: center;
			    border-radius: 6px;
			    opacity: 0.8;
			} 
			.toliet{
				margin: 0 auto;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id=&quot;hotal&quot;&gt;
			&lt;!-- 提示框 --&gt;
			&lt;div class=&quot;toast_box&quot;&gt;
			    &lt;p id=&quot;toast&quot;&gt;&lt;/p&gt;
			&lt;/div&gt;
			&lt;button id=&quot;toliet&quot; type=&quot;button&quot; onclick=&quot;correct()&quot;&gt;正常&lt;/button&gt;
			&lt;button id=&quot;toliet&quot; type=&quot;button&quot; onclick=&quot;warning()&quot;&gt;警告&lt;/button&gt;
			&lt;button id=&quot;toliet&quot; type=&quot;button&quot; onclick=&quot;error()&quot;&gt;报错异常&lt;/button&gt;
		&lt;/div&gt;
		&lt;script type=&quot;text/javascript&quot;&gt;
			//形参分别是: 提示内容,停留时间时间
			function toast(text, time) {
			    let toast = document.getElementById('toast');
			    let toast_box = document.getElementsByClassName('toast_box')[0];
			    toast.innerHTML = text;
			    toast_box.style.animation = 'show 1.5s'
			    toast_box.style.display = 'inline-block';
				setTimeout(function(){
					toast_box.style.animation = 'hide 1.5s'
					setTimeout(function(){
						toast_box.style.display = 'none';
					}, 1400)
				}, time)   
			}
			//调用
			function correct(){
				toast(&quot;is ok!&quot;,5000);
			}
			function warning(){
				toast(&quot;异常提醒&quot;,3000);
			}
			function error(){
				toast(&quot;报错&quot;,3000);
			}
		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="js-遮罩层弹出表单">js 遮罩层弹出表单</h2>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot;&gt;
	&lt;title&gt;&lt;/title&gt;
    &lt;body&gt;
        &lt;style type=&quot;text/css&gt;
            #dialogBg3{
                width:100%;
                height:100%;
                background-color:#000000;
                opacity:.8;
                filter:alpha(opacity=60);
                position:fixed;
                top:0;
                left:0;
                z-index:9999;
                display:none;
            }
            #dialog3{ 
                width: 70%; 
                height: 500px; 
                margin: 0 auto; 
                display: none; 
                background-color: #ffffff; 
                position: fixed;
                top: 45%;
                left: 50%;
                transform: translate(-50%, -50%);
                /* margin: -120px 0 0 -150px; */
                z-index: 10000; 
                border: 1px solid #ccc; 
                border-radius: 10px; 
                -webkit-border-radius: 10px; 
                box-shadow: 3px 2px 4px rgba(0,0,0,0.2); 
                -webkit-box-shadow: 3px 2px 4px rgba(0,0,0,0.2); 
                background-image: linear-gradient(#F9E2C3, #fff5e6);
            }
            .dialogTop3{
                width:90%;
                margin:0 auto;
                border-bottom:1px dotted #ccc;
                letter-spacing:1px;
                padding:10px 0;
                text-align:right;
                position: relative;
            }
            .submitImg {
                position: absolute;
                top: -180px;
                left: 50%;
                transform: translate(-50%, 80px);
            }
            .claseDialogBtn3 {
                position: absolute;
                top: -80px;
                right: -80px;
            }
            .dialogIco3{
                width:50px;
                height:50px;
                position:absolute;
                top:-25px;
                left:50%;
                margin-left:-25px;
            }
        &lt;/style&gt;
        &lt;div id=&quot;dialogBg3&quot;&gt;&lt;/div&gt;
		&lt;div id=&quot;dialog3&quot; class=&quot;animated3&quot;&gt;
			&lt;div class=&quot;dialogTop3&quot;&gt;
				&lt;image class=&quot;claseDialogBtn3&quot; src=&quot;./image/backBtn.png&quot;&gt;&lt;/image&gt;
			&lt;/div&gt;
			&lt;p style=&quot;text-align: center; font-size: 36px; color: #671404; margin: 80px auto;&quot;&gt;提交失败&lt;/p&gt;
			&lt;p style=&quot;text-align: center; margin: 30px 0 60px 0; font-size: 28px; line-height: 41px; letter-spacing: 2px; padding-left: 40px; padding-right: 40px;&quot;&gt;您的报名提交失败！请重新提交&lt;/p&gt;
			&lt;div style=&quot;margin-top: 120px; position: relative;&quot; onclick=&quot;submitData()&quot;&gt;
				&lt;image width=&quot;90%;&quot; height=&quot;90px&quot; style=&quot; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&quot; src=&quot;./image/submitBtn.png&quot;&gt;&lt;/image&gt;
				&lt;p onclick=&quot;offDialog()&quot; style=&quot;position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 32px; color: #fff;&quot;&gt;我知道了&lt;/p&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/body&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        $(function(){
			getSrceenWH();
			//点击触发弹窗
			$('.course3 p').click(function(){
				className = $(this).attr('class');
				$('#dialogBg'3).fadeIn(300);
				$('#dialog3').removeAttr('class').addClass('animated '+className+'').fadeIn();
			});
			//关闭弹窗
			$('.claseDialogBtn3').click(function(){
				$('#dialogBg3').fadeOut(300,function(){
					$('#dialog3').addClass('bounceOutUp3').fadeOut();
				});
			});
        })  
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h2 id="类似于微信的时间格式转换">类似于微信的时间格式转换</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AES前后端加密实例]]></title>
        <id>https://qinyu312.github.io/post/aes-qian-hou-duan-jia-mi-shi-li/</id>
        <link href="https://qinyu312.github.io/post/aes-qian-hou-duan-jia-mi-shi-li/">
        </link>
        <updated>2021-03-18T06:18:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端部分">前端部分</h2>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/rollups/tripledes.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/components/aes.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/components/mode-ecb-min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input id=&quot;test&quot; name=&quot;gj&quot;&gt;
&lt;button onclick=&quot;test()&quot;&gt;点击&lt;/button&gt;
&lt;script&gt;
    function test(){
        var param = $(&quot;input[name='gj']&quot;).val();
        Encrypt(param);
    }

    var key  = CryptoJS.enc.Utf8.parse('asdfghjklqwertuuiop');
    function Encrypt(word){

        var srcs = CryptoJS.enc.Utf8.parse(word);
        var encrypted = CryptoJS.AES.encrypt(srcs, key, {mode:CryptoJS.mode.ECB,padding: CryptoJS.pad.Pkcs7});
        console.log(encrypted.toString());
    }
    function Decrypt(word) {

        var decrypt = CryptoJS.AES.decrypt(word, key, {mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7});
        return CryptoJS.enc.Utf8.stringify(decrypt).toString();
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="后端部分java">后端部分（java）</h2>
<pre><code>import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @Author:yw
 * @Description:AES 加密解密
 * @Date: Created in 18:392018/6/11
 */
public class AESUtil {
    private static final String KEY =&quot;sadaasdsad&quot;   
 private static final String KEY_ALGORITHM = &quot;AES&quot;;
    private static final String DEFAULT_CIPHER_ALGORITHM = &quot;AES/ECB/PKCS5Padding&quot;;//默认的加密算法

    /**
     * AES 加密操作
     *
     * @param content 待加密内容
     * @param password 加密密码
     * @return 返回Base64转码后的加密数据
     */
    public static String encrypt(String content, String decryptKey) {
        try {
            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);// 创建密码器

            byte[] byteContent = content.getBytes(&quot;utf-8&quot;);

            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(decryptKey.getBytes(), &quot;AES&quot;));// 初始化为加密模式的密码器

            byte[] result = cipher.doFinal(byteContent);// 加密

            return Base64.encodeBase64String(result);//通过Base64转码返回
        } catch (Exception ex) {
            Logger.getLogger(AESUtil.class.getName()).log(Level.SEVERE, null, ex);
        }

        return null;
    }

    /**
     * AES 加密操作
     *
     * @param content 待加密内容
     * @param password 加密密码
     * @return 返回Base64转码后的加密数据
     */
    public static String encrypt(String content) {
        try {
            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);// 创建密码器

            byte[] byteContent = content.getBytes(&quot;utf-8&quot;);

            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(KEY.getBytes(), &quot;AES&quot;));// 初始化为加密模式的密码器

            byte[] result = cipher.doFinal(byteContent);// 加密

            return Base64.encodeBase64String(result);//通过Base64转码返回
        } catch (Exception ex) {
            Logger.getLogger(AESUtil.class.getName()).log(Level.SEVERE, null, ex);
        }

        return null;
    }
    /**
     * AES 解密操作
     *
     * @param content
     * @param password
     * @return
     */
    public static String decrypt(String content, String decryptKey) {

        try {
            //实例化
            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);

            //使用密钥初始化，设置为解密模式
            cipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(decryptKey.getBytes(), &quot;AES&quot;));

            //执行操作
            byte[] result = cipher.doFinal(Base64.decodeBase64(content));

            return new String(result, &quot;utf-8&quot;);
        } catch (Exception ex) {
            Logger.getLogger(AESUtil.class.getName()).log(Level.SEVERE, null, ex);
        }

        return null;
    }

    /**
     * AES 解密操作
     *
     * @param content
     * @param password
     * @return
     */
    public static String decrypt(String content) {

        try {
            //实例化
            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);

            //使用密钥初始化，设置为解密模式
            cipher.init(Cipher.DECRYPT_MODE,new SecretKeySpec(KEY.getBytes(), &quot;AES&quot;));

            //执行操作
            byte[] result = cipher.doFinal(Base64.decodeBase64(content));

            return new String(result, &quot;utf-8&quot;);
        } catch (Exception ex) {
            Logger.getLogger(AESUtil.class.getName()).log(Level.SEVERE, null, ex);
        }

        return null;
    }
    /**
     * 生成加密秘钥
     *
     * @return
     */
    private static SecretKeySpec getSecretKey(final String password) {
        //返回生成指定算法密钥生成器的 KeyGenerator 对象
        KeyGenerator kg = null;

        try {
            kg = KeyGenerator.getInstance(KEY_ALGORITHM);

            //AES 要求密钥长度为 128
            kg.init(128, new SecureRandom(password.getBytes()));

            //生成一个密钥
            SecretKey secretKey = kg.generateKey();

            return new SecretKeySpec(secretKey.getEncoded(), KEY_ALGORITHM);// 转换为AES专用密钥
        } catch (NoSuchAlgorithmException ex) {
            Logger.getLogger(AESUtil.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    public static void main(String[] args) {
        String content = &quot;13958160820&quot;;  //0gqIDaFNAAmwvv3tKsFOFf9P9m/6MWlmtB8SspgxqpWKYnELb/lXkyXm7P4sMf3e
        System.out.println(&quot;加密前：&quot; + content);

        System.out.println(&quot;加密密钥和解密密钥：&quot; + KEY);

        String encrypt = encrypt(content, KEY);
        System.out.println(encrypt.length()+&quot;:加密后：&quot; + encrypt);

        String decrypt = decrypt(encrypt, KEY);
        System.out.println(&quot;解密后：&quot; + decrypt);


    }
   /* *//**
     * 加密
     * @method encrypt
     * @param content   需要加密的内容
     * @param password  加密密码
     * @return
     * @throws
     * @since v1.0
     *//*
    public static String encrypt(String content){
        try {
            KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);
            kgen.init(128, new SecureRandom(KEY.getBytes()));
            SecretKey secretKey = kgen.generateKey();
            byte[] enCodeFormat = secretKey.getEncoded();
            SecretKeySpec key = new SecretKeySpec(enCodeFormat, &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);// 创建密码器
            byte[] byteContent = content.getBytes(&quot;utf-8&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, key);// 初始化
            byte[] result = cipher.doFinal(byteContent);
            return parseByte2HexStr(result);// 加密
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }catch (InvalidKeyException e) {
            e.printStackTrace();
        }catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }catch (BadPaddingException e) {
            e.printStackTrace();
        }
        return null;
    }

    *//**
     * 加密
     * @method encrypt
     * @param content   需要加密的内容
     * @param password  加密密码
     * @return
     * @throws
     * @since v1.0
     *//*
    public static String encrypt(String content, String password){
        try {
            KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);
            kgen.init(128, new SecureRandom(password.getBytes()));
            SecretKey secretKey = kgen.generateKey();
            byte[] enCodeFormat = secretKey.getEncoded();
            SecretKeySpec key = new SecretKeySpec(enCodeFormat, &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);// 创建密码器
            byte[] byteContent = content.getBytes(&quot;utf-8&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, key);// 初始化
            byte[] result = cipher.doFinal(byteContent);
            return parseByte2HexStr(result);// 加密
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }catch (InvalidKeyException e) {
            e.printStackTrace();
        }catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }catch (BadPaddingException e) {
            e.printStackTrace();
        }
        return null;
    }

    *//**
     * 解密
     * @method decrypt
     * @param content   待解密内容
     * @param password  解密密钥
     * @return
     * @throws
     * @since v1.0
     *//*
    public static String decrypt(String content, String password){
        try {
            byte[] param = parseHexStr2Byte(content);
            KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);
            kgen.init(128, new SecureRandom(password.getBytes()));
            SecretKey secretKey = kgen.generateKey();
            byte[] enCodeFormat = secretKey.getEncoded();
            SecretKeySpec key = new SecretKeySpec(enCodeFormat, &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);// 创建密码器
            cipher.init(Cipher.DECRYPT_MODE, key);// 初始化
            byte[] result = cipher.doFinal(param);
            return new String(result); // 解密
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }catch (InvalidKeyException e) {
            e.printStackTrace();
        }catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return null;
    }

    *//**
     * 解密
     * @method decrypt
     * @param content   待解密内容
     * @param password  解密密钥
     * @return
     * @throws
     * @since v1.0
     *//*
    public static String decrypt(String content){
        try {
            byte[] param = Base64.decodeBase64(parseHexStr2Byte(content));

            KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);
            kgen.init(128, new SecureRandom(KEY.getBytes()));
            SecretKey secretKey = kgen.generateKey();
            byte[] enCodeFormat = secretKey.getEncoded();
            SecretKeySpec key = new SecretKeySpec(enCodeFormat, &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);// 创建密码器
            cipher.init(Cipher.DECRYPT_MODE, key);// 初始化
            byte[] result = cipher.doFinal(param);
            return new String(result); // 解密
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }catch (InvalidKeyException e) {
            e.printStackTrace();
        }catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return null;
    }

    *//**
     * 将二进制转换成16进制
     * @method parseByte2HexStr
     * @param buf
     * @return
     * @throws
     * @since v1.0
     *//*
    public static String parseByte2HexStr(byte buf[]){
        StringBuffer sb = new StringBuffer();
        for(int i = 0; i &lt; buf.length; i++){
            String hex = Integer.toHexString(buf[i] &amp; 0xFF);
            if (hex.length() == 1) {
                hex = '0' + hex;
            }
            sb.append(hex.toUpperCase());
        }
        return sb.toString();
    }

    *//**
     * 将16进制转换为二进制
     * @method parseHexStr2Byte
     * @param hexStr
     * @return
     * @throws
     * @since v1.0
     *//*
    public static byte[] parseHexStr2Byte(String hexStr){
        if(hexStr.length() &lt; 1)
            return null;
        byte[] result = new byte[hexStr.length()/2];
        for (int i = 0;i&lt; hexStr.length()/2; i++) {
            int high = Integer.parseInt(hexStr.substring(i*2, i*2+1), 16);
            int low = Integer.parseInt(hexStr.substring(i*2+1, i*2+2), 16);
            result[i] = (byte) (high * 16 + low);
        }
        return result;
    }

    *//**
     * 另外一种加密方式--这种加密方式有两种限制
     * 1、密钥必须是16位的
     * 2、待加密内容的长度必须是16的倍数，如果不是16的倍数，就会出如下异常
     * javax.crypto.IllegalBlockSizeException: Input length not multiple of 16 bytes
     at com.sun.crypto.provider.SunJCE_f.a(DashoA13*..)
     at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
     at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
     at com.sun.crypto.provider.AESCipher.engineDoFinal(DashoA13*..)
     at javax.crypto.Cipher.doFinal(DashoA13*..)
     要解决如上异常，可以通过补全传入加密内容等方式进行避免。
     * @method encrypt2
     * @param content   需要加密的内容
     * @param password  加密密码
     * @return
     * @throws
     * @since v1.0
     *//*
    public static byte[] encrypt2(String content, String password){
        try {
            SecretKeySpec key = new SecretKeySpec(password.getBytes(), &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;);
            byte[] byteContent = content.getBytes(&quot;utf-8&quot;);
            cipher.init(Cipher.ENCRYPT_MODE, key);// 初始化
            byte[] result = cipher.doFinal(byteContent);
            return result; // 加密
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        }
        return null;
    }*/
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript]]></title>
        <id>https://qinyu312.github.io/post/typescript/</id>
        <link href="https://qinyu312.github.io/post/typescript/">
        </link>
        <updated>2021-03-12T06:42:56.000Z</updated>
        <content type="html"><![CDATA[<p>typescript是javascript的超集，二者最本质的区别就体现在名字上面， type意为类型，从前的javascript，由于历史遗留及语言定位问题，一直以来虽然独霸前端技术栈，但也一直深受诟病。中小型项目尚可，真要在大型项目的场景中使用，就会暴露出许多问题，例如，定义变量类型不够明确，不会抛出异常报错信息，处理复杂业务能力欠佳等。而typescript的到来填补了许多坑。</p>
<h2 id="环境搭建">环境搭建</h2>
<p>首先，typescript是使用 node.js进行编写的javascript的超集，所以运行typescript需要先安装 node.js 环境，官网下载安装即可，安装完成之后，需要借助 node.js 的包管理器 npm ，进行typescript的全局安装，命令行指令如下</p>
<pre><code>npm install -g typescript
</code></pre>
<p>安装完成之后就可以创建 以 .ts 为结尾的ts文件，需要注意的是，浏览器是不支持解析ts文件的，所以我们写完 ts代码后，还需要将 ts 文件编译为 js文件，在可以在浏览器中执行，例如 test.ts 文件，如果需要执行，就需要在当前文件的命令行下执行命令</p>
<pre><code>tsc test.ts
</code></pre>
<p>然后 test.ts 同级目录下就会输出一个 test.js 的编译好的 js文件，html代码中引入 js文件， 既可以正常执行，值得注意的是，现在的 ts 文件，每次修改后都需要重新编译为 js 文件。</p>
<h2 id="语法学习">语法学习</h2>
<p>ts 可以指定变量或者函数传参的类型，这点在大型项目中尤为重要，大型项目动辄一个js文件上千上万行代码，而js定义变量和函数传参等写法上又十分随意，时常会有类型错误导致程序异常，导致项目过大难以维护，加上js本身的机制上并不会抛出异常，所以遇到类型错误难以捕获，维护成本大大增加，使用ts之后，虽然前期写法上略显多余和臃肿，但是为之后的项目维护提前布局，从而提高了效率。<br>
基本写法</p>
<pre><code>&lt;!-- 在ts文件中定义一个变量,变量后面紧跟冒号加数据类型，即可指定当前变量的数据类型 --&gt;
let a:string = 'hello ts'
&lt;!-- 当给 a 指定了数据类型为字符串 string 后，再次修改 a 的 值为 number 123时，程序就会抛出异常，告诉你此处需要的是一个字符串，而不是number类型 --&gt;
a = 123
&lt;!-- 此时，在命令行中输入编译命令， tsc test.ts 将文件编译为 js文件时，也会抛出错误信息，但是编译器依然会帮你将错误的ts语法代码编译为 js文件 --&gt;

&lt;!-- 函数传参时指定参数的类型可以有效防止传入的值与所需类型不一致的问题，例如此处，一个求和的函数，需要传入两个数字，进行相加得到结果，如果指定参数类型为 number ,但调用时传入其他类型的参数就会直接抛出异常，如果不在函数参数里指定数据类型，那么如果传入的是一个数字和一个字符串，那么就会进行字符串的拼串操作，得到的会是一个字符串，而非我们希望的数字 --&gt;
function sum(a:number, b:number) {
    return a + b;
} 
let res = sum(2 , 7)

&lt;!--  联合类型  在 ts中， ｜ 表示或的意思，什么或者什么，所以a的值只可以在 male 和 demale之间才可以，否则，就会抛出异常。 ｜ 既可以用来连接字面量，也可以用来连接类型 --&gt;

let a: &quot;male&quot; | &quot;famale&quot;
let b: false | string

&lt;!-- any  表示任意类型，定义为any的变量，可以是任意类型。但是当一个变量设置为any类型后，相当于是对这个变量关闭了 ts 的类型检测，之后不管赋值什么类型都不会抛出异常。 所以不建议使用--&gt;
let c:any
c = 'hello'
c = 12
c = true

&lt;!-- 当声名一个变量，但是不去赋值的时候，ts 解析器无法知道变量的数据类型，就会隐式的将 变量类型设置为 any ,  --&gt;
let d

&lt;!-- 当你暂时不知道变量的类型设置为什么比较好时，any并不是首选项，还可以使用 unknown, 表示未知类型的值，他的效果和 any 一样， 但是他们在使用上会有很大的差异， 举个例子，现在有一个变量 e的值为 string 类型， 变量 f 只声名未赋值，也就是 any 类型， 当把 f 赋值给e的时候，由于f是any类型，也就是任意类型，它显然是符合 e 的类型条件的，所以并不会报错，但是此时，f 就把自己的类型 any 也带给了 e ,导致 e 的类型从 string 变成了 any , 污染了其他变量。  而 unknown 类型的变量实际上就是一个类型安全的 any ，因为它不能直接赋值给其他变量  --&gt;
let e = 'hello'
let f
e = f
当需要把 unknown 变量赋值给其他变量时， 可以先做一个类型判断后再进行赋值操作
if(typeof e === 'string') {
    e = f
}
还可以使用类型断言的方式强行指定类型
e = f as string
&lt;!-- 或者 --&gt;
e = &lt;string&gt; f;

&lt;!-- void 为空的， 以函数为例，当给函数的返回值设置为 void 类型时，如果返回的值不为空类型（underfind 或者 null ）就会报错 --&gt;
function fn():void {
    return ;
}

&lt;!-- never 类型，表示永远不会又返回结果。 适用于没有返回值的函数使用，比如专门用来捕获抛出异常的函数 --&gt;
function fn1(): never {
    return
}

&lt;!-- object 对象类型  { } 用来指定对象中可以包含哪些类型的属性--&gt;
let g: {name: string}
g = {name: 'suibianshenme '}

&lt;!-- [ccc: string]: string表示任意名称的字符串和 字符串类型的值 --&gt;
let h: {name: string, [ccc: string]: string}
h = {name: 'suibianshenme ', ddd: 'sdhu'}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[地图定位相关]]></title>
        <id>https://qinyu312.github.io/post/di-tu-ding-wei-xiang-guan/</id>
        <link href="https://qinyu312.github.io/post/di-tu-ding-wei-xiang-guan/">
        </link>
        <updated>2021-02-18T01:57:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="js获取当前地理位置经纬度">JS获取当前地理位置(经纬度)</h2>
<pre><code>if(navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
        function (position) {  
            console.log( position.coords.longitude );
            console.log( position.coords.latitude );
        },
        function (e) {
           throw(e.message);
        }
    ) 
}
</code></pre>
<h2 id="微信小程序获取当前地理位置经纬度">微信小程序获取当前地理位置(经纬度)</h2>
<pre><code>wx.getLocation({
      altitude: 'altitude',
      isHighAccuracy: true, 
      success(res) {
        // 手机经纬度定位更加精准，需要截取到小数点后六位
        var currentLatitude = (res.latitude).toFixed(6);  //纬度
        var currentLongitude = (res.longitude).toFixed(6); //经度
        console.log(currentLatitude , currentLongitude)
        this.setData({
          // 经度
          longitude: currentLongitude,
          // 纬度
          latitude: currentLatitude
        })
      }
    })
</code></pre>
<h2 id="微信小程序通过经纬度逆推获取当前城市信息">微信小程序通过经纬度逆推获取当前城市信息</h2>
<ol>
<li>首先需要去<a href="https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/jsSdkOverview">腾讯位置服务官网</a>，<a href="https://lbs.qq.com/dev/console/application/mine">申请开发者密钥</a><br>
<img src="https://qinyu312.github.io/post-images/1613641773112.png" alt="" loading="lazy"></li>
<li>开通webserviceAPI服务：在控制台 -&gt; key管理 -&gt; 设置（使用该功能的key）-&gt; 勾选webserviceAPI -&gt; 保存。(小程序SDK需要用到webserviceAPI的部分服务，所以使用该功能的KEY需要具备相应的权限)</li>
<li>下载微信小程序JavaScriptSDK，微信小程序JavaScriptSDK v1.1   JavaScriptSDK v1.2</li>
<li>安全域名设置，在小程序管理后台 -&gt; 开发 -&gt; 开发管理 -&gt; 开发设置 -&gt; “服务器域名” 中设置request合法域名，添加https://apis.map.qq.com</li>
<li>示例如下</li>
</ol>
<pre><code>getAddress() {
    var that = this
    &lt;!-- 调用微信小程序获取经纬度API --&gt;
    wx.getLocation({
      altitude: 'altitude',
      isHighAccuracy: true, 
      success(res) {
        // 手机经纬度定位更加精准，需要截取到小数点后六位
        var currentLatitude = (res.latitude).toFixed(6);  //纬度
        var currentLongitude = (res.longitude).toFixed(6); //经度
        &lt;!-- 将经纬度存储在data中 --&gt;
        that.setData({
          // 经度
          longitude: currentLongitude,
          // 纬度
          latitude: currentLatitude
        })
        // 逆解析接口 /ws/geocoder/v1
        &lt;!-- 定义一个变量用于拼接地址逆解析接口，key值是腾讯位置服务中注册后生成的 key --&gt;
        var qqMapApi = 'http://apis.map.qq.com/ws/geocoder/v1/' + &quot;?location=&quot; + that.data.latitude + ',' +
        that.data.longitude + &quot;&amp;key=&quot; + 'ZHHBZ-MCN6D-HUX4Y-PL7SW-KM4TQ-WYBDZ' + &quot;&amp;get_poi=1&quot;;
        &lt;!-- 拼接完成后作为参数使用 --&gt;
        that.getSkys(qqMapApi);
      }
    })
  },
  &lt;!-- 调用接口将参数作为 url 发送请求 --&gt;
  getSkys(qqMapApi){
    const that = this
    wx.request({
      url: qqMapApi,
      header: {
        'Content-Type': 'application/json'
      },
      data: {},
      method:'GET',
      success: (res) =&gt; {
          &lt;!-- 获取的返回值数据就是传入的经纬度提取到的 各级地理数据信息 --&gt;
        if (res.statusCode == 200 &amp;&amp; res.data.status == 0) {
          // 从返回值中提取需要的业务地理信息数据 国家、省、市、县区、街道
          // that.setData({ nation: res.data.result.address_component.nation });
          // that.setData({ province: res.data.result.address_component.province });
          that.setData({ city: res.data.result.address_component.city });
          // that.setData({ district: res.data.result.address_component.district });
          // that.setData({ street: res.data.result.address_component.street });
          wx.request({
            url: &quot;http://wthrcdn.etouch.cn/weather_mini&quot;,
            data: {city: res.data.result.address_component.city},
            // data: {city: '昆明'},
            method: 'GET',
            success: res =&gt; {
              var low = res.data.data.forecast[0].low.split(' ', 2)[1]
              var high = res.data.data.forecast[0].high.split(' ', 2)[1]
              var skyTitle = low + '~' + high + ' ' + res.data.data.forecast[0].type
              var skyType = res.data.data.forecast[0].type
              this.setData({
                skyType: skyType,
                skyTitle: skyTitle
              })
              console.log(skyTitle)
            }
          })
        }
      }
    })
  },
</code></pre>
<p>最后得到所需要的位置信息<br>
<img src="https://qinyu312.github.io/post-images/1613641792498.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2.5基金日报]]></title>
        <id>https://qinyu312.github.io/post/25-ji-jin-ri-bao/</id>
        <link href="https://qinyu312.github.io/post/25-ji-jin-ri-bao/">
        </link>
        <updated>2021-02-05T07:07:52.000Z</updated>
        <content type="html"><![CDATA[<p>最近几天新能源和军工又又又被锤肿了，可能受春运回家核酸检测和疫苗接种的影响，医药最近几天走势大好，月初几天美股游戏驿站事件，A股也是一片哀嚎一片绿，但是白酒却逆势上扬，让我想起一句话，白酒生，万物死。今天新能源和军工大跌，理性加一些仓位，个人觉得新能源是长期利好，也是未来的发展趋势，军工在今年的十四五规划中也有望大放异彩，医药方面，由于人口老龄化加速及医疗水平提高，可作为长期投资，半导体5G方面谨慎上车，有色金属可适当上车。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AES加密前端操作]]></title>
        <id>https://qinyu312.github.io/post/jia-mi-cao-zuo/</id>
        <link href="https://qinyu312.github.io/post/jia-mi-cao-zuo/">
        </link>
        <updated>2021-02-04T09:12:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="aes前端加密">aes前端加密</h1>
<p>最近在开发微信小程序，由于是国企项目，上线前都需要做好几次安全漏洞扫描，所以数据接口都需要二次封装并进行加解密的操作来确保安全性，最后和后端同事商议，使用aes进行加密，原理是前端请求的后端接口，除统一域名前缀部分外，后面接口部分全部使用公共参数 例如common 进行替换，然后将接口名称，接口所需参数等信息，通过 aes 加密后传输给后端，后端拿到加密后的字符串，通过解密算法得到接口名称及参数，来调用对用的接口，然后将返回值同样经过加密后返回给前端，前端拿到加密串后解密，得到JSON对象，转换后得到接口数据进行页面渲染。</p>
<p>具体操作如下：</p>
<ol>
<li>将加解密方法操作封装在 public.js 和 aes.js 两个文件中</li>
</ol>
<pre><code>&lt;!-- public.js --&gt;

var CryptoJS = require('./aes.js'); //引用AES源码js
var key = CryptoJS.enc.Utf8.parse(&quot;richeninfo202121&quot;); //十六位十六进制数作为秘钥
var iv = CryptoJS.enc.Utf8.parse('richeninfo202121');//十六位十六进制数作为秘钥偏移量
//解密方法
function Decrypt(word) {
    var encryptedHexStr = CryptoJS.enc.Hex.parse(word);
    var srcs = CryptoJS.enc.Base64.stringify(encryptedHexStr);
    var decrypt = CryptoJS.AES.decrypt(srcs, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    var decryptedStr = decrypt.toString(CryptoJS.enc.Utf8);
    return decryptedStr.toString();
}
//加密方法
function Encrypt(word) {
    var srcs = CryptoJS.enc.Utf8.parse(word);
    var encrypted = CryptoJS.AES.encrypt(srcs, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    return encrypted.ciphertext.toString().toUpperCase();
}
 
//暴露接口
module.exports.Decrypt = Decrypt;
module.exports.Encrypt = Encrypt;
</code></pre>
<pre><code>&lt;!-- aes.js --&gt;
/**
 * [description] CryptoJS v3.1.2 
 * [description] zhuangzhudada sort out 
 */
var CryptoJS = CryptoJS || function(u, p) {
  var d = {},
      l = d.lib = {},
      s = function() {},
      t = l.Base = {
          extend: function(a) {
              s.prototype = this;
              var c = new s;
              a &amp;&amp; c.mixIn(a);
              c.hasOwnProperty(&quot;init&quot;) || (c.init = function() {
                  c.$super.init.apply(this, arguments)
              });
              c.init.prototype = c;
              c.$super = this;
              return c
          },
          create: function() {
              var a = this.extend();
              a.init.apply(a, arguments);
              return a
          },
          init: function() {},
          mixIn: function(a) {
              for (var c in a) a.hasOwnProperty(c) &amp;&amp; (this[c] = a[c]);
              a.hasOwnProperty(&quot;toString&quot;) &amp;&amp; (this.toString = a.toString)
          },
          clone: function() {
              return this.init.prototype.extend(this)
          }
      },
      r = l.WordArray = t.extend({
          init: function(a, c) {
              a = this.words = a || [];
              this.sigBytes = c != p ? c : 4 * a.length
          },
          toString: function(a) {
              return (a || v).stringify(this)
          },
          concat: function(a) {
              var c = this.words,
                  e = a.words,
                  j = this.sigBytes;
              a = a.sigBytes;
              this.clamp();
              if (j % 4)
                  for (var k = 0; k &lt; a; k++) c[j + k &gt;&gt;&gt; 2] |= (e[k &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (k % 4) &amp; 255) &lt;&lt; 24 - 8 * ((j + k) % 4);
              else if (65535 &lt; e.length)
                  for (k = 0; k &lt; a; k += 4) c[j + k &gt;&gt;&gt; 2] = e[k &gt;&gt;&gt; 2];
              else c.push.apply(c, e);
              this.sigBytes += a;
              return this
          },
          clamp: function() {
              var a = this.words,
                  c = this.sigBytes;
              a[c &gt;&gt;&gt; 2] &amp;= 4294967295 &lt;&lt;
- 8 * (c % 4);
              a.length = u.ceil(c / 4)
          },
          clone: function() {
              var a = t.clone.call(this);
              a.words = this.words.slice(0);
              return a
          },
          random: function(a) {
              for (var c = [], e = 0; e &lt; a; e += 4) c.push(4294967296 * u.random() | 0);
              return new r.init(c, a)
          }
      }),
      w = d.enc = {},
      v = w.Hex = {
          stringify: function(a) {
              var c = a.words;
              a = a.sigBytes;
              for (var e = [], j = 0; j &lt; a; j++) {
                  var k = c[j &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (j % 4) &amp; 255;
                  e.push((k &gt;&gt;&gt; 4).toString(16));
                  e.push((k &amp; 15).toString(16))
              }
              return e.join(&quot;&quot;)
          },
          parse: function(a) {
              for (var c = a.length, e = [], j = 0; j &lt; c; j += 2) e[j &gt;&gt;&gt; 3] |= parseInt(a.substr(j,
                  2), 16) &lt;&lt; 24 - 4 * (j % 8);
              return new r.init(e, c / 2)
          }
      },
      b = w.Latin1 = {
          stringify: function(a) {
              var c = a.words;
              a = a.sigBytes;
              for (var e = [], j = 0; j &lt; a; j++) e.push(String.fromCharCode(c[j &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (j % 4) &amp; 255));
              return e.join(&quot;&quot;)
          },
          parse: function(a) {
              for (var c = a.length, e = [], j = 0; j &lt; c; j++) e[j &gt;&gt;&gt; 2] |= (a.charCodeAt(j) &amp; 255) &lt;&lt; 24 - 8 * (j % 4);
              return new r.init(e, c)
          }
      },
      x = w.Utf8 = {
          stringify: function(a) {
              try {
                  return decodeURIComponent(escape(b.stringify(a)))
              } catch (c) {
                  throw Error(&quot;Malformed UTF-8 data&quot;);
              }
          },
          parse: function(a) {
              return b.parse(unescape(encodeURIComponent(a)))
          }
      },
      q = l.BufferedBlockAlgorithm = t.extend({
          reset: function() {
              this._data = new r.init;
              this._nDataBytes = 0
          },
          _append: function(a) {
              &quot;string&quot; == typeof a &amp;&amp; (a = x.parse(a));
              this._data.concat(a);
              this._nDataBytes += a.sigBytes
          },
          _process: function(a) {
              var c = this._data,
                  e = c.words,
                  j = c.sigBytes,
                  k = this.blockSize,
                  b = j / (4 * k),
                  b = a ? u.ceil(b) : u.max((b | 0) - this._minBufferSize, 0);
              a = b * k;
              j = u.min(4 * a, j);
              if (a) {
                  for (var q = 0; q &lt; a; q += k) this._doProcessBlock(e, q);
                  q = e.splice(0, a);
                  c.sigBytes -= j
              }
              return new r.init(q, j)
          },
          clone: function() {
              var a = t.clone.call(this);
              a._data = this._data.clone();
              return a
          },
          _minBufferSize: 0
      });
  l.Hasher = q.extend({
      cfg: t.extend(),
      init: function(a) {
          this.cfg = this.cfg.extend(a);
          this.reset()
      },
      reset: function() {
          q.reset.call(this);
          this._doReset()
      },
      update: function(a) {
          this._append(a);
          this._process();
          return this
      },
      finalize: function(a) {
          a &amp;&amp; this._append(a);
          return this._doFinalize()
      },
      blockSize: 16,
      _createHelper: function(a) {
          return function(b, e) {
              return (new a.init(e)).finalize(b)
          }
      },
      _createHmacHelper: function(a) {
          return function(b, e) {
              return (new n.HMAC.init(a,
                  e)).finalize(b)
          }
      }
  });
  var n = d.algo = {};
  return d
}(Math);
(function() {
  var u = CryptoJS,
      p = u.lib.WordArray;
  u.enc.Base64 = {
      stringify: function(d) {
          var l = d.words,
              p = d.sigBytes,
              t = this._map;
          d.clamp();
          d = [];
          for (var r = 0; r &lt; p; r += 3)
              for (var w = (l[r &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (r % 4) &amp; 255) &lt;&lt; 16 | (l[r + 1 &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * ((r + 1) % 4) &amp; 255) &lt;&lt; 8 | l[r + 2 &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * ((r + 2) % 4) &amp; 255, v = 0; 4 &gt; v &amp;&amp; r + 0.75 * v &lt; p; v++) d.push(t.charAt(w &gt;&gt;&gt; 6 * (3 - v) &amp; 63));
          if (l = t.charAt(64))
              for (; d.length % 4;) d.push(l);
          return d.join(&quot;&quot;)
      },
      parse: function(d) {
          var l = d.length,
              s = this._map,
              t = s.charAt(64);
          t &amp;&amp; (t = d.indexOf(t), -1 != t &amp;&amp; (l = t));
          for (var t = [], r = 0, w = 0; w &lt;
              l; w++)
              if (w % 4) {
                  var v = s.indexOf(d.charAt(w - 1)) &lt;&lt; 2 * (w % 4),
                      b = s.indexOf(d.charAt(w)) &gt;&gt;&gt; 6 - 2 * (w % 4);
                  t[r &gt;&gt;&gt; 2] |= (v | b) &lt;&lt; 24 - 8 * (r % 4);
                  r++
              }
          return p.create(t, r)
      },
      _map: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;
  }
})();
(function(u) {
  function p(b, n, a, c, e, j, k) {
      b = b + (n &amp; a | ~n &amp; c) + e + k;
      return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n
  }

  function d(b, n, a, c, e, j, k) {
      b = b + (n &amp; c | a &amp; ~c) + e + k;
      return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n
  }

  function l(b, n, a, c, e, j, k) {
      b = b + (n ^ a ^ c) + e + k;
      return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n
  }

  function s(b, n, a, c, e, j, k) {
      b = b + (a ^ (n | ~c)) + e + k;
      return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n
  }
  for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 &gt; x; x++) b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0;
  r = r.MD5 = v.extend({
      _doReset: function() {
          this._hash = new w.init([1732584193, 4023233417, 2562383102, 271733878])
      },
      _doProcessBlock: function(q, n) {
          for (var a = 0; 16 &gt; a; a++) {
              var c = n + a,
                  e = q[c];
              q[c] = (e &lt;&lt; 8 | e &gt;&gt;&gt; 24) &amp; 16711935 | (e &lt;&lt; 24 | e &gt;&gt;&gt; 8) &amp; 4278255360
          }
          var a = this._hash.words,
              c = q[n + 0],
              e = q[n + 1],
              j = q[n + 2],
              k = q[n + 3],
              z = q[n + 4],
              r = q[n + 5],
              t = q[n + 6],
              w = q[n + 7],
              v = q[n + 8],
              A = q[n + 9],
              B = q[n + 10],
              C = q[n + 11],
              u = q[n + 12],
              D = q[n + 13],
              E = q[n + 14],
              x = q[n + 15],
              f = a[0],
              m = a[1],
              g = a[2],
              h = a[3],
              f = p(f, m, g, h, c, 7, b[0]),
              h = p(h, f, m, g, e, 12, b[1]),
              g = p(g, h, f, m, j, 17, b[2]),
              m = p(m, g, h, f, k, 22, b[3]),
              f = p(f, m, g, h, z, 7, b[4]),
              h = p(h, f, m, g, r, 12, b[5]),
              g = p(g, h, f, m, t, 17, b[6]),
              m = p(m, g, h, f, w, 22, b[7]),
              f = p(f, m, g, h, v, 7, b[8]),
              h = p(h, f, m, g, A, 12, b[9]),
              g = p(g, h, f, m, B, 17, b[10]),
              m = p(m, g, h, f, C, 22, b[11]),
              f = p(f, m, g, h, u, 7, b[12]),
              h = p(h, f, m, g, D, 12, b[13]),
              g = p(g, h, f, m, E, 17, b[14]),
              m = p(m, g, h, f, x, 22, b[15]),
              f = d(f, m, g, h, e, 5, b[16]),
              h = d(h, f, m, g, t, 9, b[17]),
              g = d(g, h, f, m, C, 14, b[18]),
              m = d(m, g, h, f, c, 20, b[19]),
              f = d(f, m, g, h, r, 5, b[20]),
              h = d(h, f, m, g, B, 9, b[21]),
              g = d(g, h, f, m, x, 14, b[22]),
              m = d(m, g, h, f, z, 20, b[23]),
              f = d(f, m, g, h, A, 5, b[24]),
              h = d(h, f, m, g, E, 9, b[25]),
              g = d(g, h, f, m, k, 14, b[26]),
              m = d(m, g, h, f, v, 20, b[27]),
              f = d(f, m, g, h, D, 5, b[28]),
              h = d(h, f,
                  m, g, j, 9, b[29]),
              g = d(g, h, f, m, w, 14, b[30]),
              m = d(m, g, h, f, u, 20, b[31]),
              f = l(f, m, g, h, r, 4, b[32]),
              h = l(h, f, m, g, v, 11, b[33]),
              g = l(g, h, f, m, C, 16, b[34]),
              m = l(m, g, h, f, E, 23, b[35]),
              f = l(f, m, g, h, e, 4, b[36]),
              h = l(h, f, m, g, z, 11, b[37]),
              g = l(g, h, f, m, w, 16, b[38]),
              m = l(m, g, h, f, B, 23, b[39]),
              f = l(f, m, g, h, D, 4, b[40]),
              h = l(h, f, m, g, c, 11, b[41]),
              g = l(g, h, f, m, k, 16, b[42]),
              m = l(m, g, h, f, t, 23, b[43]),
              f = l(f, m, g, h, A, 4, b[44]),
              h = l(h, f, m, g, u, 11, b[45]),
              g = l(g, h, f, m, x, 16, b[46]),
              m = l(m, g, h, f, j, 23, b[47]),
              f = s(f, m, g, h, c, 6, b[48]),
              h = s(h, f, m, g, w, 10, b[49]),
              g = s(g, h, f, m,
                  E, 15, b[50]),
              m = s(m, g, h, f, r, 21, b[51]),
              f = s(f, m, g, h, u, 6, b[52]),
              h = s(h, f, m, g, k, 10, b[53]),
              g = s(g, h, f, m, B, 15, b[54]),
              m = s(m, g, h, f, e, 21, b[55]),
              f = s(f, m, g, h, v, 6, b[56]),
              h = s(h, f, m, g, x, 10, b[57]),
              g = s(g, h, f, m, t, 15, b[58]),
              m = s(m, g, h, f, D, 21, b[59]),
              f = s(f, m, g, h, z, 6, b[60]),
              h = s(h, f, m, g, C, 10, b[61]),
              g = s(g, h, f, m, j, 15, b[62]),
              m = s(m, g, h, f, A, 21, b[63]);
          a[0] = a[0] + f | 0;
          a[1] = a[1] + m | 0;
          a[2] = a[2] + g | 0;
          a[3] = a[3] + h | 0
      },
      _doFinalize: function() {
          var b = this._data,
              n = b.words,
              a = 8 * this._nDataBytes,
              c = 8 * b.sigBytes;
          n[c &gt;&gt;&gt; 5] |= 128 &lt;&lt; 24 - c % 32;
          var e = u.floor(a /
              4294967296);
          n[(c + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 15] = (e &lt;&lt; 8 | e &gt;&gt;&gt; 24) &amp; 16711935 | (e &lt;&lt; 24 | e &gt;&gt;&gt; 8) &amp; 4278255360;
          n[(c + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 14] = (a &lt;&lt; 8 | a &gt;&gt;&gt; 24) &amp; 16711935 | (a &lt;&lt; 24 | a &gt;&gt;&gt; 8) &amp; 4278255360;
          b.sigBytes = 4 * (n.length + 1);
          this._process();
          b = this._hash;
          n = b.words;
          for (a = 0; 4 &gt; a; a++) c = n[a], n[a] = (c &lt;&lt; 8 | c &gt;&gt;&gt; 24) &amp; 16711935 | (c &lt;&lt; 24 | c &gt;&gt;&gt; 8) &amp; 4278255360;
          return b
      },
      clone: function() {
          var b = v.clone.call(this);
          b._hash = this._hash.clone();
          return b
      }
  });
  t.MD5 = v._createHelper(r);
  t.HmacMD5 = v._createHmacHelper(r)
})(Math);
(function() {
  var u = CryptoJS,
      p = u.lib,
      d = p.Base,
      l = p.WordArray,
      p = u.algo,
      s = p.EvpKDF = d.extend({
          cfg: d.extend({
              keySize: 4,
              hasher: p.MD5,
              iterations: 1
          }),
          init: function(d) {
              this.cfg = this.cfg.extend(d)
          },
          compute: function(d, r) {
              for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length &lt; q;) {
                  n &amp;&amp; s.update(n);
                  var n = s.update(d).finalize(r);
                  s.reset();
                  for (var a = 1; a &lt; p; a++) n = s.finalize(n), s.reset();
                  b.concat(n)
              }
              b.sigBytes = 4 * q;
              return b
          }
      });
  u.EvpKDF = function(d, l, p) {
      return s.create(p).compute(d,
          l)
  }
})();
CryptoJS.lib.Cipher || function(u) {
  var p = CryptoJS,
      d = p.lib,
      l = d.Base,
      s = d.WordArray,
      t = d.BufferedBlockAlgorithm,
      r = p.enc.Base64,
      w = p.algo.EvpKDF,
      v = d.Cipher = t.extend({
          cfg: l.extend(),
          createEncryptor: function(e, a) {
              return this.create(this._ENC_XFORM_MODE, e, a)
          },
          createDecryptor: function(e, a) {
              return this.create(this._DEC_XFORM_MODE, e, a)
          },
          init: function(e, a, b) {
              this.cfg = this.cfg.extend(b);
              this._xformMode = e;
              this._key = a;
              this.reset()
          },
          reset: function() {
              t.reset.call(this);
              this._doReset()
          },
          process: function(e) {
              this._append(e);
              return this._process()
          },
          finalize: function(e) {
              e &amp;&amp; this._append(e);
              return this._doFinalize()
          },
          keySize: 4,
          ivSize: 4,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function(e) {
              return {
                  encrypt: function(b, k, d) {
                      return (&quot;string&quot; == typeof k ? c : a).encrypt(e, b, k, d)
                  },
                  decrypt: function(b, k, d) {
                      return (&quot;string&quot; == typeof k ? c : a).decrypt(e, b, k, d)
                  }
              }
          }
      });
  d.StreamCipher = v.extend({
      _doFinalize: function() {
          return this._process(!0)
      },
      blockSize: 1
  });
  var b = p.mode = {},
      x = function(e, a, b) {
          var c = this._iv;
          c ? this._iv = u : c = this._prevBlock;
          for (var d = 0; d &lt; b; d++) e[a + d] ^=
              c[d]
      },
      q = (d.BlockCipherMode = l.extend({
          createEncryptor: function(e, a) {
              return this.Encryptor.create(e, a)
          },
          createDecryptor: function(e, a) {
              return this.Decryptor.create(e, a)
          },
          init: function(e, a) {
              this._cipher = e;
              this._iv = a
          }
      })).extend();
  q.Encryptor = q.extend({
      processBlock: function(e, a) {
          var b = this._cipher,
              c = b.blockSize;
          x.call(this, e, a, c);
          b.encryptBlock(e, a);
          this._prevBlock = e.slice(a, a + c)
      }
  });
  q.Decryptor = q.extend({
      processBlock: function(e, a) {
          var b = this._cipher,
              c = b.blockSize,
              d = e.slice(a, a + c);
          b.decryptBlock(e, a);
          x.call(this,
              e, a, c);
          this._prevBlock = d
      }
  });
  b = b.CBC = q;
  q = (p.pad = {}).Pkcs7 = {
      pad: function(a, b) {
          for (var c = 4 * b, c = c - a.sigBytes % c, d = c &lt;&lt; 24 | c &lt;&lt; 16 | c &lt;&lt; 8 | c, l = [], n = 0; n &lt; c; n += 4) l.push(d);
          c = s.create(l, c);
          a.concat(c)
      },
      unpad: function(a) {
          a.sigBytes -= a.words[a.sigBytes - 1 &gt;&gt;&gt; 2] &amp; 255
      }
  };
  d.BlockCipher = v.extend({
      cfg: v.cfg.extend({
          mode: b,
          padding: q
      }),
      reset: function() {
          v.reset.call(this);
          var a = this.cfg,
              b = a.iv,
              a = a.mode;
          if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;
          else c = a.createDecryptor, this._minBufferSize = 1;
          this._mode = c.call(a,
              this, b &amp;&amp; b.words)
      },
      _doProcessBlock: function(a, b) {
          this._mode.processBlock(a, b)
      },
      _doFinalize: function() {
          var a = this.cfg.padding;
          if (this._xformMode == this._ENC_XFORM_MODE) {
              a.pad(this._data, this.blockSize);
              var b = this._process(!0)
          } else b = this._process(!0), a.unpad(b);
          return b
      },
      blockSize: 4
  });
  var n = d.CipherParams = l.extend({
          init: function(a) {
              this.mixIn(a)
          },
          toString: function(a) {
              return (a || this.formatter).stringify(this)
          }
      }),
      b = (p.format = {}).OpenSSL = {
          stringify: function(a) {
              var b = a.ciphertext;
              a = a.salt;
              return (a ? s.create([1398893684,
              ]).concat(a).concat(b) : b).toString(r)
          },
          parse: function(a) {
              a = r.parse(a);
              var b = a.words;
              if (1398893684 == b[0] &amp;&amp; 1701076831 == b[1]) {
                  var c = s.create(b.slice(2, 4));
                  b.splice(0, 4);
                  a.sigBytes -= 16
              }
              return n.create({
                  ciphertext: a,
                  salt: c
              })
          }
      },
      a = d.SerializableCipher = l.extend({
          cfg: l.extend({
              format: b
          }),
          encrypt: function(a, b, c, d) {
              d = this.cfg.extend(d);
              var l = a.createEncryptor(c, d);
              b = l.finalize(b);
              l = l.cfg;
              return n.create({
                  ciphertext: b,
                  key: c,
                  iv: l.iv,
                  algorithm: a,
                  mode: l.mode,
                  padding: l.padding,
                  blockSize: a.blockSize,
                  formatter: d.format
              })
          },
          decrypt: function(a, b, c, d) {
              d = this.cfg.extend(d);
              b = this._parse(b, d.format);
              return a.createDecryptor(c, d).finalize(b.ciphertext)
          },
          _parse: function(a, b) {
              return &quot;string&quot; == typeof a ? b.parse(a, this) : a
          }
      }),
      p = (p.kdf = {}).OpenSSL = {
          execute: function(a, b, c, d) {
              d || (d = s.random(8));
              a = w.create({
                  keySize: b + c
              }).compute(a, d);
              c = s.create(a.words.slice(b), 4 * c);
              a.sigBytes = 4 * b;
              return n.create({
                  key: a,
                  iv: c,
                  salt: d
              })
          }
      },
      c = d.PasswordBasedCipher = a.extend({
          cfg: a.cfg.extend({
              kdf: p
          }),
          encrypt: function(b, c, d, l) {
              l = this.cfg.extend(l);
              d = l.kdf.execute(d,
                  b.keySize, b.ivSize);
              l.iv = d.iv;
              b = a.encrypt.call(this, b, c, d.key, l);
              b.mixIn(d);
              return b
          },
          decrypt: function(b, c, d, l) {
              l = this.cfg.extend(l);
              c = this._parse(c, l.format);
              d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt);
              l.iv = d.iv;
              return a.decrypt.call(this, b, c, d.key, l)
          }
      })
}();
(function() {
  for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 &gt; c; c++) a[c] = 128 &gt; c ? c &lt;&lt; 1 : c &lt;&lt; 1 ^ 283;
  for (var e = 0, j = 0, c = 0; 256 &gt; c; c++) {
      var k = j ^ j &lt;&lt; 1 ^ j &lt;&lt; 2 ^ j &lt;&lt; 3 ^ j &lt;&lt; 4,
          k = k &gt;&gt;&gt; 8 ^ k &amp; 255 ^ 99;
      l[e] = k;
      s[k] = e;
      var z = a[e],
          F = a[z],
          G = a[F],
          y = 257 * a[k] ^ 16843008 * k;
      t[e] = y &lt;&lt; 24 | y &gt;&gt;&gt; 8;
      r[e] = y &lt;&lt; 16 | y &gt;&gt;&gt; 16;
      w[e] = y &lt;&lt; 8 | y &gt;&gt;&gt; 24;
      v[e] = y;
      y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e;
      b[k] = y &lt;&lt; 24 | y &gt;&gt;&gt; 8;
      x[k] = y &lt;&lt; 16 | y &gt;&gt;&gt; 16;
      q[k] = y &lt;&lt; 8 | y &gt;&gt;&gt; 24;
      n[k] = y;
      e ? (e = z ^ a[a[a[G ^ z]]], j ^= a[a[j]]) : e = j = 1
  }
  var H = [0, 1, 2, 4, 8,
          16, 32, 64, 128, 27, 54
      ],
      d = d.AES = p.extend({
          _doReset: function() {
              for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; j &lt; a; j++)
                  if (j &lt; d) e[j] = c[j];
                  else {
                      var k = e[j - 1];
                      j % d ? 6 &lt; d &amp;&amp; 4 == j % d &amp;&amp; (k = l[k &gt;&gt;&gt; 24] &lt;&lt; 24 | l[k &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | l[k &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | l[k &amp; 255]) : (k = k &lt;&lt; 8 | k &gt;&gt;&gt; 24, k = l[k &gt;&gt;&gt; 24] &lt;&lt; 24 | l[k &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | l[k &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | l[k &amp; 255], k ^= H[j / d | 0] &lt;&lt; 24);
                      e[j] = e[j - d] ^ k
                  }
              c = this._invKeySchedule = [];
              for (d = 0; d &lt; a; d++) j = a - d, k = d % 4 ? e[j] : e[j - 4], c[d] = 4 &gt; d || 4 &gt;= j ? k : b[l[k &gt;&gt;&gt; 24]] ^ x[l[k &gt;&gt;&gt; 16 &amp; 255]] ^ q[l[k &gt;&gt;&gt; 8 &amp; 255]] ^ n[l[k &amp; 255]]
          },
          encryptBlock: function(a, b) {
              this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l)
          },
          decryptBlock: function(a, c) {
              var d = a[c + 1];
              a[c + 1] = a[c + 3];
              a[c + 3] = d;
              this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s);
              d = a[c + 1];
              a[c + 1] = a[c + 3];
              a[c + 3] = d
          },
          _doCryptBlock: function(a, b, c, d, e, j, l, f) {
              for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; r &lt; m; r++) var q = d[g &gt;&gt;&gt; 24] ^ e[h &gt;&gt;&gt; 16 &amp; 255] ^ j[k &gt;&gt;&gt; 8 &amp; 255] ^ l[n &amp; 255] ^ c[p++],
                  s = d[h &gt;&gt;&gt; 24] ^ e[k &gt;&gt;&gt; 16 &amp; 255] ^ j[n &gt;&gt;&gt; 8 &amp; 255] ^ l[g &amp; 255] ^ c[p++],
                  t =
                  d[k &gt;&gt;&gt; 24] ^ e[n &gt;&gt;&gt; 16 &amp; 255] ^ j[g &gt;&gt;&gt; 8 &amp; 255] ^ l[h &amp; 255] ^ c[p++],
                  n = d[n &gt;&gt;&gt; 24] ^ e[g &gt;&gt;&gt; 16 &amp; 255] ^ j[h &gt;&gt;&gt; 8 &amp; 255] ^ l[k &amp; 255] ^ c[p++],
                  g = q,
                  h = s,
                  k = t;
              q = (f[g &gt;&gt;&gt; 24] &lt;&lt; 24 | f[h &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[k &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[n &amp; 255]) ^ c[p++];
              s = (f[h &gt;&gt;&gt; 24] &lt;&lt; 24 | f[k &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[n &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[g &amp; 255]) ^ c[p++];
              t = (f[k &gt;&gt;&gt; 24] &lt;&lt; 24 | f[n &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[g &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[h &amp; 255]) ^ c[p++];
              n = (f[n &gt;&gt;&gt; 24] &lt;&lt; 24 | f[g &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[h &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[k &amp; 255]) ^ c[p++];
              a[b] = q;
              a[b + 1] = s;
              a[b + 2] = t;
              a[b + 3] = n
          },
          keySize: 8
      });
  u.AES = p._createHelper(d)
})();

module.exports = CryptoJS
</code></pre>
<ol start="2">
<li>需要使用加密操作的接口文件中，引入已经封装加解密方法进行接口的加解密操作</li>
</ol>
<pre><code>&lt;!-- 引入方法 --&gt;
const CryptoJS = require('./utils/public');

&lt;!-- 拼接需要调用的接口名称和所需的参数信息 --&gt;
var data = '{&quot;url&quot;: &quot;/login/sendSMS&quot;, &quot;openid&quot;: &quot;'+ wx.getStorageSync('openid') +'&quot;, &quot;userName&quot;: &quot;'+ this.data.oaName +'&quot;, &quot;userMobile&quot;: &quot;'+ this.data.tel +'&quot;}';
&lt;!-- 使用CryptoJS.Encryp将拼接的信息进行加密，得到密文字符串 --&gt;
      var encrypt = CryptoJS.Encrypt(data)
&lt;!-- 此处微信小程序为例，请求调用 --&gt;
      request({ 
&lt;!-- url处填写和后端协商好的固定接口地址，接口的二次封装 --&gt;
        url: 'http://localhost:8080/miniprogram-union/common',
&lt;!-- data处传拼接和加密好的接口名称和参数信息 --&gt;
        data: encrypt,
        method: &quot;POST&quot;, 
        }).then(result =&gt; {
&lt;!--  通过CryptoJS.Decrypt解密方法解密后端传过来的返回值--&gt;
        var res = CryptoJS.Decrypt(result.data);
&lt;!-- 解密得到的值一般为 JSON 对象形式，需要转为js对象 --&gt;
        var smsInfo = JSON.parse(res)
&lt;!-- 微信小程序中将得到的数据放到data中并在页面渲染 --&gt;
        this.setData({
            smsInfoList: smsInfo.data
        })
      })   
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后端代码本地打包运行]]></title>
        <id>https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-ben-di-ce-shi-jie-kou/</id>
        <link href="https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-ben-di-ce-shi-jie-kou/">
        </link>
        <updated>2021-01-28T01:41:32.000Z</updated>
        <content type="html"><![CDATA[<pre><code>zsh: command not found: mvn 解决命令
source ~/.bash_profile
</code></pre>
<ol>
<li>以Mac环境为例，需要先检查本地是否安装Maven</li>
</ol>
<pre><code>mvn -v  
</code></pre>
<ol start="2">
<li>安装mvn后，由于下载较慢，建议配置阿里云打包，进入maven目录下的 conf 文件下，打开settings.xml 文件，添加以下代码</li>
</ol>
<pre><code>&lt;mirrors&gt;
    &lt;mirror&gt;
      &lt;id&gt;mirrorId&lt;/id&gt;
      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;
      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;
      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;
    &lt;/mirror&gt;
     --&gt;
	 &lt;mirror&gt;
	   &lt;id&gt;nexus-aliyun&lt;/id&gt;
	   &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
	   &lt;name&gt;Nexus aliyun&lt;/name&gt;
	   &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
	 &lt;/mirror&gt;
  &lt;/mirrors&gt;
</code></pre>
<ol start="3">
<li>进入后端代码所在的项目目录下，运行Maven打包命令</li>
</ol>
<pre><code>mvn package -DskipTests
</code></pre>
<p>停止运行命令</p>
<pre><code>mvn clean
</code></pre>
<p>运行完成命令后会在项目文件夹下得到一个target文件，target文件下的war就可以在本地 tomcat 运行了需要下载安装 Tomcat 来运行一个war包<br>
4. 将后端项目代码中已经配置好的 xxx.war 文件拷贝至 tomcat文件目录下的 webapps下<br>
<img src="https://qinyu312.github.io/post-images/1611799120504.png" alt="" loading="lazy"><br>
5. 命令行进入到 Tomcat 下的 bin 目录</p>
<p>命令行启动 startup.sh<br>
<img src="https://qinyu312.github.io/post-images/1611799131274.png" alt="" loading="lazy"><br>
<code>sudo sh ./startup.sh</code><br>
命令行结束运行<br>
<img src="https://qinyu312.github.io/post-images/1611799138646.png" alt="" loading="lazy"><br>
<code>sudo sh ./shutdown.sh</code><br>
命令行查看 Tomcat所有进程<br>
<img src="https://qinyu312.github.io/post-images/1611799147086.png" alt="" loading="lazy"><br>
<code>ps -ef|grep java</code><br>
命令行强制终止 某些 Tomcat进程<br>
<code>kill -9 端口号</code></p>
<ol start="6">
<li>startup.sh 启动后就可以在浏览器输入 localhost:8080测试 Tomcat 启动的情况</li>
<li>把接口请求处的测试地址换成 localhost:8080 调用接口测试，数据正常返回，本地调用成功</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序开发随记]]></title>
        <id>https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-kai-fa/</id>
        <link href="https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-kai-fa/">
        </link>
        <updated>2020-12-25T07:53:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="button-无法设置宽高">button 无法设置宽高</h2>
<p>当前版本的微信小程序，在.wxss文件里设置Button宽度无效,调整不会被应用到元素上</p>
<pre><code>.btn {
    width: 80%;
    height: 80rpx;
}
</code></pre>
<p>第一种方式是把 app.json里的  style: v2语句删掉。<br>
这样虽然也可以解决问题，但会导致全局的样式变化。<br>
第二种方式可以很便捷的解决问题，就是直接在 button标签的行内添加样式</p>
<pre><code>&lt;button style=&quot;width: 80%; height: 80rpx&quot;&gt;提交&lt;/button&gt;
</code></pre>
<p>按钮宽高生效</p>
<h2 id="微信小程序跳转操作">微信小程序跳转操作</h2>
<pre><code>&lt;!-- 1. 跳转到页面后左上角不会有返回角标及操作，但是不可以跳转到根级别的tab页面 --&gt;
wx.redirectTo({
    url: '/pages/oa_login/index',
})

&lt;!-- 2. 这个方法之能跳转到 app.json 里面定义的 主 tab页面，如首页，我的这种 --&gt;
wx.switchTab({
    url: '/pages/index/index',
})

&lt;!-- 3. 页面跳转且会有返回操作，但是不可以跳转到根级别的tab页面 --&gt;
wx.navigataTo({
    url: '/pages/oa_login/index',
})

&lt;!-- 绝对路径跳转，一般用于页面token失效需要重新跳转到登陆页面使用 --&gt;
wx.reLaunch({  //绝对路径跳转
      url: &quot;/pages/health_page/health_list/index&quot;,
    });
</code></pre>
<h2 id="微信小程序轻提示">微信小程序轻提示</h2>
<pre><code>wx.showToast({
    title: info.message,
    icon: 'none',
    duration: 1500
})
</code></pre>
<h2 id="微信小程序返回上一页面数据不刷新解决">微信小程序返回上一页面数据不刷新解决</h2>
<p>当你在某活动详情页调用方法后数据发生改变，然后返回上一个页面，活动列表中的数据没有发生更新，此时可以使用以下两种方式</p>
<ol>
<li>简单粗暴的 onShow:function() {}方法中调用 获取列表数据的方法 ，但是会重新加载整个页面，增加开销且比较慢。</li>
</ol>
<pre><code>onShow: function() {
    this.onLoad();
}
</code></pre>
<ol>
<li>在子页面中进行某些操作的时候，后台刷新父页面，此时返回父页面数据已更新且不会重新加载，比较推荐的用法，快速且不会有多余消耗</li>
</ol>
<pre><code>&lt;!-- 父页面定义更新方法 --&gt;
changeData: function() {
    this.onLoad();
 },

&lt;!-- 子页面某处触发方法 --&gt;
changeParentData: function() {
    var pages = getCurrentPages();  //当前页面栈
    if(pages.length &gt; 1) {
      var beforePage = pages[pages.length - 2] //获取上一个页面的实例对象
      beforePage.changeData() // 触发父页面中的更新方法
      console.log('更新成功了吗？？？')
    }
  },
</code></pre>
<h2 id="微信小程序获取当前经纬度定位信息">微信小程序获取当前经纬度定位信息</h2>
<p>在微信小程序开发者工具中测试获取到的经纬度信息有较大的偏差，不够准确，手机上测试相对较为精准，后续会持续优化精准度。</p>
<!-- 在 app.json里面设置是否允许获取当前定位信息的弹窗 -->
<pre><code>{
    &quot;pages&quot;:[
        &quot;pages/index/index&quot;,
    ],
    &lt;!-- 是否允许获取定位信息 --&gt;
    &quot;permission&quot;: {
        &quot;scope.userLocation&quot;: {
        &quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot;
        }
    },
}
&lt;!-- 在需要获取定位信息的 js 里面调用微信获取经纬度位置的API    wx.getLocation({})   --&gt;
onLoad: function(options) {
    // 获取当前经纬度定位信息API 
      wx.getLocation({
        altitude: 'altitude',
        isHighAccuracy: true, 
        success(res) {
            &lt;!-- 返回定位信息    longitude字段为经度     latitude为纬度--&gt;
            console.log(res)
          this.setData({
            // 经度
            longitude: res.longitude,
            // 纬度
            latitude: res.latitude
          })
        }
      })
}
</code></pre>
<h2 id="微信小程序时间戳转换成微信时间规范">微信小程序时间戳转换成微信时间规范</h2>
<pre><code>getUnionList() {
    &lt;!-- 参数加密请求 --&gt;
    var data = '{&quot;url&quot;: &quot;/data/infoList&quot;, &quot;userId&quot;: &quot;'+ wx.getStorageSync('userId') +'&quot;}';
    var encrypt = CryptoJS.Encrypt(data)
    request({ 
      url: '',
      data: encrypt,
      method: &quot;POST&quot;, })
    .then(result =&gt; {
      var res = CryptoJS.Decrypt(result.data);
      var unionInfo = JSON.parse(res)
      unionInfo.data.forEach(element =&gt; {
        let daySec, dayMin, dayHour, dayS
        let timeNow = new Date().getTime()
        let ts = (timeNow - element.mienTime) / 1000
        dayS = Math.round(ts / (24 * 60 * 60))
        dayHour = Math.round(ts / (60 * 60))
        dayMin = Math.round(ts / 60)
        daySec = Math.round(ts)
        if (dayS &gt; 7 &amp;&amp; dayS &lt; 365) {
          var date=new Date(parseInt(element.infoDate));
          var mon = date.getMonth()+1;
          var day = date.getDate();
          element.infoDate = mon+'/'+day;
          return mon+'/'+day;
        } else if (dayS &gt; 2 &amp;&amp; dayS &lt; 7) {
          element.infoDate = `${dayS} 天以前`
          return `${dayS} 天以前`
        } else if(dayS &gt; 0 &amp;&amp; dayS &lt; 2) {
          element.infoDate = `${dayS} 天以前`
          return `${dayS} 天以前`
        } else if (dayS &lt;= 0 &amp;&amp; dayHour &gt; 0) {
          element.infoDate = `${dayHour} 小时以前`
          return `${dayHour} 小时以前`
        } else if (dayHour &lt;= 0 &amp;&amp; dayMin &gt; 0) {
          element.infoDate = `${dayMin} 分钟以前`
          return `${dayMin} 分钟以前`
        } else if (dayMin &lt;= 0 &amp;&amp; daySec &gt;= 0) {
          element.infoDate = '刚刚'
          return '刚刚'
        } else {
          var date=new Date(parseInt(element.infoDate));
          var year=date.getFullYear();
          var mon = date.getMonth()+1;
          var day = date.getDate();
          element.infoDate = year+'/'+mon+'/'+day;
          return year+'/'+mon+'/'+day;
        }
      });
      console.log(unionInfo)
      this.setData({
        unionList: unionInfo.data,
      })
    }) 
  },
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Angular项目避坑指南]]></title>
        <id>https://qinyu312.github.io/post/angular-xiang-mu-bi-keng-zhi-nan/</id>
        <link href="https://qinyu312.github.io/post/angular-xiang-mu-bi-keng-zhi-nan/">
        </link>
        <updated>2020-11-24T10:15:01.000Z</updated>
        <content type="html"><![CDATA[<p>最近收到一个新的需求，有一个Angular项目需要兼容到 IE8 以上版本，实在让我又惊又喜，惊的是都 2020年了，还甩不掉 IE8 这颗烫手山芋；喜的是第一次接触 Angular项目，不知道又会学到什么新的知识呢。拉到项目代码后，本地启动，果然给我来了迎头痛击。<br>
首先确认本地安装有Node.js环境后，全局安装 Angular-cli ，也就是Angular脚手架,命令行输入：</p>
<pre><code>cnpm install -g @angular/cli
</code></pre>
<p>然后就是老步骤，下载node_modules 依赖包</p>
<pre><code>cnpm install
</code></pre>
<p>之后直接 ng serve 启动命令有点别具一格的简洁，直接芜湖🛫️</p>
<pre><code>ng serve
</code></pre>
<p>接下来，就是见证 奇迹（打脸）的时刻<br>
<img src="https://qinyu312.github.io/post-images/1606213638697.png" alt="" loading="lazy"><br>
我敲完命令一回车，啪的一下满屏飙红报错，很快啊，我就看到是依赖包的问题，按照传统功夫的看到为止，我没有看下去，上去就是一个卸载依赖，一个 cnpm install ，我大意了啊，没有删完，接着又是飙红报错。Angular 不讲武德，来欺，为难我入行一年多点的小前端，希望它以后耗子尾汁！<br>
<img src="https://qinyu312.github.io/post-images/1606228631691.png" alt="" loading="lazy"><br>
最后在 node_modules 下的 less-loader 加上一句  javascriptEnabled: true  ，问题得到解决<br>
<img src="https://qinyu312.github.io/post-images/1606228810583.png" alt="" loading="lazy"></p>
<p>项目成功启动，再来解决兼容IE8的问题，<a href="https://angular.cn/guide/browser-support">Angular</a>，官方文档浏览器兼容部分我们可以看到， IE 10, 11, 9，也就是说连官方都放弃去做IE9一下的兼容了。<br>
<img src="https://qinyu312.github.io/post-images/1606461891938.png" alt="" loading="lazy"><br>
忍不住又想吐槽IE一把，但是客户需求在身，只能硬着头皮做了，因为Angular在国内市场的使用还不是特别频繁，所以我在百度没有什么收获之后，决定翻墙去 Google ，Angular 也不亏是 Google的亲儿子。方案当然是有的。需要将Angular版本降低至 1.2一以下可以对IE8进行兼容适配。然后就是传统功夫的卸载新版本，安装旧版本。</p>
<pre><code>&lt;!-- 卸载新版本 --&gt;
cnpm uninstall -g @angular/cli
&lt;!-- 安装新版本 --&gt;
cnpm install -g @angular/cli/1.1
</code></pre>
<p>问题得到解决，兼容是好了，样式又乱的简直是乱他妈妈给乱开门  -  乱到家了。不说了，我要去调样式了！<br>
<img src="https://qinyu312.github.io/post-images/1606462146562.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React各种零碎知识合集]]></title>
        <id>https://qinyu312.github.io/post/js-ge-chong-ling-sui-zhi-shi-he-ji/</id>
        <link href="https://qinyu312.github.io/post/js-ge-chong-ling-sui-zhi-shi-he-ji/">
        </link>
        <updated>2020-07-28T02:37:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="react里的事件">React里的事件</h2>
<pre><code>&lt;!-- onChange事件 --&gt;
this.handleChange = this.handleChange.bind(this)
handleChange(event) {
    this.setState({value: event.target.value})
}
&lt;textarea onChange={ this.handleChange } /&gt;  

&lt;!-- onSubmit事件 --&gt;
this.handleSubmit = this,handleSubmit(this)
handleSubmit(event) {
    alert('提交' + this.state.value + '成功!')
    event.preventDefault()    
    &lt;!-- 清除默认事件 --&gt;
}
&lt;form onSubmit= { this.handleSubmit }&gt;&lt;/form&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于各种浏览器兼容(持续更新中)]]></title>
        <id>https://qinyu312.github.io/post/guan-yu-ge-chong-ie-jian-rong/</id>
        <link href="https://qinyu312.github.io/post/guan-yu-ge-chong-ie-jian-rong/">
        </link>
        <updated>2020-07-15T10:07:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ie条件注释">IE条件注释</h2>
<p>IE10以下版本可用，IE11已经取消支持</p>
<pre><code>&lt;!--[if lte IE 8]&gt; 	
        &lt;script src=&quot;/js/html5.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/js/css3-mediaqueries.js&quot;&gt;&lt;/script&gt;
        &lt;link href=&quot;/css/ie8.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
&lt;![endif]--&gt;
</code></pre>
<p>因为IE11不支持条件注释，可以使用正则判断</p>
<pre><code>var browser = navigator.appName;
var ie11 = !!navigator.userAgent.match(/Trident\/7\./);
if (browser == 'Microsoft Internet Explorer' || ie11 == true) {
    //do something
}
</code></pre>
<h2 id="ie9部分页面不显示的问题">IE9部分页面不显示的问题</h2>
<pre><code>IE9是不支持 console.log 打印输出语句的，在非开发者模式下会阻塞不会执行后面的内容
</code></pre>
<h2 id="ie9-及以下-ie浏览器不支持placeholder属性">IE9 及以下 IE浏览器不支持placeholder属性</h2>
<pre><code>引入 jquery和用于解决这个属性兼容的CDN
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.ijquery.cn/js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.ijquery.cn/js/jquery.placeholder.min.js&quot;&gt;&lt;/script&gt;

&lt;%--兼容IE9及以下input输入框，textarea文本框不支持提示文本placeholder属性的问题--%&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function(){ $('input, textarea').placeholder(); });
&lt;/script&gt;
</code></pre>
<p>上面这种方法在HTML文件中亲测有效，但是不知道为什么在前后端不分离JSP项目中不会生效，以某国企老项目为例，需要在每个页面的JS代码中加上</p>
<pre><code>	&lt;!-- css代码 --&gt;
    .phcolor{ 
			color:#999;
	}

    &lt;!-- js代码 --&gt;
	// placeholder兼容IE9
	$(function(){
	  //判断浏览器是否支持placeholder属性
	  supportPlaceholder='placeholder'in document.createElement('input'),
	  placeholder=function(input){
	    var text = input.attr('placeholder'),
	    defaultValue = input.defaultValue;
	    if(!defaultValue){
	      input.val(text).addClass(&quot;phcolor&quot;);
	    }
	    input.focus(function(){
	      if(input.val() == text){
	        $(this).val(&quot;&quot;);
	      }
	    });
	    input.blur(function(){
	      if(input.val() == &quot;&quot;){
	        $(this).val(text).addClass(&quot;phcolor&quot;);
	      }
	    });
	    //输入的字符不为灰色
	    input.keydown(function(){
	      $(this).removeClass(&quot;phcolor&quot;);
	    });
	  };
	  //当浏览器不支持placeholder属性时，调用placeholder函数
	  if(!supportPlaceholder){
	    $('input').each(function(){
	      text = $(this).attr(&quot;placeholder&quot;);
	      if($(this).attr(&quot;type&quot;) == &quot;text&quot;){
	        placeholder($(this));
	      }
	    });
	  }
	});
</code></pre>
<h2 id="换行word-wrap与word-break兼容ie和火狐-chrome">换行word-wrap与word-break兼容ie和火狐、chrome</h2>
<ol>
<li>word-wrap控制换行，使用break-word时，会强制进行换行，中文没问题，英文语句没问题，长串的英文不会生效。</li>
<li>word-break控制是否断词<br>
normal是默认情况，英文单词不被拆开<br>
break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题。<br>
keep-all，是指Chinese, Japanese, and Korean不断词。即只用此时，不用word-wrap，中文就不会换行了。（英文语句正常。）<br>
所以，要做到英文和中文等强制换行，需要组合使用如下</li>
</ol>
<pre><code>&lt;p style=&quot;word-wrap: break-word; word-break: break-all&quot;&gt;&lt;/p&gt;
</code></pre>
<h2 id="js判断移动端浏览器还是pc浏览器">JS判断移动端浏览器还是PC浏览器</h2>
<pre><code>window.parent.location.href = /Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent) ? &quot;${context}/erpGuaranteeFlowController/findErpGuaranteeApprovalNew.do&quot; :  &quot;${context}/erpItosController/toDoList&quot;;


var userAgentInfo = navigator.userAgent;
var Agents = [&quot;Android&quot;, &quot;iPhone&quot;,
            &quot;SymbianOS&quot;, &quot;Windows Phone&quot;,
            &quot;iPad&quot;, &quot;iPod&quot;];
var flag = true;
for (var v = 0; v &lt; Agents.length; v++) {
    if (userAgentInfo.indexOf(Agents[v]) &gt; 0) {
        flag = false;
        break;
    }
}

if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
	&lt;!-- 移动端设备 --&gt;
	h5flag = false
} else {
	&lt;!-- pc端设备 --&gt;
	h5flag = true
}
</code></pre>
]]></content>
    </entry>
</feed>