<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://qinyu312.github.io</id>
    <title>҉҉҈淸鷠҉҉҈、</title>
    <updated>2020-12-08T15:48:38.482Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://qinyu312.github.io"/>
    <link rel="self" href="https://qinyu312.github.io/atom.xml"/>
    <subtitle>万般皆苦，唯有自渡</subtitle>
    <logo>https://qinyu312.github.io/images/avatar.png</logo>
    <icon>https://qinyu312.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ҉҉҈淸鷠҉҉҈、</rights>
    <entry>
        <title type="html"><![CDATA[Fetch querystring  跨域解决]]></title>
        <id>https://qinyu312.github.io/post/fetch-shu-ju-jie-kou-qing-qiu/</id>
        <link href="https://qinyu312.github.io/post/fetch-shu-ju-jie-kou-qing-qiu/">
        </link>
        <updated>2020-12-08T14:38:43.000Z</updated>
        <content type="html"><![CDATA[<p>以前写数据接口，对接请求都是使用的Ajax，或者Axios之类的，最近在使用React进行开发，用到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">fetch</a>, 和<a href="http://nodejs.cn/api/querystring.html">querystring</a></p>
<pre><code>import qs from 'querystring'
&lt;!-- get请求 --&gt;
fetch(&quot;http://iwenwiki.com/api/blueberrypai/getChengpinInfo.php&quot;)
.then(res =&gt; res.json())
.then(data =&gt; {
    console.log(data)
})

&lt;!-- post请求 --&gt;
fetch(&quot;http://iwenwiki.com/api/blueberrypai/login.php&quot;, {
    method: 'POST' ,   // 请求方式
    headers: {            // 请求头
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json, text/plain, */*',
    },
    &lt;!-- body: &quot;user_id=iwen@qq.com&amp;password=iwen123&amp;verification_code=crfvw&quot; --&gt;
    &lt;!-- 此处传参使用字符串传参的方式，所以需要参数间 &amp; 分隔拼串 --&gt;
    &lt;!-- 如果不想写拼串，也可以直接引入 querystring来进行转换操作如下 --&gt;
    body: qs.stringify({
        'user_id': 'iwen@qq.com',
        'password': 'iwen123',
        'verification_code': 'crfvw'
    })
})
</code></pre>
<h2 id="跨域的解决方案">跨域的解决方案</h2>
<p>跨域一般分为两种场景： 开发环境下的跨域问题和生产环境下的跨域问题<br>
此处以React项目开发环境下为例</p>
<pre><code>componentDidMount() {
    fetch(&quot;http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0&quot;)
    .then(res =&gt; res.json())
    .then(data =&gt; {
        console.log(data)
    })
    .catch(error =&gt; {
        console.log(new Error(error))
    })
}
</code></pre>
<p><img src="https://qinyu312.github.io/post-images/1607442245412.png" alt="" loading="lazy"><br>
此处请求会跨域<br>
需要在 package.json 文件中配置 proxy 代理解决<br>
<img src="https://qinyu312.github.io/post-images/1607442296763.png" alt="" loading="lazy"><br>
配置完成 package.json 文件后需要将请求接口前面的已经被代理的地址去掉如下</p>
<pre><code>componentDidMount() {
    fetch(&quot;/v1/restserver/ting?method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0&quot;)
    .then(res =&gt; res.json())
    .then(data =&gt; {
        console.log(data)
    })
    .catch(error =&gt; {
        console.log(new Error(error))
    })
}
</code></pre>
<p>然后终止此项目进程，重新运行该项目即可使用代理解决跨域问题。打开浏览器调试，接口数据正常请求得到。<br>
<img src="https://qinyu312.github.io/post-images/1607442458895.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于各种IE兼容(持续更新中)]]></title>
        <id>https://qinyu312.github.io/post/guan-yu-ge-chong-ie-jian-rong/</id>
        <link href="https://qinyu312.github.io/post/guan-yu-ge-chong-ie-jian-rong/">
        </link>
        <updated>2020-12-04T10:07:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="条件注释">条件注释</h2>
<p>IE10以下版本可用，IE11已经取消支持</p>
<pre><code>&lt;!--[if lte IE 8]&gt; 	
        &lt;script src=&quot;/js/html5.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/js/css3-mediaqueries.js&quot;&gt;&lt;/script&gt;
        &lt;link href=&quot;/css/ie8.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
&lt;![endif]--&gt;
</code></pre>
<p>因为IE11不支持条件注释，可以使用正则判断</p>
<pre><code>var browser = navigator.appName;
var ie11 = !!navigator.userAgent.match(/Trident\/7\./);
if (browser == 'Microsoft Internet Explorer' || ie11 == true) {
    //do something
}
</code></pre>
<h2 id="ie9部分页面不显示的问题">IE9部分页面不显示的问题</h2>
<pre><code>IE9是不支持 console.log 打印输出语句的，在非开发者模式下会阻塞不会执行后面的内容
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Angular项目避坑指南]]></title>
        <id>https://qinyu312.github.io/post/angular-xiang-mu-bi-keng-zhi-nan/</id>
        <link href="https://qinyu312.github.io/post/angular-xiang-mu-bi-keng-zhi-nan/">
        </link>
        <updated>2020-11-24T10:15:01.000Z</updated>
        <content type="html"><![CDATA[<p>最近收到一个新的需求，有一个Angular项目需要兼容到 IE8 以上版本，实在让我又惊又喜，惊的是都 2020年了，还甩不掉 IE8 这颗烫手山芋；喜的是第一次接触 Angular项目，不知道又会学到什么新的知识呢。拉到项目代码后，本地启动，果然给我来了迎头痛击。<br>
首先确认本地安装有Node.js环境后，全局安装 Angular-cli ，也就是Angular脚手架,命令行输入：</p>
<pre><code>cnpm install -g @angular/cli
</code></pre>
<p>然后就是老步骤，下载node_modules 依赖包</p>
<pre><code>cnpm install
</code></pre>
<p>之后直接 ng serve 启动命令有点别具一格的简洁，直接芜湖🛫️</p>
<pre><code>ng serve
</code></pre>
<p>接下来，就是见证 奇迹（打脸）的时刻<br>
<img src="https://qinyu312.github.io/post-images/1606213638697.png" alt="" loading="lazy"><br>
我敲完命令一回车，啪的一下满屏飙红报错，很快啊，我就看到是依赖包的问题，按照传统功夫的看到为止，我没有看下去，上去就是一个卸载依赖，一个 cnpm install ，我大意了啊，没有删完，接着又是飙红报错。Angular 不讲武德，来欺，为难我入行一年多点的小前端，希望它以后耗子尾汁！<br>
<img src="https://qinyu312.github.io/post-images/1606228631691.png" alt="" loading="lazy"><br>
最后在 node_modules 下的 less-loader 加上一句  javascriptEnabled: true  ，问题得到解决<br>
<img src="https://qinyu312.github.io/post-images/1606228810583.png" alt="" loading="lazy"></p>
<p>项目成功启动，再来解决兼容IE8的问题，<a href="https://angular.cn/guide/browser-support">Angular</a>，官方文档浏览器兼容部分我们可以看到， IE 10, 11, 9，也就是说连官方都放弃去做IE9一下的兼容了。<br>
<img src="https://qinyu312.github.io/post-images/1606461891938.png" alt="" loading="lazy"><br>
忍不住又想吐槽IE一把，但是客户需求在身，只能硬着头皮做了，因为Angular在国内市场的使用还不是特别频繁，所以我在百度没有什么收获之后，决定翻墙去 Google ，Angular 也不亏是 Google的亲儿子。方案当然是有的。需要将Angular版本降低至 1.2一以下可以对IE8进行兼容适配。然后就是传统功夫的卸载新版本，安装旧版本。</p>
<pre><code>&lt;!-- 卸载新版本 --&gt;
cnpm uninstall -g @angular/cli
&lt;!-- 安装新版本 --&gt;
cnpm install -g @angular/cli/1.1
</code></pre>
<p>问题得到解决，兼容是好了，样式又乱的简直是乱他妈妈给乱开门  -  乱到家了。不说了，我要去调样式了！<br>
<img src="https://qinyu312.github.io/post-images/1606462146562.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-router 路由守卫]]></title>
        <id>https://qinyu312.github.io/post/vue-router-lu-you-shou-wei/</id>
        <link href="https://qinyu312.github.io/post/vue-router-lu-you-shou-wei/">
        </link>
        <updated>2020-11-23T01:59:18.000Z</updated>
        <content type="html"><![CDATA[<pre><code>有一段时间没有写过 vue 的项目了，最近工作中需要自己搭建，所以简单分享一下vue-router路由守卫!
</code></pre>
<p>项目中很常见的一种场景，需求是，用户打开网址进入线上地址，首先是登录页面，用户需要账号密码验证码等手段通过验证和赋权，才可以进入到包括首页，各种管理等内容页面，未登录之前，通过修改路由来进行跳转，如果确实存在此路由，会跳转到登录页面进行登录，如果没有这个路由，会跳转到 404 页面。而成功完成登录后再进行路由地址修改则可以正常跳转！<br>
这里就需要用到通配符匹配和 路由守卫等操作了</p>
<h2 id="通配符">通配符 *</h2>
<p>一般用于菜单路由匹配的最后面，为什么要放在最后面呢？因为放在前面会把写在它之后的路由菜单全部匹配进去，就相当于在小河的上游筑起水坝蓄水，那下游自然就没水了，所以通配符相当于确保没有漏网之鱼的作用，凡是没有被定义的路由，都会被它拦截，转而跳转到首页或者404等页面。</p>
<pre><code>&lt;!-- router 下的 index.js --&gt;
export default new Router({
  routes: [
    {
      path:'/home',
      name:'home',
      component:home
    },
    //通配符的使用
    {
      path: '/detail-*',
      component:detail
    },
    {
      path: '/*',
      component:notFound
    }
  ]
})
</code></pre>
<h2 id="beforeeach-前置路由守卫">beforeEach() 前置路由守卫</h2>
<p>当你随意修改路由地址上的路由菜单进行跳转，比如在 '/login' 修改为 '/home'却可以正常跳转时，在尚未登录赋权的情况下就可以进入程序主页面，是一种很不安全的操作，就需要用到路由守卫了！全局前置路由守卫用于路由跳转之前执行，他有三个参数 'to' 参数，表示你当前正要跳转到哪里去，也就是目标页面路由， 'from'参数表示，从哪里来的，也就是当前页面， next() 方法，一定需要调用，继续往下执行的函数。</p>
<pre><code>&lt;!-- 在 roter 文件下的路由配置处， 将meta下的 requireAuth 设置为 true作为此菜单不可不登录直接跳转的标记 --&gt;
{
    path: '/home',
    meta:{ requireAuth: true }
}
</code></pre>
<pre><code>&lt;!-- main.js --&gt;
beforeEach((to, form, next) =&gt; {
    console.log(to)
    console.log(from)
    &lt;!-- 如果要去的这个页面的路由配置中 meta.requireAuth 为 true的话 --&gt;
    if(to.meta.requireAuth) {
        &lt;!-- 判断本地存储是否有token令牌，如果有并且令牌合法，调用 next() 方法继续执行 --&gt;
        if(localStorage.getItem('access_token')) {
            next();
        } else {
            &lt;!-- 否则就直接调用next()方法跳转回登录页面重新登录 --&gt;
            next({
                path: '/login'
            })
        }
    } else {
        next();
    }
})
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://qinyu312.github.io/post-images/1606098979481.png" alt="" loading="lazy"></figure>
<p>设置完成之后保存并运行项目就会发现，在路径处修改路由不会直接跳转而是会自动拦截。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识React]]></title>
        <id>https://qinyu312.github.io/post/chu-shi-react/</id>
        <link href="https://qinyu312.github.io/post/chu-shi-react/">
        </link>
        <updated>2020-11-18T13:47:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="搭建react项目">搭建React项目</h2>
<p>在装有node.js的基础上，命令行输入命令</p>
<pre><code>npx create-react-app item-name
</code></pre>
<p>即可创建一个React项目，项目结构如下</p>
<figure data-type="image" tabindex="1"><img src="https://qinyu312.github.io/post-images/1605707465716.png" alt="" loading="lazy"></figure>
<h2 id="jsx语法">JSX语法</h2>
<p>src文件下的index.js是项目的入口文件，文件中先后引入了react和react-dom两个库。</p>
<pre><code>ReactDOM.render(&lt;h2&gt;hello react&lt;/h2&gt;, document.getElementById('root'));
</code></pre>
<p>ReactDOM实例通过render方法，将前面的h2标签元素，添加到root元素中，而id为root的元素是public文件的index.html文件的元素。<br>
JSX语法由JavaScript语法 和 XML语法组成，通俗来说就是，当我们在JSX语句中遇到 &lt;&gt; 的形式的，按照XML的形式来解析，因为他们是标签；遇到 {} 按照javaScript来解析，表示JS语法。</p>
<pre><code>const a = (
        &lt;div&gt;
            &lt;p&gt;hello react&lt;/p&gt;
        &lt;/div&gt;
) 
</code></pre>
<p>如果存在标签结构，并且标签结构需要换行的话，可以使用 （）的形式进行表示</p>
<h2 id="react-元素渲染">React 元素渲染</h2>
<p>这里通过一个实例了解react的元素渲染</p>
<pre><code>&lt;!-- 首先定义一个方法 --&gt;
function nowTime() {
    const ele = (
        &lt;!-- 使用()的形式，可以换行写标签语法 --&gt;
        &lt;h2&gt;get now time&lt;/h2&gt;  
        &lt;!-- 定义一个获取当前时间的方法 --&gt;
        &lt;h1&gt;now time is { new Date().toLocalTimeString() } &lt;/h1&gt;
    )
    &lt;!-- 渲染这个获取当前时间的方法 --&gt;
    reactDOM.render(ele, document.getElementById('root));
}
&lt;!-- 定时器每隔一秒会调用一次该方法，实现实时更新当前时间 --&gt;
setInterval(() =&gt; {
    nowTime()
},1000)

</code></pre>
<h2 id="react-组件">React 组件</h2>
<p>关于Ract组件，区别于vue的以 .vue为后缀结尾的文件，React的组件可以是以 .js 为后缀的文件，也可以是 .jsx 为后缀的文件命名。编写React组件的时候，创建 .js 的组件是没有代码语法提示的，而创建 .jsx 组件文件是有代码语法提示的。 创建React组件分别有两种方式，第一种是通过 类的形式创建组件，第二种是通过Hook的形式创建。并且组件之间是可以互相引入和使用的，以标签的形式存在！</p>
<pre><code>&lt;!-- 第一种写法 --&gt;
&lt;!-- 创建一个React组件首先需要引入 React 库 --&gt;
import React from 'react'
&lt;!-- 创建一个类App继承React所提供的Component组件的对象 --&gt;
class App extends React Component {
    &lt;!-- rander(){} 渲染函数 --&gt;
    render() {
        &lt;p&gt;渲染函数中写你需要这个组件展示的内容，或者要做什么&lt;/p&gt;
    }
}
&lt;!-- 导出组件 --&gt;
export default App

&lt;!-- 第二种写法 --&gt;
import React from 'react'

export default class App extends React.Component{
    render() {
        return {
            &lt;div&gt;
                &lt;p&gt;直接导出并继承React下的Component对象&lt;/p&gt;
            &lt;/div&gt;
        }
    }
}
</code></pre>
<pre><code>&lt;!-- 函数组件 --&gt;
function fun(props) {
    return (
        &lt;div&gt;
            &lt;h3&gt;函数组件&lt;/h3&gt;
        &lt;/div&gt;
    )
}
&lt;!-- ES6 class类组件 --&gt;
class App extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h3&gt;ES6 class类创建组件&lt;/h3&gt;  
            &lt;/div&gt;
        )
    }
}
</code></pre>
<p>然后在需要使用的地方引入该组件,并将其放置在渲染函数中渲染即可。</p>
<pre><code>import 'App' from './App.jsx'
ReactDOM.render(&lt;App /&gt;, document.getElementById('root));

</code></pre>
<h3 id="props组件动态传参">Props组件动态传参</h3>
<p>React里面的组件传参通过 props</p>
<h3 id="父组件传递参数给子组件">父组件传递参数给子组件</h3>
<pre><code>&lt;!-- 子组件 --&gt;
import React from 'react'
export default class Son extends React.Component {
    render() {
        return {
            &lt;div&gt;
                &lt;ul&gt;
                    {
                    &lt;!-- 子组件中 通过this.props的方式获取父组件传递过来的数据，也就是arr ,然后通过map来遍历获取到的数据--&gt;
                        this.props.arr.map((element, index) =&gt; {
                            &lt;!-- 将遍历得到的数据放在li标签中渲染返回，key值需要绑定index唯一值，否则会抛出语法error --&gt;
                            return &lt;li key={ index }&gt;{ element }&lt;/li&gt;
                        })
                    }
                &lt;/ul&gt;            
            &lt;/div&gt;
        }
    }
}
</code></pre>
<pre><code>import React from 'react'
&lt;!-- 引入子组件 --&gt;
import Son from './son'
export default class Father extends React.Component {
    render() {
        &lt;!-- 父组件定义两个数组，用于传递给子组件使用 --&gt;
        const arrOne = ['Vue' , 'React', 'Angular'],
                 arrTwo = ['Java', 'Pythen', 'C++']
        return (
            &lt;!-- 在两个子组件中分别传入不同的数据 --&gt;
            &lt;Son arr={ arrOne } /&gt;
            &lt;Son arr={ arrTwo } /&gt;
        )
    }
}
</code></pre>
<h3 id="子组件传递参数给父组件">子组件传递参数给父组件</h3>
<pre><code>&lt;!-- 父组件 --&gt;
import React from 'react'
import Son from './son'
export defaul{t class Father React.Component {
    &lt;!-- 首先定义state用来存储title的状态 --&gt;
    constructor() {
        super();
        this.state = {
            title: ‘最初的标题’
        }
    }
    clickChange = () =&gt; {
        this.setState({
            title: '最后的标题'
        })
    }
    render()  {
        return (    
            &lt;div&gt;
                父子组件传参
            &lt;/div&gt;
            &lt;!-- 使用子组件,title最开始为 ‘最初的标题’， changeFatherProps 被子组件中的点击事件触发从而执行父组件中的clickChange方法，完成对标题的修改 --&gt;
            &lt;son title={ this.state.title } changeFatherProps={ this.clickChange } /&gt;
        )
    }
}
</code></pre>
<pre><code>&lt;!-- 子组件 --&gt;
import React from 'react'

export defaul{t class Father React.Component {
    changeFather = () =&gt; {
        &lt;!-- 通过 this.props 的方式 --&gt;
        this.prpos.changFatherProps()
    }
    render()  {
        return &lt;div&gt;
                    父子组件传参
                    &lt;!-- 点击button事件会触发父组件中方法的执行，将标题修改 --&gt;
                    &lt;button onClick={ this.changeFather }&gt;点击传参修改&lt;button&gt;
                &lt;/div&gt;
    }
}
</code></pre>
<h2 id="state-状态">state 状态</h2>
<pre><code>&lt;!-- 通过this.state定义保存数据和状态 --&gt;
    this.state = {
        flag: true,
        count: 10,
    }
    &lt;!-- 需要修改状态值的时候通过 this.setState({})的方式进行修改 --&gt;
    this.setState({
        flag:  false,
        count: this.state.count ++
    })
</code></pre>
<h2 id="生命周期函数">生命周期函数</h2>
<p>随着我们对React理解和使用的原来越多，生命周期会越来越有参考价值<br>
生命周期函数包括:</p>
<ol>
<li>componentWillMount:  在组件创建之前执行</li>
<li>componentDidMount: 在组件渲染之后执行</li>
<li>shouldComponentUpdata: 返回 true 和 false, true代表允许改变， false代表不允许改变</li>
<li>componentWillUpdata: 数据在改变之前执行（state, props）</li>
<li>conponentDidUpdata: 代表数据修改完成（state, props）</li>
<li>conponentWillReveiceProps: props发生改变时执行的生命周期函数</li>
<li>conponentWillUnMount: 组件卸载前执行</li>
</ol>
<h2 id="探讨关于-setstate-更新是同步操作还是异步操作的问题">探讨关于 setState 更新是同步操作还是异步操作的问题</h2>
<pre><code>setState会引起视图的重绘
官方文档解答:在可控的情况下是异步的，在不可控的情况下是同步的
</code></pre>
<h2 id="create-react-app-按需加载antd-组件">create-react-app 按需加载Antd 组件</h2>
<ol>
<li>命令行输入 cnpm run eject  拉取React的配置文件</li>
<li>文件被修改时，会抛出异常，由于GIt的原因导致,此时找到文件目录，按下shift + command + . 显示隐藏文件，删除 .git 文件，重新 cnpm run eject即可，安装完成后目录多出了两个文件，分别是config和script文件，config文件就是webpack配置文件</li>
<li>安装一个依赖文件 cnpm install babel-plugin-import --save-dev</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记个人博客之旅]]></title>
        <id>https://qinyu312.github.io/post/ji-yi-ci-bu-tong-xun-chang-de-ge-ren-blog-da-jian/</id>
        <link href="https://qinyu312.github.io/post/ji-yi-ci-bu-tong-xun-chang-de-ge-ren-blog-da-jian/">
        </link>
        <updated>2020-11-15T12:29:35.000Z</updated>
        <content type="html"><![CDATA[<pre><code>前端开发小菜🐦，借助Gridea平台搭建属于自己的个人博客正式通🚗，🎉🎉🎉🎉🎉🎉🎉🎉🎉  
在这里，我将不定时分享不定时内容，更多的是对工作👨🏻‍🔧 技术👨🏻‍💻 生活🚶🏻等方面的积累收获与感悟，期待与你共同进步！
</code></pre>
<p><img src="https://w.wallhaven.cc/full/5w/wallhaven-5w26x1.jpg" alt="avatar" loading="lazy"><br>
饮水思源，第一次写博客的内容就决定是分享Gridea + Github快速搭建个人博客类网站！</p>
<h2 id="安装gridea">安装Gridea</h2>
<p>首先需要安装Gridea客户端，附官网地址 <a href="https://gridea.dev/">Gridea</a><br>
因为只满足于日常个人写作轻量级使用，所以选择使用最简单的Github Pages部署，这边就不详细讲解域名，服务器，备案等等配置，感兴趣的建议参考这位大佬的博客观看学习<a href="https://aoizz.com/post/sha-gua-shi-cong-wu-dao-you-jian-li-yi-ge-bo-ke/">https://aoizz.com</a></p>
<figure data-type="image" tabindex="1"><img src="https://qinyu312.github.io/post-images/1605677874498.png" alt="" loading="lazy"></figure>
<h2 id="创建git仓库">创建git仓库</h2>
<p>Gridea安装完成后，登录Github，创建一个空白仓库，用于存储个人博客内容。</p>
<figure data-type="image" tabindex="2"><img src="https://qinyu312.github.io/post-images/1605680193617.png" alt="" loading="lazy"></figure>
<h2 id="配置gridea">配置Gridea</h2>
<p>打开Gridea客户端，在远程菜单中，对Github Pages进行配置如下，平台选择Github Pages，如果需要使用自己的服务器和域名也可以选择SFTP，这里不做赘述，域名直接填写之前创建的Github空白仓库的地址即可，仓库名称同上，分支，仓库用户名，邮箱几项按自己的填写即可，<a href="https://github.com/settings/tokens/new">令牌创建地址</a> 创建完成的令牌复制到令牌选项框。CNAME处填写自己的仓库名称。至此，Gridea中的Github Pages配置基本完成，点击保存和同步后，就可以输入你的域名进行访问了！</p>
<figure data-type="image" tabindex="3"><img src="https://qinyu312.github.io/post-images/1605681597177.png" alt="" loading="lazy"></figure>
<h2 id="芜湖起飞">芜湖！起飞</h2>
<p>更加贴心的是， Gridea还为广大个人博主提供了各种风格迥异的博客模版，可以让大家更加专注于写出高质量博客，而不用过于关注样式布局方面的问题。当然，如果你追求极致和个性化，也可以自己定制你的博客。<a href="https://gridea.dev/themes/">更多主题</a></p>
<figure data-type="image" tabindex="4"><img src="https://qinyu312.github.io/post-images/1605682923167.png" alt="" loading="lazy"></figure>
<h2 id="使用主题">使用主题</h2>
<p>进入官网下载主题到本地，然后解压后将文件放到Gridea所在的本地地址路径下的themes文件夹下</p>
<figure data-type="image" tabindex="5"><img src="https://qinyu312.github.io/post-images/1605683290929.png" alt="" loading="lazy"></figure>
<p>然后在Gridea客户端的主题菜单里就可以看到你下载的新主题啦。选中后即可同步预览效果！</p>
<figure data-type="image" tabindex="6"><img src="https://qinyu312.github.io/post-images/1605683207314.png" alt="" loading="lazy"></figure>
<p>那关于个人博客的简单搭建就介绍完了，有兴趣的小伙伴可以动手尝试一下，期待你们精美的博客和优质的作品！</p>
<p>ヽ｀、ヽ｀｀、ヽ｀ヽ｀、、ヽ ｀ヽ 、ヽ｀🌙｀ヽヽ｀ヽ、ヽ｀ヽ｀、ヽ｀｀、ヽ 、｀｀、 ｀、ヽ｀ 、｀ ヽ｀ヽ、ヽ ｀、ヽ｀｀、ヽ、｀｀、｀、ヽ｀｀、 、ヽヽ｀、｀、、ヽヽ、｀｀、 、 ヽ｀、ヽ｀｀、ヽ｀ヽ｀、、ヽ ｀ヽ 、ヽ｀｀ヽ、｀🏡｀ヽ｀、、🚶｀ヽ｀、</p>
]]></content>
    </entry>
</feed>