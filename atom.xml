<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://qinyu312.github.io</id>
    <title>҉҉҈淸鷠҉҉҈、</title>
    <updated>2021-02-08T03:03:44.021Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://qinyu312.github.io"/>
    <link rel="self" href="https://qinyu312.github.io/atom.xml"/>
    <subtitle>万般皆苦，唯有自渡</subtitle>
    <logo>https://qinyu312.github.io/images/avatar.png</logo>
    <icon>https://qinyu312.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, ҉҉҈淸鷠҉҉҈、</rights>
    <entry>
        <title type="html"><![CDATA[2.5基金日报]]></title>
        <id>https://qinyu312.github.io/post/25-ji-jin-ri-bao/</id>
        <link href="https://qinyu312.github.io/post/25-ji-jin-ri-bao/">
        </link>
        <updated>2021-02-05T07:07:52.000Z</updated>
        <content type="html"><![CDATA[<p>最近几天新能源和军工又又又被锤肿了，可能受春运回家核酸检测和疫苗接种的影响，医药最近几天走势大好，月初几天美股游戏驿站事件，A股也是一片哀嚎一片绿，但是白酒却逆势上扬，让我想起一句话，白酒生，万物死。今天新能源和军工大跌，理性加一些仓位，个人觉得新能源是长期利好，也是未来的发展趋势，军工在今年的十四五规划中也有望大放异彩，医药方面，由于人口老龄化加速及医疗水平提高，可作为长期投资，半导体5G方面谨慎上车，有色金属可适当上车。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AES加密前端操作]]></title>
        <id>https://qinyu312.github.io/post/jia-mi-cao-zuo/</id>
        <link href="https://qinyu312.github.io/post/jia-mi-cao-zuo/">
        </link>
        <updated>2021-02-04T09:12:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="aes前端加密">aes前端加密</h1>
<p>最近在开发微信小程序，由于是国企项目，上线前都需要做好几次安全漏洞扫描，所以数据接口都需要二次封装并进行加解密的操作来确保安全性，最后和后端同事商议，使用aes进行加密，原理是前端请求的后端接口，除统一域名前缀部分外，后面接口部分全部使用公共参数 例如common 进行替换，然后将接口名称，接口所需参数等信息，通过 aes 加密后传输给后端，后端拿到加密后的字符串，通过解密算法得到接口名称及参数，来调用对用的接口，然后将返回值同样经过加密后返回给前端，前端拿到加密串后解密，得到JSON对象，转换后得到接口数据进行页面渲染。</p>
<p>具体操作如下：</p>
<ol>
<li>将加解密方法操作封装在 public.js 和 aes.js 两个文件中</li>
</ol>
<pre><code>&lt;!-- public.js --&gt;

var CryptoJS = require('./aes.js'); //引用AES源码js
var key = CryptoJS.enc.Utf8.parse(&quot;richeninfo202121&quot;); //十六位十六进制数作为秘钥
var iv = CryptoJS.enc.Utf8.parse('richeninfo202121');//十六位十六进制数作为秘钥偏移量
//解密方法
function Decrypt(word) {
    var encryptedHexStr = CryptoJS.enc.Hex.parse(word);
    var srcs = CryptoJS.enc.Base64.stringify(encryptedHexStr);
    var decrypt = CryptoJS.AES.decrypt(srcs, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    var decryptedStr = decrypt.toString(CryptoJS.enc.Utf8);
    return decryptedStr.toString();
}
//加密方法
function Encrypt(word) {
    var srcs = CryptoJS.enc.Utf8.parse(word);
    var encrypted = CryptoJS.AES.encrypt(srcs, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    return encrypted.ciphertext.toString().toUpperCase();
}
 
//暴露接口
module.exports.Decrypt = Decrypt;
module.exports.Encrypt = Encrypt;
</code></pre>
<pre><code>&lt;!-- aes.js --&gt;
/**
 * [description] CryptoJS v3.1.2 
 * [description] zhuangzhudada sort out 
 */
var CryptoJS = CryptoJS || function(u, p) {
  var d = {},
      l = d.lib = {},
      s = function() {},
      t = l.Base = {
          extend: function(a) {
              s.prototype = this;
              var c = new s;
              a &amp;&amp; c.mixIn(a);
              c.hasOwnProperty(&quot;init&quot;) || (c.init = function() {
                  c.$super.init.apply(this, arguments)
              });
              c.init.prototype = c;
              c.$super = this;
              return c
          },
          create: function() {
              var a = this.extend();
              a.init.apply(a, arguments);
              return a
          },
          init: function() {},
          mixIn: function(a) {
              for (var c in a) a.hasOwnProperty(c) &amp;&amp; (this[c] = a[c]);
              a.hasOwnProperty(&quot;toString&quot;) &amp;&amp; (this.toString = a.toString)
          },
          clone: function() {
              return this.init.prototype.extend(this)
          }
      },
      r = l.WordArray = t.extend({
          init: function(a, c) {
              a = this.words = a || [];
              this.sigBytes = c != p ? c : 4 * a.length
          },
          toString: function(a) {
              return (a || v).stringify(this)
          },
          concat: function(a) {
              var c = this.words,
                  e = a.words,
                  j = this.sigBytes;
              a = a.sigBytes;
              this.clamp();
              if (j % 4)
                  for (var k = 0; k &lt; a; k++) c[j + k &gt;&gt;&gt; 2] |= (e[k &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (k % 4) &amp; 255) &lt;&lt; 24 - 8 * ((j + k) % 4);
              else if (65535 &lt; e.length)
                  for (k = 0; k &lt; a; k += 4) c[j + k &gt;&gt;&gt; 2] = e[k &gt;&gt;&gt; 2];
              else c.push.apply(c, e);
              this.sigBytes += a;
              return this
          },
          clamp: function() {
              var a = this.words,
                  c = this.sigBytes;
              a[c &gt;&gt;&gt; 2] &amp;= 4294967295 &lt;&lt;
- 8 * (c % 4);
              a.length = u.ceil(c / 4)
          },
          clone: function() {
              var a = t.clone.call(this);
              a.words = this.words.slice(0);
              return a
          },
          random: function(a) {
              for (var c = [], e = 0; e &lt; a; e += 4) c.push(4294967296 * u.random() | 0);
              return new r.init(c, a)
          }
      }),
      w = d.enc = {},
      v = w.Hex = {
          stringify: function(a) {
              var c = a.words;
              a = a.sigBytes;
              for (var e = [], j = 0; j &lt; a; j++) {
                  var k = c[j &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (j % 4) &amp; 255;
                  e.push((k &gt;&gt;&gt; 4).toString(16));
                  e.push((k &amp; 15).toString(16))
              }
              return e.join(&quot;&quot;)
          },
          parse: function(a) {
              for (var c = a.length, e = [], j = 0; j &lt; c; j += 2) e[j &gt;&gt;&gt; 3] |= parseInt(a.substr(j,
                  2), 16) &lt;&lt; 24 - 4 * (j % 8);
              return new r.init(e, c / 2)
          }
      },
      b = w.Latin1 = {
          stringify: function(a) {
              var c = a.words;
              a = a.sigBytes;
              for (var e = [], j = 0; j &lt; a; j++) e.push(String.fromCharCode(c[j &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (j % 4) &amp; 255));
              return e.join(&quot;&quot;)
          },
          parse: function(a) {
              for (var c = a.length, e = [], j = 0; j &lt; c; j++) e[j &gt;&gt;&gt; 2] |= (a.charCodeAt(j) &amp; 255) &lt;&lt; 24 - 8 * (j % 4);
              return new r.init(e, c)
          }
      },
      x = w.Utf8 = {
          stringify: function(a) {
              try {
                  return decodeURIComponent(escape(b.stringify(a)))
              } catch (c) {
                  throw Error(&quot;Malformed UTF-8 data&quot;);
              }
          },
          parse: function(a) {
              return b.parse(unescape(encodeURIComponent(a)))
          }
      },
      q = l.BufferedBlockAlgorithm = t.extend({
          reset: function() {
              this._data = new r.init;
              this._nDataBytes = 0
          },
          _append: function(a) {
              &quot;string&quot; == typeof a &amp;&amp; (a = x.parse(a));
              this._data.concat(a);
              this._nDataBytes += a.sigBytes
          },
          _process: function(a) {
              var c = this._data,
                  e = c.words,
                  j = c.sigBytes,
                  k = this.blockSize,
                  b = j / (4 * k),
                  b = a ? u.ceil(b) : u.max((b | 0) - this._minBufferSize, 0);
              a = b * k;
              j = u.min(4 * a, j);
              if (a) {
                  for (var q = 0; q &lt; a; q += k) this._doProcessBlock(e, q);
                  q = e.splice(0, a);
                  c.sigBytes -= j
              }
              return new r.init(q, j)
          },
          clone: function() {
              var a = t.clone.call(this);
              a._data = this._data.clone();
              return a
          },
          _minBufferSize: 0
      });
  l.Hasher = q.extend({
      cfg: t.extend(),
      init: function(a) {
          this.cfg = this.cfg.extend(a);
          this.reset()
      },
      reset: function() {
          q.reset.call(this);
          this._doReset()
      },
      update: function(a) {
          this._append(a);
          this._process();
          return this
      },
      finalize: function(a) {
          a &amp;&amp; this._append(a);
          return this._doFinalize()
      },
      blockSize: 16,
      _createHelper: function(a) {
          return function(b, e) {
              return (new a.init(e)).finalize(b)
          }
      },
      _createHmacHelper: function(a) {
          return function(b, e) {
              return (new n.HMAC.init(a,
                  e)).finalize(b)
          }
      }
  });
  var n = d.algo = {};
  return d
}(Math);
(function() {
  var u = CryptoJS,
      p = u.lib.WordArray;
  u.enc.Base64 = {
      stringify: function(d) {
          var l = d.words,
              p = d.sigBytes,
              t = this._map;
          d.clamp();
          d = [];
          for (var r = 0; r &lt; p; r += 3)
              for (var w = (l[r &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (r % 4) &amp; 255) &lt;&lt; 16 | (l[r + 1 &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * ((r + 1) % 4) &amp; 255) &lt;&lt; 8 | l[r + 2 &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * ((r + 2) % 4) &amp; 255, v = 0; 4 &gt; v &amp;&amp; r + 0.75 * v &lt; p; v++) d.push(t.charAt(w &gt;&gt;&gt; 6 * (3 - v) &amp; 63));
          if (l = t.charAt(64))
              for (; d.length % 4;) d.push(l);
          return d.join(&quot;&quot;)
      },
      parse: function(d) {
          var l = d.length,
              s = this._map,
              t = s.charAt(64);
          t &amp;&amp; (t = d.indexOf(t), -1 != t &amp;&amp; (l = t));
          for (var t = [], r = 0, w = 0; w &lt;
              l; w++)
              if (w % 4) {
                  var v = s.indexOf(d.charAt(w - 1)) &lt;&lt; 2 * (w % 4),
                      b = s.indexOf(d.charAt(w)) &gt;&gt;&gt; 6 - 2 * (w % 4);
                  t[r &gt;&gt;&gt; 2] |= (v | b) &lt;&lt; 24 - 8 * (r % 4);
                  r++
              }
          return p.create(t, r)
      },
      _map: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;
  }
})();
(function(u) {
  function p(b, n, a, c, e, j, k) {
      b = b + (n &amp; a | ~n &amp; c) + e + k;
      return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n
  }

  function d(b, n, a, c, e, j, k) {
      b = b + (n &amp; c | a &amp; ~c) + e + k;
      return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n
  }

  function l(b, n, a, c, e, j, k) {
      b = b + (n ^ a ^ c) + e + k;
      return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n
  }

  function s(b, n, a, c, e, j, k) {
      b = b + (a ^ (n | ~c)) + e + k;
      return (b &lt;&lt; j | b &gt;&gt;&gt; 32 - j) + n
  }
  for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 &gt; x; x++) b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0;
  r = r.MD5 = v.extend({
      _doReset: function() {
          this._hash = new w.init([1732584193, 4023233417, 2562383102, 271733878])
      },
      _doProcessBlock: function(q, n) {
          for (var a = 0; 16 &gt; a; a++) {
              var c = n + a,
                  e = q[c];
              q[c] = (e &lt;&lt; 8 | e &gt;&gt;&gt; 24) &amp; 16711935 | (e &lt;&lt; 24 | e &gt;&gt;&gt; 8) &amp; 4278255360
          }
          var a = this._hash.words,
              c = q[n + 0],
              e = q[n + 1],
              j = q[n + 2],
              k = q[n + 3],
              z = q[n + 4],
              r = q[n + 5],
              t = q[n + 6],
              w = q[n + 7],
              v = q[n + 8],
              A = q[n + 9],
              B = q[n + 10],
              C = q[n + 11],
              u = q[n + 12],
              D = q[n + 13],
              E = q[n + 14],
              x = q[n + 15],
              f = a[0],
              m = a[1],
              g = a[2],
              h = a[3],
              f = p(f, m, g, h, c, 7, b[0]),
              h = p(h, f, m, g, e, 12, b[1]),
              g = p(g, h, f, m, j, 17, b[2]),
              m = p(m, g, h, f, k, 22, b[3]),
              f = p(f, m, g, h, z, 7, b[4]),
              h = p(h, f, m, g, r, 12, b[5]),
              g = p(g, h, f, m, t, 17, b[6]),
              m = p(m, g, h, f, w, 22, b[7]),
              f = p(f, m, g, h, v, 7, b[8]),
              h = p(h, f, m, g, A, 12, b[9]),
              g = p(g, h, f, m, B, 17, b[10]),
              m = p(m, g, h, f, C, 22, b[11]),
              f = p(f, m, g, h, u, 7, b[12]),
              h = p(h, f, m, g, D, 12, b[13]),
              g = p(g, h, f, m, E, 17, b[14]),
              m = p(m, g, h, f, x, 22, b[15]),
              f = d(f, m, g, h, e, 5, b[16]),
              h = d(h, f, m, g, t, 9, b[17]),
              g = d(g, h, f, m, C, 14, b[18]),
              m = d(m, g, h, f, c, 20, b[19]),
              f = d(f, m, g, h, r, 5, b[20]),
              h = d(h, f, m, g, B, 9, b[21]),
              g = d(g, h, f, m, x, 14, b[22]),
              m = d(m, g, h, f, z, 20, b[23]),
              f = d(f, m, g, h, A, 5, b[24]),
              h = d(h, f, m, g, E, 9, b[25]),
              g = d(g, h, f, m, k, 14, b[26]),
              m = d(m, g, h, f, v, 20, b[27]),
              f = d(f, m, g, h, D, 5, b[28]),
              h = d(h, f,
                  m, g, j, 9, b[29]),
              g = d(g, h, f, m, w, 14, b[30]),
              m = d(m, g, h, f, u, 20, b[31]),
              f = l(f, m, g, h, r, 4, b[32]),
              h = l(h, f, m, g, v, 11, b[33]),
              g = l(g, h, f, m, C, 16, b[34]),
              m = l(m, g, h, f, E, 23, b[35]),
              f = l(f, m, g, h, e, 4, b[36]),
              h = l(h, f, m, g, z, 11, b[37]),
              g = l(g, h, f, m, w, 16, b[38]),
              m = l(m, g, h, f, B, 23, b[39]),
              f = l(f, m, g, h, D, 4, b[40]),
              h = l(h, f, m, g, c, 11, b[41]),
              g = l(g, h, f, m, k, 16, b[42]),
              m = l(m, g, h, f, t, 23, b[43]),
              f = l(f, m, g, h, A, 4, b[44]),
              h = l(h, f, m, g, u, 11, b[45]),
              g = l(g, h, f, m, x, 16, b[46]),
              m = l(m, g, h, f, j, 23, b[47]),
              f = s(f, m, g, h, c, 6, b[48]),
              h = s(h, f, m, g, w, 10, b[49]),
              g = s(g, h, f, m,
                  E, 15, b[50]),
              m = s(m, g, h, f, r, 21, b[51]),
              f = s(f, m, g, h, u, 6, b[52]),
              h = s(h, f, m, g, k, 10, b[53]),
              g = s(g, h, f, m, B, 15, b[54]),
              m = s(m, g, h, f, e, 21, b[55]),
              f = s(f, m, g, h, v, 6, b[56]),
              h = s(h, f, m, g, x, 10, b[57]),
              g = s(g, h, f, m, t, 15, b[58]),
              m = s(m, g, h, f, D, 21, b[59]),
              f = s(f, m, g, h, z, 6, b[60]),
              h = s(h, f, m, g, C, 10, b[61]),
              g = s(g, h, f, m, j, 15, b[62]),
              m = s(m, g, h, f, A, 21, b[63]);
          a[0] = a[0] + f | 0;
          a[1] = a[1] + m | 0;
          a[2] = a[2] + g | 0;
          a[3] = a[3] + h | 0
      },
      _doFinalize: function() {
          var b = this._data,
              n = b.words,
              a = 8 * this._nDataBytes,
              c = 8 * b.sigBytes;
          n[c &gt;&gt;&gt; 5] |= 128 &lt;&lt; 24 - c % 32;
          var e = u.floor(a /
              4294967296);
          n[(c + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 15] = (e &lt;&lt; 8 | e &gt;&gt;&gt; 24) &amp; 16711935 | (e &lt;&lt; 24 | e &gt;&gt;&gt; 8) &amp; 4278255360;
          n[(c + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 14] = (a &lt;&lt; 8 | a &gt;&gt;&gt; 24) &amp; 16711935 | (a &lt;&lt; 24 | a &gt;&gt;&gt; 8) &amp; 4278255360;
          b.sigBytes = 4 * (n.length + 1);
          this._process();
          b = this._hash;
          n = b.words;
          for (a = 0; 4 &gt; a; a++) c = n[a], n[a] = (c &lt;&lt; 8 | c &gt;&gt;&gt; 24) &amp; 16711935 | (c &lt;&lt; 24 | c &gt;&gt;&gt; 8) &amp; 4278255360;
          return b
      },
      clone: function() {
          var b = v.clone.call(this);
          b._hash = this._hash.clone();
          return b
      }
  });
  t.MD5 = v._createHelper(r);
  t.HmacMD5 = v._createHmacHelper(r)
})(Math);
(function() {
  var u = CryptoJS,
      p = u.lib,
      d = p.Base,
      l = p.WordArray,
      p = u.algo,
      s = p.EvpKDF = d.extend({
          cfg: d.extend({
              keySize: 4,
              hasher: p.MD5,
              iterations: 1
          }),
          init: function(d) {
              this.cfg = this.cfg.extend(d)
          },
          compute: function(d, r) {
              for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length &lt; q;) {
                  n &amp;&amp; s.update(n);
                  var n = s.update(d).finalize(r);
                  s.reset();
                  for (var a = 1; a &lt; p; a++) n = s.finalize(n), s.reset();
                  b.concat(n)
              }
              b.sigBytes = 4 * q;
              return b
          }
      });
  u.EvpKDF = function(d, l, p) {
      return s.create(p).compute(d,
          l)
  }
})();
CryptoJS.lib.Cipher || function(u) {
  var p = CryptoJS,
      d = p.lib,
      l = d.Base,
      s = d.WordArray,
      t = d.BufferedBlockAlgorithm,
      r = p.enc.Base64,
      w = p.algo.EvpKDF,
      v = d.Cipher = t.extend({
          cfg: l.extend(),
          createEncryptor: function(e, a) {
              return this.create(this._ENC_XFORM_MODE, e, a)
          },
          createDecryptor: function(e, a) {
              return this.create(this._DEC_XFORM_MODE, e, a)
          },
          init: function(e, a, b) {
              this.cfg = this.cfg.extend(b);
              this._xformMode = e;
              this._key = a;
              this.reset()
          },
          reset: function() {
              t.reset.call(this);
              this._doReset()
          },
          process: function(e) {
              this._append(e);
              return this._process()
          },
          finalize: function(e) {
              e &amp;&amp; this._append(e);
              return this._doFinalize()
          },
          keySize: 4,
          ivSize: 4,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function(e) {
              return {
                  encrypt: function(b, k, d) {
                      return (&quot;string&quot; == typeof k ? c : a).encrypt(e, b, k, d)
                  },
                  decrypt: function(b, k, d) {
                      return (&quot;string&quot; == typeof k ? c : a).decrypt(e, b, k, d)
                  }
              }
          }
      });
  d.StreamCipher = v.extend({
      _doFinalize: function() {
          return this._process(!0)
      },
      blockSize: 1
  });
  var b = p.mode = {},
      x = function(e, a, b) {
          var c = this._iv;
          c ? this._iv = u : c = this._prevBlock;
          for (var d = 0; d &lt; b; d++) e[a + d] ^=
              c[d]
      },
      q = (d.BlockCipherMode = l.extend({
          createEncryptor: function(e, a) {
              return this.Encryptor.create(e, a)
          },
          createDecryptor: function(e, a) {
              return this.Decryptor.create(e, a)
          },
          init: function(e, a) {
              this._cipher = e;
              this._iv = a
          }
      })).extend();
  q.Encryptor = q.extend({
      processBlock: function(e, a) {
          var b = this._cipher,
              c = b.blockSize;
          x.call(this, e, a, c);
          b.encryptBlock(e, a);
          this._prevBlock = e.slice(a, a + c)
      }
  });
  q.Decryptor = q.extend({
      processBlock: function(e, a) {
          var b = this._cipher,
              c = b.blockSize,
              d = e.slice(a, a + c);
          b.decryptBlock(e, a);
          x.call(this,
              e, a, c);
          this._prevBlock = d
      }
  });
  b = b.CBC = q;
  q = (p.pad = {}).Pkcs7 = {
      pad: function(a, b) {
          for (var c = 4 * b, c = c - a.sigBytes % c, d = c &lt;&lt; 24 | c &lt;&lt; 16 | c &lt;&lt; 8 | c, l = [], n = 0; n &lt; c; n += 4) l.push(d);
          c = s.create(l, c);
          a.concat(c)
      },
      unpad: function(a) {
          a.sigBytes -= a.words[a.sigBytes - 1 &gt;&gt;&gt; 2] &amp; 255
      }
  };
  d.BlockCipher = v.extend({
      cfg: v.cfg.extend({
          mode: b,
          padding: q
      }),
      reset: function() {
          v.reset.call(this);
          var a = this.cfg,
              b = a.iv,
              a = a.mode;
          if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;
          else c = a.createDecryptor, this._minBufferSize = 1;
          this._mode = c.call(a,
              this, b &amp;&amp; b.words)
      },
      _doProcessBlock: function(a, b) {
          this._mode.processBlock(a, b)
      },
      _doFinalize: function() {
          var a = this.cfg.padding;
          if (this._xformMode == this._ENC_XFORM_MODE) {
              a.pad(this._data, this.blockSize);
              var b = this._process(!0)
          } else b = this._process(!0), a.unpad(b);
          return b
      },
      blockSize: 4
  });
  var n = d.CipherParams = l.extend({
          init: function(a) {
              this.mixIn(a)
          },
          toString: function(a) {
              return (a || this.formatter).stringify(this)
          }
      }),
      b = (p.format = {}).OpenSSL = {
          stringify: function(a) {
              var b = a.ciphertext;
              a = a.salt;
              return (a ? s.create([1398893684,
              ]).concat(a).concat(b) : b).toString(r)
          },
          parse: function(a) {
              a = r.parse(a);
              var b = a.words;
              if (1398893684 == b[0] &amp;&amp; 1701076831 == b[1]) {
                  var c = s.create(b.slice(2, 4));
                  b.splice(0, 4);
                  a.sigBytes -= 16
              }
              return n.create({
                  ciphertext: a,
                  salt: c
              })
          }
      },
      a = d.SerializableCipher = l.extend({
          cfg: l.extend({
              format: b
          }),
          encrypt: function(a, b, c, d) {
              d = this.cfg.extend(d);
              var l = a.createEncryptor(c, d);
              b = l.finalize(b);
              l = l.cfg;
              return n.create({
                  ciphertext: b,
                  key: c,
                  iv: l.iv,
                  algorithm: a,
                  mode: l.mode,
                  padding: l.padding,
                  blockSize: a.blockSize,
                  formatter: d.format
              })
          },
          decrypt: function(a, b, c, d) {
              d = this.cfg.extend(d);
              b = this._parse(b, d.format);
              return a.createDecryptor(c, d).finalize(b.ciphertext)
          },
          _parse: function(a, b) {
              return &quot;string&quot; == typeof a ? b.parse(a, this) : a
          }
      }),
      p = (p.kdf = {}).OpenSSL = {
          execute: function(a, b, c, d) {
              d || (d = s.random(8));
              a = w.create({
                  keySize: b + c
              }).compute(a, d);
              c = s.create(a.words.slice(b), 4 * c);
              a.sigBytes = 4 * b;
              return n.create({
                  key: a,
                  iv: c,
                  salt: d
              })
          }
      },
      c = d.PasswordBasedCipher = a.extend({
          cfg: a.cfg.extend({
              kdf: p
          }),
          encrypt: function(b, c, d, l) {
              l = this.cfg.extend(l);
              d = l.kdf.execute(d,
                  b.keySize, b.ivSize);
              l.iv = d.iv;
              b = a.encrypt.call(this, b, c, d.key, l);
              b.mixIn(d);
              return b
          },
          decrypt: function(b, c, d, l) {
              l = this.cfg.extend(l);
              c = this._parse(c, l.format);
              d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt);
              l.iv = d.iv;
              return a.decrypt.call(this, b, c, d.key, l)
          }
      })
}();
(function() {
  for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 &gt; c; c++) a[c] = 128 &gt; c ? c &lt;&lt; 1 : c &lt;&lt; 1 ^ 283;
  for (var e = 0, j = 0, c = 0; 256 &gt; c; c++) {
      var k = j ^ j &lt;&lt; 1 ^ j &lt;&lt; 2 ^ j &lt;&lt; 3 ^ j &lt;&lt; 4,
          k = k &gt;&gt;&gt; 8 ^ k &amp; 255 ^ 99;
      l[e] = k;
      s[k] = e;
      var z = a[e],
          F = a[z],
          G = a[F],
          y = 257 * a[k] ^ 16843008 * k;
      t[e] = y &lt;&lt; 24 | y &gt;&gt;&gt; 8;
      r[e] = y &lt;&lt; 16 | y &gt;&gt;&gt; 16;
      w[e] = y &lt;&lt; 8 | y &gt;&gt;&gt; 24;
      v[e] = y;
      y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e;
      b[k] = y &lt;&lt; 24 | y &gt;&gt;&gt; 8;
      x[k] = y &lt;&lt; 16 | y &gt;&gt;&gt; 16;
      q[k] = y &lt;&lt; 8 | y &gt;&gt;&gt; 24;
      n[k] = y;
      e ? (e = z ^ a[a[a[G ^ z]]], j ^= a[a[j]]) : e = j = 1
  }
  var H = [0, 1, 2, 4, 8,
          16, 32, 64, 128, 27, 54
      ],
      d = d.AES = p.extend({
          _doReset: function() {
              for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; j &lt; a; j++)
                  if (j &lt; d) e[j] = c[j];
                  else {
                      var k = e[j - 1];
                      j % d ? 6 &lt; d &amp;&amp; 4 == j % d &amp;&amp; (k = l[k &gt;&gt;&gt; 24] &lt;&lt; 24 | l[k &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | l[k &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | l[k &amp; 255]) : (k = k &lt;&lt; 8 | k &gt;&gt;&gt; 24, k = l[k &gt;&gt;&gt; 24] &lt;&lt; 24 | l[k &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | l[k &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | l[k &amp; 255], k ^= H[j / d | 0] &lt;&lt; 24);
                      e[j] = e[j - d] ^ k
                  }
              c = this._invKeySchedule = [];
              for (d = 0; d &lt; a; d++) j = a - d, k = d % 4 ? e[j] : e[j - 4], c[d] = 4 &gt; d || 4 &gt;= j ? k : b[l[k &gt;&gt;&gt; 24]] ^ x[l[k &gt;&gt;&gt; 16 &amp; 255]] ^ q[l[k &gt;&gt;&gt; 8 &amp; 255]] ^ n[l[k &amp; 255]]
          },
          encryptBlock: function(a, b) {
              this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l)
          },
          decryptBlock: function(a, c) {
              var d = a[c + 1];
              a[c + 1] = a[c + 3];
              a[c + 3] = d;
              this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s);
              d = a[c + 1];
              a[c + 1] = a[c + 3];
              a[c + 3] = d
          },
          _doCryptBlock: function(a, b, c, d, e, j, l, f) {
              for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; r &lt; m; r++) var q = d[g &gt;&gt;&gt; 24] ^ e[h &gt;&gt;&gt; 16 &amp; 255] ^ j[k &gt;&gt;&gt; 8 &amp; 255] ^ l[n &amp; 255] ^ c[p++],
                  s = d[h &gt;&gt;&gt; 24] ^ e[k &gt;&gt;&gt; 16 &amp; 255] ^ j[n &gt;&gt;&gt; 8 &amp; 255] ^ l[g &amp; 255] ^ c[p++],
                  t =
                  d[k &gt;&gt;&gt; 24] ^ e[n &gt;&gt;&gt; 16 &amp; 255] ^ j[g &gt;&gt;&gt; 8 &amp; 255] ^ l[h &amp; 255] ^ c[p++],
                  n = d[n &gt;&gt;&gt; 24] ^ e[g &gt;&gt;&gt; 16 &amp; 255] ^ j[h &gt;&gt;&gt; 8 &amp; 255] ^ l[k &amp; 255] ^ c[p++],
                  g = q,
                  h = s,
                  k = t;
              q = (f[g &gt;&gt;&gt; 24] &lt;&lt; 24 | f[h &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[k &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[n &amp; 255]) ^ c[p++];
              s = (f[h &gt;&gt;&gt; 24] &lt;&lt; 24 | f[k &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[n &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[g &amp; 255]) ^ c[p++];
              t = (f[k &gt;&gt;&gt; 24] &lt;&lt; 24 | f[n &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[g &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[h &amp; 255]) ^ c[p++];
              n = (f[n &gt;&gt;&gt; 24] &lt;&lt; 24 | f[g &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | f[h &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | f[k &amp; 255]) ^ c[p++];
              a[b] = q;
              a[b + 1] = s;
              a[b + 2] = t;
              a[b + 3] = n
          },
          keySize: 8
      });
  u.AES = p._createHelper(d)
})();

module.exports = CryptoJS
</code></pre>
<ol start="2">
<li>需要使用加密操作的接口文件中，引入已经封装加解密方法进行接口的加解密操作</li>
</ol>
<pre><code>&lt;!-- 引入方法 --&gt;
const CryptoJS = require('./utils/public');

&lt;!-- 拼接需要调用的接口名称和所需的参数信息 --&gt;
var data = '{&quot;url&quot;: &quot;/login/sendSMS&quot;, &quot;openid&quot;: &quot;'+ wx.getStorageSync('openid') +'&quot;, &quot;userName&quot;: &quot;'+ this.data.oaName +'&quot;, &quot;userMobile&quot;: &quot;'+ this.data.tel +'&quot;}';
&lt;!-- 使用CryptoJS.Encryp将拼接的信息进行加密，得到密文字符串 --&gt;
      var encrypt = CryptoJS.Encrypt(data)
&lt;!-- 此处微信小程序为例，请求调用 --&gt;
      request({ 
&lt;!-- url处填写和后端协商好的固定接口地址，接口的二次封装 --&gt;
        url: 'http://localhost:8080/miniprogram-union/common',
&lt;!-- data处传拼接和加密好的接口名称和参数信息 --&gt;
        data: encrypt,
        method: &quot;POST&quot;, 
        }).then(result =&gt; {
&lt;!--  通过CryptoJS.Decrypt解密方法解密后端传过来的返回值--&gt;
        var res = CryptoJS.Decrypt(result.data);
&lt;!-- 解密得到的值一般为 JSON 对象形式，需要转为js对象 --&gt;
        var smsInfo = JSON.parse(res)
&lt;!-- 微信小程序中将得到的数据放到data中并在页面渲染 --&gt;
        this.setData({
            smsInfoList: smsInfo.data
        })
      })   
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后端代码本地打包运行]]></title>
        <id>https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-ben-di-ce-shi-jie-kou/</id>
        <link href="https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-ben-di-ce-shi-jie-kou/">
        </link>
        <updated>2021-01-28T01:41:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="后端-string-boot">后端 string boot</h2>
<pre><code>zsh: command not found: mvn 解决命令
source ~/.bash_profile
</code></pre>
<ol>
<li>以Mac环境为例，需要先检查本地是否安装Maven</li>
</ol>
<pre><code>mvn -v  
</code></pre>
<ol start="2">
<li>安装mvn后，由于下载较慢，建议配置阿里云打包，进入maven目录下的 conf 文件下，打开settings.xml 文件，添加以下代码</li>
</ol>
<pre><code>&lt;mirrors&gt;
    &lt;mirror&gt;
      &lt;id&gt;mirrorId&lt;/id&gt;
      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;
      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;
      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;
    &lt;/mirror&gt;
     --&gt;
	 &lt;mirror&gt;
	   &lt;id&gt;nexus-aliyun&lt;/id&gt;
	   &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
	   &lt;name&gt;Nexus aliyun&lt;/name&gt;
	   &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
	 &lt;/mirror&gt;
  &lt;/mirrors&gt;
</code></pre>
<ol start="3">
<li>进入后端代码所在的项目目录下，运行打包命令</li>
</ol>
<pre><code>mvn package -DskipTests
</code></pre>
<p>停止运行命令</p>
<pre><code>mvn clean
</code></pre>
<p>运行完成命令后会在项目文件夹下得到一个target文件，target文件下的war就可以在本地 tomcat 运行了需要下载安装 Tomcat 来运行一个war包<br>
4. 将后端项目代码中已经配置好的 xxx.war 文件拷贝至 tomcat文件目录下的 webapps下<br>
<img src="https://qinyu312.github.io/post-images/1611799120504.png" alt="" loading="lazy"><br>
5. 命令行进入到 Tomcat 下的 bin 目录</p>
<p>命令行启动 startup.sh<br>
<img src="https://qinyu312.github.io/post-images/1611799131274.png" alt="" loading="lazy"><br>
<code>sudo sh ./startup.sh</code><br>
命令行结束运行<br>
<img src="https://qinyu312.github.io/post-images/1611799138646.png" alt="" loading="lazy"><br>
<code>sudo sh ./shutdown.sh</code><br>
命令行查看 Tomcat所有进程<br>
<img src="https://qinyu312.github.io/post-images/1611799147086.png" alt="" loading="lazy"><br>
<code>ps -ef|grep java</code><br>
命令行强制终止 某些 Tomcat进程<br>
<code>kill -9 端口号</code></p>
<ol start="6">
<li>startup.sh 启动后就可以在浏览器输入 localhost:8080测试 Tomcat 启动的情况</li>
<li>把接口请求处的测试地址换成 localhost:8080 调用接口测试，数据正常返回，本地调用成功</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序开发随记]]></title>
        <id>https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-kai-fa/</id>
        <link href="https://qinyu312.github.io/post/wei-xin-xiao-cheng-xu-kai-fa/">
        </link>
        <updated>2020-12-25T07:53:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="button-无法设置宽高">button 无法设置宽高</h2>
<p>当前版本的微信小程序，在.wxss文件里设置Button宽度无效,调整不会被应用到元素上</p>
<pre><code>.btn {
    width: 80%;
    height: 80rpx;
}
</code></pre>
<p>第一种方式是把 app.json里的  style: v2语句删掉。<br>
这样虽然也可以解决问题，但会导致全局的样式变化。<br>
第二种方式可以很便捷的解决问题，就是直接在 button标签的行内添加样式</p>
<pre><code>&lt;button style=&quot;width: 80%; height: 80rpx&quot;&gt;提交&lt;/button&gt;
</code></pre>
<p>按钮宽高生效</p>
<h2 id="微信小程序跳转操作">微信小程序跳转操作</h2>
<pre><code>&lt;!-- 1. 跳转到页面后左上角不会有返回角标及操作，但是不可以跳转到根级别的tab页面 --&gt;
wx.redirectTo({
    url: '/pages/oa_login/index',
})

&lt;!-- 2. 这个方法之能跳转到 app.json 里面定义的 主 tab页面，如首页，我的这种 --&gt;
wx.switchTab({
    url: '/pages/index/index',
})

&lt;!-- 3. 页面跳转且会有返回操作，但是不可以跳转到根级别的tab页面 --&gt;
wx.navigataTo({
    url: '/pages/oa_login/index',
})
</code></pre>
<h2 id="微信小程序轻提示">微信小程序轻提示</h2>
<pre><code>wx.showToast({
    title: info.message,
    icon: 'none',
    duration: 1500
})
</code></pre>
<h2 id="微信小程序获取当前经纬度定位信息">微信小程序获取当前经纬度定位信息</h2>
<!-- 在 app.json里面设置是否允许获取当前定位信息的弹窗 -->
<pre><code>{
    &quot;pages&quot;:[
        &quot;pages/index/index&quot;,
    ],
    &lt;!-- 是否允许获取定位信息 --&gt;
    &quot;permission&quot;: {
        &quot;scope.userLocation&quot;: {
        &quot;desc&quot;: &quot;你的位置信息将用于小程序位置接口的效果展示&quot;
        }
    },
}
&lt;!-- 在需要获取定位信息的 js 里面调用微信获取经纬度位置的API    wx.getLocation({})   --&gt;
onLoad: function(options) {
    // 获取当前经纬度定位信息API 
      wx.getLocation({
        altitude: 'altitude',
        isHighAccuracy: true, 
        success(res) {
            &lt;!-- 返回定位信息    longitude字段为经度     latitude为纬度--&gt;
            console.log(res)
          this.setData({
            // 经度
            longitude: res.longitude,
            // 纬度
            latitude: res.latitude
          })
        }
      })
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Angular项目避坑指南]]></title>
        <id>https://qinyu312.github.io/post/angular-xiang-mu-bi-keng-zhi-nan/</id>
        <link href="https://qinyu312.github.io/post/angular-xiang-mu-bi-keng-zhi-nan/">
        </link>
        <updated>2020-11-24T10:15:01.000Z</updated>
        <content type="html"><![CDATA[<p>最近收到一个新的需求，有一个Angular项目需要兼容到 IE8 以上版本，实在让我又惊又喜，惊的是都 2020年了，还甩不掉 IE8 这颗烫手山芋；喜的是第一次接触 Angular项目，不知道又会学到什么新的知识呢。拉到项目代码后，本地启动，果然给我来了迎头痛击。<br>
首先确认本地安装有Node.js环境后，全局安装 Angular-cli ，也就是Angular脚手架,命令行输入：</p>
<pre><code>cnpm install -g @angular/cli
</code></pre>
<p>然后就是老步骤，下载node_modules 依赖包</p>
<pre><code>cnpm install
</code></pre>
<p>之后直接 ng serve 启动命令有点别具一格的简洁，直接芜湖🛫️</p>
<pre><code>ng serve
</code></pre>
<p>接下来，就是见证 奇迹（打脸）的时刻<br>
<img src="https://qinyu312.github.io/post-images/1606213638697.png" alt="" loading="lazy"><br>
我敲完命令一回车，啪的一下满屏飙红报错，很快啊，我就看到是依赖包的问题，按照传统功夫的看到为止，我没有看下去，上去就是一个卸载依赖，一个 cnpm install ，我大意了啊，没有删完，接着又是飙红报错。Angular 不讲武德，来欺，为难我入行一年多点的小前端，希望它以后耗子尾汁！<br>
<img src="https://qinyu312.github.io/post-images/1606228631691.png" alt="" loading="lazy"><br>
最后在 node_modules 下的 less-loader 加上一句  javascriptEnabled: true  ，问题得到解决<br>
<img src="https://qinyu312.github.io/post-images/1606228810583.png" alt="" loading="lazy"></p>
<p>项目成功启动，再来解决兼容IE8的问题，<a href="https://angular.cn/guide/browser-support">Angular</a>，官方文档浏览器兼容部分我们可以看到， IE 10, 11, 9，也就是说连官方都放弃去做IE9一下的兼容了。<br>
<img src="https://qinyu312.github.io/post-images/1606461891938.png" alt="" loading="lazy"><br>
忍不住又想吐槽IE一把，但是客户需求在身，只能硬着头皮做了，因为Angular在国内市场的使用还不是特别频繁，所以我在百度没有什么收获之后，决定翻墙去 Google ，Angular 也不亏是 Google的亲儿子。方案当然是有的。需要将Angular版本降低至 1.2一以下可以对IE8进行兼容适配。然后就是传统功夫的卸载新版本，安装旧版本。</p>
<pre><code>&lt;!-- 卸载新版本 --&gt;
cnpm uninstall -g @angular/cli
&lt;!-- 安装新版本 --&gt;
cnpm install -g @angular/cli/1.1
</code></pre>
<p>问题得到解决，兼容是好了，样式又乱的简直是乱他妈妈给乱开门  -  乱到家了。不说了，我要去调样式了！<br>
<img src="https://qinyu312.github.io/post-images/1606462146562.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识React]]></title>
        <id>https://qinyu312.github.io/post/chu-shi-react/</id>
        <link href="https://qinyu312.github.io/post/chu-shi-react/">
        </link>
        <updated>2020-07-30T13:47:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="搭建react项目">搭建React项目</h2>
<p>在装有node.js的基础上，命令行输入命令</p>
<pre><code>npx create-react-app item-name
</code></pre>
<p>即可创建一个React项目，项目结构如下</p>
<figure data-type="image" tabindex="1"><img src="https://qinyu312.github.io/post-images/1605707465716.png" alt="" loading="lazy"></figure>
<h2 id="jsx语法">JSX语法</h2>
<p>src文件下的index.js是项目的入口文件，文件中先后引入了react和react-dom两个库。</p>
<pre><code>ReactDOM.render(&lt;h2&gt;hello react&lt;/h2&gt;, document.getElementById('root'));
</code></pre>
<p>ReactDOM实例通过render方法，将前面的h2标签元素，添加到root元素中，而id为root的元素是public文件的index.html文件的元素。<br>
JSX语法由JavaScript语法 和 XML语法组成，通俗来说就是，当我们在JSX语句中遇到 &lt;&gt; 的形式的，按照XML的形式来解析，因为他们是标签；遇到 {} 按照javaScript来解析，表示JS语法。</p>
<pre><code>const a = (
        &lt;div&gt;
            &lt;p&gt;hello react&lt;/p&gt;
        &lt;/div&gt;
) 
</code></pre>
<p>如果存在标签结构，并且标签结构需要换行的话，可以使用 （）的形式进行表示</p>
<h2 id="react-元素渲染">React 元素渲染</h2>
<p>这里通过一个实例了解react的元素渲染</p>
<pre><code>&lt;!-- 首先定义一个方法 --&gt;
function nowTime() {
    const ele = (
        &lt;!-- 使用()的形式，可以换行写标签语法 --&gt;
        &lt;h2&gt;get now time&lt;/h2&gt;  
        &lt;!-- 定义一个获取当前时间的方法 --&gt;
        &lt;h1&gt;now time is { new Date().toLocalTimeString() } &lt;/h1&gt;
    )
    &lt;!-- 渲染这个获取当前时间的方法 --&gt;
    reactDOM.render(ele, document.getElementById('root));
}
&lt;!-- 定时器每隔一秒会调用一次该方法，实现实时更新当前时间 --&gt;
setInterval(() =&gt; {
    nowTime()
},1000)

</code></pre>
<h2 id="react-组件">React 组件</h2>
<p>关于Ract组件，区别于vue的以 .vue为后缀结尾的文件，React的组件可以是以 .js 为后缀的文件，也可以是 .jsx 为后缀的文件命名。编写React组件的时候，创建 .js 的组件是没有代码语法提示的，而创建 .jsx 组件文件是有代码语法提示的。 创建React组件分别有两种方式，第一种是通过 类的形式创建组件，第二种是通过Hook的形式创建。并且组件之间是可以互相引入和使用的，以标签的形式存在！</p>
<pre><code>&lt;!-- 第一种写法 --&gt;
&lt;!-- 创建一个React组件首先需要引入 React 库 --&gt;
import React from 'react'
&lt;!-- 创建一个类App继承React所提供的Component组件的对象 --&gt;
class App extends React Component {
    &lt;!-- rander(){} 渲染函数 --&gt;
    render() {
        &lt;p&gt;渲染函数中写你需要这个组件展示的内容，或者要做什么&lt;/p&gt;
    }
}
&lt;!-- 导出组件 --&gt;
export default App

&lt;!-- 第二种写法 --&gt;
import React from 'react'

export default class App extends React.Component{
    render() {
        return {
            &lt;div&gt;
                &lt;p&gt;直接导出并继承React下的Component对象&lt;/p&gt;
            &lt;/div&gt;
        }
    }
}
</code></pre>
<pre><code>&lt;!-- 函数组件 --&gt;
function fun(props) {
    return (
        &lt;div&gt;
            &lt;h3&gt;函数组件&lt;/h3&gt;
        &lt;/div&gt;
    )
}
&lt;!-- ES6 class类组件 --&gt;
class App extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;h3&gt;ES6 class类创建组件&lt;/h3&gt;  
            &lt;/div&gt;
        )
    }
}
</code></pre>
<p>然后在需要使用的地方引入该组件,并将其放置在渲染函数中渲染即可。</p>
<pre><code>import 'App' from './App.jsx'
ReactDOM.render(&lt;App /&gt;, document.getElementById('root));

</code></pre>
<h3 id="props组件动态传参">Props组件动态传参</h3>
<p>React里面的组件传参通过 props</p>
<h3 id="父组件传递参数给子组件">父组件传递参数给子组件</h3>
<pre><code>&lt;!-- 子组件 --&gt;
import React from 'react'
export default class Son extends React.Component {
    render() {
        return {
            &lt;div&gt;
                &lt;ul&gt;
                    {
                    &lt;!-- 子组件中 通过this.props的方式获取父组件传递过来的数据，也就是arr ,然后通过map来遍历获取到的数据--&gt;
                        this.props.arr.map((element, index) =&gt; {
                            &lt;!-- 将遍历得到的数据放在li标签中渲染返回，key值需要绑定index唯一值，否则会抛出语法error --&gt;
                            return &lt;li key={ index }&gt;{ element }&lt;/li&gt;
                        })
                    }
                &lt;/ul&gt;            
            &lt;/div&gt;
        }
    }
}
</code></pre>
<pre><code>import React from 'react'
&lt;!-- 引入子组件 --&gt;
import Son from './son'
export default class Father extends React.Component {
    render() {
        &lt;!-- 父组件定义两个数组，用于传递给子组件使用 --&gt;
        const arrOne = ['Vue' , 'React', 'Angular'],
                 arrTwo = ['Java', 'Pythen', 'C++']
        return (
            &lt;!-- 在两个子组件中分别传入不同的数据 --&gt;
            &lt;Son arr={ arrOne } /&gt;
            &lt;Son arr={ arrTwo } /&gt;
        )
    }
}
</code></pre>
<h3 id="子组件传递参数给父组件">子组件传递参数给父组件</h3>
<pre><code>&lt;!-- 父组件 --&gt;
import React from 'react'
import Son from './son'
export defaul{t class Father React.Component {
    &lt;!-- 首先定义state用来存储title的状态 --&gt;
    constructor() {
        super();
        this.state = {
            title: ‘最初的标题’
        }
    }
    clickChange = () =&gt; {
        this.setState({
            title: '最后的标题'
        })
    }
    render()  {
        return (    
            &lt;div&gt;
                父子组件传参
            &lt;/div&gt;
            &lt;!-- 使用子组件,title最开始为 ‘最初的标题’， changeFatherProps 被子组件中的点击事件触发从而执行父组件中的clickChange方法，完成对标题的修改 --&gt;
            &lt;son title={ this.state.title } changeFatherProps={ this.clickChange } /&gt;
        )
    }
}
</code></pre>
<pre><code>&lt;!-- 子组件 --&gt;
import React from 'react'

export defaul{t class Father React.Component {
    changeFather = () =&gt; {
        &lt;!-- 通过 this.props 的方式 --&gt;
        this.prpos.changFatherProps()
    }
    render()  {
        return &lt;div&gt;
                    父子组件传参
                    &lt;!-- 点击button事件会触发父组件中方法的执行，将标题修改 --&gt;
                    &lt;button onClick={ this.changeFather }&gt;点击传参修改&lt;button&gt;
                &lt;/div&gt;
    }
}
</code></pre>
<h2 id="state-状态">state 状态</h2>
<pre><code>&lt;!-- 通过this.state定义保存数据和状态 --&gt;
    this.state = {
        flag: true,
        count: 10,
    }
    &lt;!-- 需要修改状态值的时候通过 this.setState({})的方式进行修改 --&gt;
    this.setState({
        flag:  false,
        count: this.state.count ++
    })
</code></pre>
<h2 id="生命周期函数">生命周期函数</h2>
<p>随着我们对React理解和使用的原来越多，生命周期会越来越有参考价值<br>
生命周期函数包括:</p>
<ol>
<li>componentWillMount:  在组件创建之前执行</li>
<li>componentDidMount: 在组件渲染之后执行</li>
<li>shouldComponentUpdata: 返回 true 和 false, true代表允许改变， false代表不允许改变</li>
<li>componentWillUpdata: 数据在改变之前执行（state, props）</li>
<li>conponentDidUpdata: 代表数据修改完成（state, props）</li>
<li>conponentWillReveiceProps: props发生改变时执行的生命周期函数</li>
<li>conponentWillUnMount: 组件卸载前执行</li>
</ol>
<h2 id="探讨关于-setstate-更新是同步操作还是异步操作的问题">探讨关于 setState 更新是同步操作还是异步操作的问题</h2>
<pre><code>setState会引起视图的重绘
官方文档解答:在可控的情况下是异步的，在不可控的情况下是同步的
</code></pre>
<h2 id="create-react-app-按需加载antd-组件">create-react-app 按需加载Antd 组件</h2>
<ol>
<li>命令行输入 cnpm run eject  拉取React的配置文件</li>
<li>文件被修改时，会抛出异常，由于GIt的原因导致,此时找到文件目录，按下shift + command + . 显示隐藏文件，删除 .git 文件，重新 cnpm run eject即可，安装完成后目录多出了两个文件，分别是config和script文件，config文件就是webpack配置文件</li>
<li>安装一个依赖文件 cnpm install babel-plugin-import --save-dev</li>
</ol>
<h2 id="react-router">React-Router</h2>
<p>React路由也分为两种路由模式： BrowserRouter 和 HashRouter<br>
两者的区别在于 HashRouter使用的是锚点链接的形式，表现为 # 的形式， # 号后面为跳转的二级路由地址 而BrowserRouter 则使用了HTML5的新特性，主要是 history.push() 实现。<br>
实际开发中， BrowserRouter 会在项目上线之后存在一些问题，就是需要后台配合做一些配置处理和重定向，否则会很容易跳转到 404 页面，而 HashRouter 则不会有这个问题。</p>
<pre><code>&lt;!-- 安装 react-router --&gt;
cnpm install react-router-dom -save

&lt;!-- 使用 react-router --&gt;
import {BrowserRouter as Router, Link,NavLink, Route, Redirect} from &quot;react-router-dom&quot;
&lt;!-- 引入  react-router 相关的组件 --&gt;

function App() {
    render() {
        return(
            &lt;div&gt;
            &lt;!-- 在 Router盒子中嵌套 Route盒子，在Route中定义路由路径和路径对应的页面 --&gt;
                &lt;Router&gt;
                    &lt;switch&gt;
                        &lt;Route path=&quot;/login&quot; component={ Login }&gt;&lt;/Route&gt;
                        &lt;Route path=&quot;/home&quot; component={ Home }&gt;&lt;/Route&gt;
                        &lt;Route path=&quot;/home/detail&quot; exact={ true } component={ detail }&gt;&lt;/Route&gt;         
                        &lt;Route path=&quot;/demo&quot; render={ () =&gt; &lt;div&gt;简约写法，不需要创建页面和组件，直接路由显示render函数中定义路由页面内容即可&lt;/div&gt;}&lt;/Route&gt;
                        &lt;!-- 简约写法，不需要创建页面和组件，直接路由显示render函数中定义路由页面内容即可 --&gt;
                    &lt;/switch&gt;
                    &lt;!-- 当路由规则包裹在switch内的时，路由就不会同时显示多个，而是按照当前路径进行匹配 --&gt;
                &lt;/Router&gt;
                    &lt;!-- 路由匹配规则之，如果一个页面上同时存在 路径为 /home 和 /home/detail 两个组件，两个组件都会显示，因为 /home 是包含 /home/detail , 但是正常情况下访问 /home下的/detail是不应该显示上一级组件也就是 /home的，这个时候就需要使用到 路由规则的精准匹配， 使用 exace = { true } 即可开启精准匹配，就不会匹配到下一级路由，只会匹配到 /home 这一个, strict = { true } 可以更加精确的匹配路由，而且使用的时候strice需要和exace一起使用才可以生效，而exace不需要组合使用也可以生效 --&gt;

                    &lt;Link to=&quot;/login&quot;&gt;go login now&lt;/Link&gt;
                    &lt;!-- Link 点击跳转到 to 后面的路由页面 --&gt;

                    &lt;NavLink to=&quot;/login&quot; activeClassName=&quot;setActive&quot;&gt;&lt;/NavLink&gt;
                    &lt;!-- NavLink顾名思义，导航跳转，后为当前选中的菜单导航添加一个名为active的class样式，给你这个样式添加颜色或者背景选中时便会添加该样式,activeClassName可以修改样式名称，默认是active --&gt;

                    &lt;Redirect from=&quot;/happy&quot; to=&quot;/login&quot;&gt;&lt;/Redirect&gt;
                    &lt;!-- Redirect可以实现路由重新向，当你访问 的地址是属性中的from，也就是要去的路由为 ‘/happy',他会直接重定向到 to所给定的路由地址 --&gt;


                &lt;/Router&gt;
            &lt;/div&gt; 
        )
    }
}
&lt;!-- 处于用户体验方面的考虑，我们一般还会在路由匹配中加入 404 等页面，将不存在的路径以更友好地方式提醒用户 --&gt;
</code></pre>
<pre><code>&lt;button&gt;跳转&lt;/button&gt;

&lt;!-- 跳转的方法有 两种  props.history.push('/home')   和 props.history.replace('/home')
区别在于， push方法的页面跳转是叠加的，也就是说点击浏览器左上角的返回上一个页面依然有效，因为历史数据被保留； 而replace方法是替换的，所以不会存有历史跳转记录
 --&gt;
</code></pre>
<h2 id="redux数据管理方案-类似于vuex">Redux数据管理方案  (类似于Vuex)</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React各种零碎知识合集]]></title>
        <id>https://qinyu312.github.io/post/js-ge-chong-ling-sui-zhi-shi-he-ji/</id>
        <link href="https://qinyu312.github.io/post/js-ge-chong-ling-sui-zhi-shi-he-ji/">
        </link>
        <updated>2020-07-28T02:37:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="react里的事件">React里的事件</h2>
<pre><code>&lt;!-- onChange事件 --&gt;
this.handleChange = this.handleChange.bind(this)
handleChange(event) {
    this.setState({value: event.target.value})
}
&lt;textarea onChange={ this.handleChange } /&gt;  

&lt;!-- onSubmit事件 --&gt;
this.handleSubmit = this,handleSubmit(this)
handleSubmit(event) {
    alert('提交' + this.state.value + '成功!')
    event.preventDefault()    
    &lt;!-- 清除默认事件 --&gt;
}
&lt;form onSubmit= { this.handleSubmit }&gt;&lt;/form&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于各种浏览器兼容(持续更新中)]]></title>
        <id>https://qinyu312.github.io/post/guan-yu-ge-chong-ie-jian-rong/</id>
        <link href="https://qinyu312.github.io/post/guan-yu-ge-chong-ie-jian-rong/">
        </link>
        <updated>2020-07-15T10:07:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ie条件注释">IE条件注释</h2>
<p>IE10以下版本可用，IE11已经取消支持</p>
<pre><code>&lt;!--[if lte IE 8]&gt; 	
        &lt;script src=&quot;/js/html5.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;/js/css3-mediaqueries.js&quot;&gt;&lt;/script&gt;
        &lt;link href=&quot;/css/ie8.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
&lt;![endif]--&gt;
</code></pre>
<p>因为IE11不支持条件注释，可以使用正则判断</p>
<pre><code>var browser = navigator.appName;
var ie11 = !!navigator.userAgent.match(/Trident\/7\./);
if (browser == 'Microsoft Internet Explorer' || ie11 == true) {
    //do something
}
</code></pre>
<h2 id="ie9部分页面不显示的问题">IE9部分页面不显示的问题</h2>
<pre><code>IE9是不支持 console.log 打印输出语句的，在非开发者模式下会阻塞不会执行后面的内容
</code></pre>
<h2 id="ie9-及以下-ie浏览器不支持placeholder属性">IE9 及以下 IE浏览器不支持placeholder属性</h2>
<pre><code>引入 jquery和用于解决这个属性兼容的CDN
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.ijquery.cn/js/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.ijquery.cn/js/jquery.placeholder.min.js&quot;&gt;&lt;/script&gt;

&lt;%--兼容IE9及以下input输入框，textarea文本框不支持提示文本placeholder属性的问题--%&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function(){ $('input, textarea').placeholder(); });
&lt;/script&gt;
</code></pre>
<p>上面这种方法在HTML文件中亲测有效，但是不知道为什么在前后端不分离JSP项目中不会生效，以某国企老项目为例，需要在每个页面的JS代码中加上</p>
<pre><code>	&lt;!-- css代码 --&gt;
    .phcolor{ 
			color:#999;
	}

    &lt;!-- js代码 --&gt;
	// placeholder兼容IE9
	$(function(){
	  //判断浏览器是否支持placeholder属性
	  supportPlaceholder='placeholder'in document.createElement('input'),
	  placeholder=function(input){
	    var text = input.attr('placeholder'),
	    defaultValue = input.defaultValue;
	    if(!defaultValue){
	      input.val(text).addClass(&quot;phcolor&quot;);
	    }
	    input.focus(function(){
	      if(input.val() == text){
	        $(this).val(&quot;&quot;);
	      }
	    });
	    input.blur(function(){
	      if(input.val() == &quot;&quot;){
	        $(this).val(text).addClass(&quot;phcolor&quot;);
	      }
	    });
	    //输入的字符不为灰色
	    input.keydown(function(){
	      $(this).removeClass(&quot;phcolor&quot;);
	    });
	  };
	  //当浏览器不支持placeholder属性时，调用placeholder函数
	  if(!supportPlaceholder){
	    $('input').each(function(){
	      text = $(this).attr(&quot;placeholder&quot;);
	      if($(this).attr(&quot;type&quot;) == &quot;text&quot;){
	        placeholder($(this));
	      }
	    });
	  }
	});
</code></pre>
<h2 id="换行word-wrap与word-break兼容ie和火狐-chrome">换行word-wrap与word-break兼容ie和火狐、chrome</h2>
<ol>
<li>word-wrap控制换行，使用break-word时，会强制进行换行，中文没问题，英文语句没问题，长串的英文不会生效。</li>
<li>word-break控制是否断词<br>
normal是默认情况，英文单词不被拆开<br>
break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题。<br>
keep-all，是指Chinese, Japanese, and Korean不断词。即只用此时，不用word-wrap，中文就不会换行了。（英文语句正常。）<br>
所以，要做到英文和中文等强制换行，需要组合使用如下</li>
</ol>
<pre><code>&lt;p style=&quot;word-wrap: break-word; word-break: break-all&quot;&gt;&lt;/p&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fetch querystring解决跨域]]></title>
        <id>https://qinyu312.github.io/post/fetch-shu-ju-jie-kou-qing-qiu/</id>
        <link href="https://qinyu312.github.io/post/fetch-shu-ju-jie-kou-qing-qiu/">
        </link>
        <updated>2020-06-11T14:38:43.000Z</updated>
        <content type="html"><![CDATA[<p>以前写数据接口，对接请求都是使用的Ajax，或者Axios之类的，最近在使用React进行开发，用到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">fetch</a>, 和<a href="http://nodejs.cn/api/querystring.html">querystring</a></p>
<pre><code>import qs from 'querystring'
&lt;!-- get请求 --&gt;
fetch(&quot;http://iwenwiki.com/api/blueberrypai/getChengpinInfo.php&quot;)
.then(res =&gt; res.json())
.then(data =&gt; {
    console.log(data)
})

&lt;!-- post请求 --&gt;
fetch(&quot;http://iwenwiki.com/api/blueberrypai/login.php&quot;, {
    method: 'POST' ,   // 请求方式
    headers: {            // 请求头
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json, text/plain, */*',
    },
    &lt;!-- body: &quot;user_id=iwen@qq.com&amp;password=iwen123&amp;verification_code=crfvw&quot; --&gt;
    &lt;!-- 此处传参使用字符串传参的方式，所以需要参数间 &amp; 分隔拼串 --&gt;
    &lt;!-- 如果不想写拼串，也可以直接引入 querystring来进行转换操作如下 --&gt;
    body: qs.stringify({
        'user_id': 'iwen@qq.com',
        'password': 'iwen123',
        'verification_code': 'crfvw'
    })
})
</code></pre>
<h2 id="跨域的解决方案">跨域的解决方案</h2>
<p>跨域一般分为两种场景： 开发环境下的跨域问题和生产环境下的跨域问题<br>
此处以React项目开发环境下为例</p>
<pre><code>componentDidMount() {
    fetch(&quot;http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0&quot;)
    .then(res =&gt; res.json())
    .then(data =&gt; {
        console.log(data)
    })
    .catch(error =&gt; {
        console.log(new Error(error))
    })
}
</code></pre>
<p><img src="https://qinyu312.github.io/post-images/1607442245412.png" alt="" loading="lazy"><br>
此处请求会跨域<br>
需要在 package.json 文件中配置 proxy 代理解决<br>
<img src="https://qinyu312.github.io/post-images/1607442296763.png" alt="" loading="lazy"><br>
配置完成 package.json 文件后需要将请求接口前面的已经被代理的地址去掉如下</p>
<pre><code>componentDidMount() {
    fetch(&quot;/v1/restserver/ting?method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0&quot;)
    .then(res =&gt; res.json())
    .then(data =&gt; {
        console.log(data)
    })
    .catch(error =&gt; {
        console.log(new Error(error))
    })
}
</code></pre>
<p>然后终止此项目进程，重新运行该项目即可使用代理解决跨域问题。打开浏览器调试，接口数据正常请求得到。<br>
<img src="https://qinyu312.github.io/post-images/1607442458895.png" alt="" loading="lazy"></p>
<h2 id="fetch-封装常用请求">fetch 封装常用请求</h2>
<p>工具类文件utils下创建 http.js 用于封装常用的请求方法</p>
<pre><code>import qs from 'querystring'

&lt;!-- 导出封装的 get 请求 --&gt;
export function httpGet(url) {
    const result = fetch(url)
    return result
}

&lt;!-- 导出封装的 post 请求 --&gt;
export function httpPost(url, params) {
    &lt;!-- params为post请求携带参数 --&gt;
    const result = fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'application/json, text/plain, */*',
        },
        body: qs.stringify(params)
    })
}
</code></pre>
<p>然后在 utils 同级创建一个 api 文件，用于管理接口，api 下新建一个 base.js ，用于向外暴露接口的前置接口地址公共部分(一般情况下接口地址的前半部分是一致的)，然后新建一个 index.js 用于定义业务接口请求统一管理，或者创建不同的功能分类 (如，登录的接口单独写在一个文件里，首页的接口单独写在一个文件里，便于维护)<br>
base.js</p>
<pre><code>const base = {
    baseUrl: 'http://iwenwiki.com/api'
}
</code></pre>
<p>index.js</p>
<pre><code>import {httpGet, httpPost} from '../utils/http'
import base from './base'

&lt;!-- 在下面定义各种业务接口 --&gt;
const api = {
    &lt;!-- get请求 --&gt;
    getUserId() {
        return httpGet(base.baseUrl + '/blueberrypai/getChengpinInfo.php');
    },
    &lt;!-- post请求 --&gt;
    getLogin(params) {
        return httpPost(baseUrl + '/blueberrypai/login.php', params);
    }
}

&lt;!-- 定义完成后导出 api ,在需要调用处导入调用即可 --&gt;
export default api
</code></pre>
<p>调用接口的文件下</p>
<pre><code>import api from '../api'
&lt;!-- get请求不用携带参数，直接获取并打印数据 --&gt;
api.getUserId().then(res =&gt; res.json()).then(data =&gt; {
    console.log(data)
})
&lt;!-- post请求调用接口时传入参数，获取并打印数据 --&gt;
api.getLogin({
    'user_id': 'iwen@qq.com',
    'password': 'iwen123',
    'verification_code': 'crfvw'
}).then(res =&gt; res.json()).then(data =&gt; {
    console.log(data)
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js常用api集锦]]></title>
        <id>https://qinyu312.github.io/post/chang-yong-api-ji-jin/</id>
        <link href="https://qinyu312.github.io/post/chang-yong-api-ji-jin/">
        </link>
        <updated>2020-02-12T09:10:57.000Z</updated>
        <content type="html"><![CDATA[<p>##数组API：<br>
var pageIds = new Array();<br>
pageIds.push('A');<br>
//数组长度<br>
pageIds.length;<br>
//shift：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined<br>
var a = [1,2,3,4,5];<br>
var b = a.shift(); //a：[2,3,4,5] b：1<br>
//unshift：将参数添加到原数组开头，并返回数组的长度<br>
var a = [1,2,3,4,5];<br>
var b = a.unshift(-2,-1); //a：[-2,-1,1,2,3,4,5] b：7<br>
//注：在IE6.0下测试返回值总为undefined，FF2.0下测试返回值为7，所以这个方法的返回值不可靠，需要用返回值时可用splice代替本方法来使用。<br>
//pop：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined<br>
var a = [1,2,3,4,5];<br>
var b = a.pop(); //a：[1,2,3,4] b：5<br>
//push：将参数添加到原数组末尾，并返回数组的长度<br>
var a = [1,2,3,4,5];<br>
var b = a.push(6,7); //a：[1,2,3,4,5,6,7] b：7<br>
//concat：返回一个新数组，是将参数添加到原数组中构成的<br>
var a = [1,2,3,4,5];<br>
var b = a.concat(6,7); //a：[1,2,3,4,5] b：[1,2,3,4,5,6,7]<br>
//splice(start,deleteCount,val1,val2,)：从start位置开始删除deleteCount项，并从该位置起插入val1,val2,<br>
var a = [1,2,3,4,5];<br>
var b = a.splice(2,2,7,8,9); //a：[1,2,7,8,9,5] b：[3,4]<br>
var b = a.splice(0,1); //同shift<br>
a.splice(0,0,-2,-1); var b = a.length; //同unshift<br>
var b = a.splice(a.length-1,1); //同pop<br>
a.splice(a.length,0,6,7); var b = a.length; //同push<br>
//reverse：将数组反序<br>
var a = [1,2,3,4,5];<br>
var b = a.reverse(); //a：[5,4,3,2,1] b：[5,4,3,2,1]<br>
//sort(orderfunction)：按指定的参数对数组进行排序<br>
var a = [1,2,3,4,5];<br>
var b = a.sort(); //a：[1,2,3,4,5] b：[1,2,3,4,5]<br>
//slice(start,end)：返回从原数组中指定开始下标到结束下标之间的项组成的新数组<br>
var a = [1,2,3,4,5];<br>
var b = a.slice(2,5); //a：[1,2,3,4,5] b：[3,4,5]<br>
//join(separator)：将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符<br>
var a = [1,2,3,4,5];<br>
var b = a.join(&quot;|&quot;); //a：[1,2,3,4,5] b：&quot;1|2|3|4|5&quot;</p>
<p>##DOM常用API：<br>
getElementById(id) Node 返回指定结点的引用<br>
getElementsByTagName(name) NodeList 返回文档中所有匹配的元素的集合<br>
createElement(name) Node Node<br>
createTextNode(text) Node 创建一个纯文本结点<br>
ownerDocument Document 指向这个节点所属的文档<br>
documentElement Node 返回html节点<br>
document.body Node 返回body节点<br>
//element方法：<br>
getAttribute(attributeName) String 返回指定属性的值<br>
setAttribute(attributeName,value) String 给属性赋值<br>
removeAttribute(attributeName) String 移除指定属性和它的值<br>
getElementsByTagName(name) NodeList 返回结点内所有匹配的元素的集合<br>
//node方法：<br>
appendChild(child) Node 给指定结点添加一个新的子结点<br>
removeChild(child) Node 移除指定结点的子结点<br>
replaceChild(newChild,oldChild) Node 替换指定结点的子结点<br>
insertBefore(newChild,refChild) Node 在同一层级的结点前面插入新结点<br>
hasChildNodes() Boolean 如果结点有子结点则返回true<br>
//node属性：<br>
nodeName String 以字符串的格式存放结点的名称<br>
nodeType String 以整型数据格式存放结点的类型<br>
nodeValue String 以可用的格式存放结点的值<br>
parentNode Node 指向结点的父结点的引用<br>
childNodes NodeList 指向子结点的引用的集合<br>
firstChild Node 指向子结点结合中的第一个子结点的引用<br>
lastChild Node 指向子结点结合中的最后一个子结点的引用<br>
previousSibling Node 指向前一个兄弟节点；如果这个节点就是兄弟节点，那么该值为null<br>
nextSibling Node 指向后一个兄弟节点；如果这个节点就是兄弟节点，那么该值为null</p>
<p>##数字方法API<br>
//·数字型(Number)<br>
//1.声明<br>
var i = 1;<br>
var i = new Number(1);<br>
//2.字符串与数字间的转换<br>
var i = 1;<br>
var str = i.toString(); //结果: &quot;1&quot;<br>
var str = new String(i); //结果: &quot;1&quot;<br>
i = parseInt(str); //结果: 1<br>
i = parseFloat(str); //结果: 1.0<br>
//注意: parseInt,parseFloat会把一个类似于&quot;32G&quot;的字符串,强制转换成32<br>
//3.判断是否为有效的数字<br>
var i = 123; var str = &quot;string&quot;;<br>
if( typeof i == &quot;number&quot; ){ } //true<br>
//某些方法(如:parseInt,parseFloat)会返回一个特殊的值NaN(Not a Number)<br>
//请注意第2点中的[注意],此方法不完全适合判断一个字符串是否是数字型!!<br>
i = parseInt(str);<br>
if( isNaN(i) ){ }<br>
//4.数字型比较<br>
//此知识与[字符串比较]相同<br>
///5.小数转整数<br>
var f = 1.5;<br>
var i = Math.round(f); //结果:2 (四舍五入)<br>
var i = Math.ceil(f); //结果:2 (返回大于f的最小整数)<br>
var i = Math.floor(f); //结果:1 (返回小于f的最大整数)<br>
//6.格式化显示数字<br>
var i = 3.14159;<br>
//格式化为两位小数的浮点数<br>
var str = i.toFixed(2); //结果: &quot;3.14&quot;<br>
//格式化为五位数字的浮点数(从左到右五位数字,不够补零)<br>
var str = i.toPrecision(5); //结果: &quot;3.1415&quot;<br>
//7.X进制数字的转换<br>
//不是很懂 -.-<br>
var i = parseInt(&quot;0x1f&quot;,16);<br>
var i = parseInt(i,10);<br>
var i = parseInt(&quot;11010011&quot;,2);<br>
//8.随机数<br>
//返回0-1之间的任意小数<br>
var rnd = Math.random();<br>
//返回0-n之间的任意整数(不包括n)<br>
var rnd = Math.floor(Math.random() * n)</p>
<p>##日期方法API<br>
//·日期型(Date)<br>
//1.声明<br>
var myDate = new Date(); //系统当前时间<br>
var myDate = new Date(yyyy, mm, dd, hh, mm, ss);<br>
var myDate = new Date(yyyy, mm, dd);<br>
var myDate = new Date(&quot;monthName dd, yyyy hh:mm:ss&quot;);<br>
var myDate = new Date(&quot;monthName dd, yyyy&quot;);<br>
var myDate = new Date(epochMilliseconds);<br>
//2.获取时间的某部份<br>
var myDate = new Date();<br>
myDate.getYear(); //获取当前年份(2位)<br>
myDate.getFullYear(); //获取完整的年份(4位,1970-????)<br>
myDate.getMonth(); //获取当前月份(0-11,0代表1月)<br>
myDate.getDate(); //获取当前日(1-31)<br>
myDate.getDay(); //获取当前星期X(0-6,0代表星期天)<br>
myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数) 时间戳！！<br>
myDate.getHours(); //获取当前小时数(0-23)<br>
myDate.getMinutes(); //获取当前分钟数(0-59)<br>
myDate.getSeconds(); //获取当前秒数(0-59)<br>
myDate.getMilliseconds(); //获取当前毫秒数(0-999)<br>
myDate.toLocaleDateString(); //获取当前日期<br>
myDate.toLocaleTimeString(); //获取当前时间<br>
myDate.toLocaleString( ); //获取日期与时间<br>
//3.计算之前或未来的时间<br>
var myDate = new Date();<br>
myDate.setDate(myDate.getDate() + 10); //当前时间加10天<br>
//类似的方法都基本相同,以set开头,具体参考第2点<br>
//4.计算两个日期的偏移量<br>
var i = daysBetween(beginDate,endDate); //返回天数<br>
var i = beginDate.getTimezoneOffset(endDate); //返回分钟数<br>
//5.检查有效日期<br>
//checkDate() 只允许&quot;mm-dd-yyyy&quot;或&quot;mm/dd/yyyy&quot;两种格式的日期<br>
if( checkDate(&quot;2006-01-01&quot;) ){ }<br>
//正则表达式(自己写的检查 yyyy-mm-dd, yy-mm-dd, yyyy/mm/dd, yy/mm/dd 四种)<br>
var r = /^(\d{2}|\d{4})[/-]\d{1,2}[/-]\d{1,2}$/;<br>
if( r.test( myString ) ){ }</p>
<p>##字符串方法API<br>
//·字符串(String)<br>
//1.声明<br>
var myString = new String(&quot;Every good boy does fine.&quot;);<br>
var myString = &quot;Every good boy does fine.&quot;;<br>
//2.字符串连接<br>
var myString = &quot;Every &quot; + &quot;good boy &quot; + &quot;does fine.&quot;;<br>
var myString = &quot;Every &quot;; myString += &quot;good boy does fine.&quot;;<br>
//3.截取字符串<br>
//截取第 6 位开始的字符<br>
var myString = &quot;Every good boy does fine.&quot;;<br>
var section = myString.substring(6); //结果: &quot;good boy does fine.&quot;<br>
//截取第 0 位开始至第 10 位为止的字符<br>
var myString = &quot;Every good boy does fine.&quot;;<br>
var section = myString.substring(0,10); //结果: &quot;Every good&quot;<br>
//截取从第 11 位到倒数第 6 位为止的字符<br>
var myString = &quot;Every good boy does fine.&quot;;<br>
var section = myString.slice(11,-6); //结果: &quot;boy does&quot;<br>
//从第 6 位开始截取长度为 4 的字符<br>
var myString = &quot;Every good boy does fine.&quot;;<br>
var section = myString.substr(6,4); //结果: &quot;good&quot;<br>
//4.转换大小写<br>
var myString = &quot;Hello&quot;;<br>
var lcString = myString.toLowerCase(); //结果: &quot;hello&quot;<br>
var ucString = myString.toUpperCase(); //结果: &quot;HELLO&quot;<br>
//5.字符串比较<br>
var aString = &quot;Hello!&quot;;<br>
var bString = new String(&quot;Hello!&quot;);<br>
if( aString == &quot;Hello!&quot; ){ } //结果: true<br>
if( aString == bString ){ } //结果: true<br>
if( aString === bString ){ } //结果: false (两个对象不同,尽管它们的值相同)<br>
//6.检索字符串<br>
var myString = &quot;hello everybody.&quot;;<br>
// 如果检索不到会返回-1,检索到的话返回在该串中的起始位置<br>
if( myString.indexOf(&quot;every&quot;) &gt; -1 ){ } //结果: true<br>
////7.查找替换字符串<br>
var myString = &quot;I is your father.&quot;;<br>
var result = myString.replace(&quot;is&quot;,&quot;am&quot;); //结果: &quot;I am your father.&quot;<br>
//8.特殊字符:<br>
//\b : 后退符 \t : 水平制表符<br>
//\n : 换行符 \v : 垂直制表符<br>
//\f : 分页符 \r : 回车符<br>
//&quot; : 双引号 ' : 单引号<br>
//\ : 反斜杆<br>
//9.将字符转换成Unicode编码<br>
var myString = &quot;hello&quot;;<br>
var code = myString.charCodeAt(3); //返回&quot;l&quot;的Unicode编码(整型)<br>
var char = String.fromCharCode(66); //返回Unicode为66的字符<br>
//10.将字符串转换成URL编码<br>
var myString = &quot;hello all&quot;;<br>
var code = encodeURI(myString); //结果: &quot;hello%20all&quot;<br>
var str = decodeURI(code); //结果: &quot;hello all&quot;<br>
//相应的还有: encodeURIComponent() decodeURIComponent()</p>
<p>##数学方法API</p>
<ol>
<li>Math.abs(num) : 返回num的绝对值</li>
<li>Math.acos(num) : 返回num的反余弦值</li>
<li>Math.asin(num) : 返回num的反正弦值</li>
<li>Math.atan(num) : 返回num的反正切值</li>
<li>Math.atan2(y,x) : 返回y除以x的商的反正切值</li>
<li>Math.ceil(num) : 返回大于num的最小整数</li>
<li>Math.cos(num) : 返回num的余弦值</li>
<li>Math.exp(x) : 返回以自然数为底,x次幂的数</li>
<li>Math.floor(num) : 返回小于num的最大整数<br>
10.Math.log(num) : 返回num的自然对数<br>
11.Math.max(num1,num2) : 返回num1和num2中较大的一个<br>
12.Math.min(num1,num2) : 返回num1和num2中较小的一个<br>
13.Math.pow(x,y) : 返回x的y次方的值<br>
14.Math.random() : 返回0到1之间的一个随机数<br>
15.Math.round(num) : 返回num四舍五入后的值<br>
16.Math.sin(num) : 返回num的正弦值<br>
17.Math.sqrt(num) : 返回num的平方根<br>
18.Math.tan(num) : 返回num的正切值<br>
19.Math.E : 自然数(2.718281828459045)<br>
20.Math.LN2 : 2的自然对数(0.6931471805599453)<br>
21.Math.LN10 : 10的自然对数(2.302585092994046)<br>
22.Math.LOG2E : log 2 为底的自然数(1.4426950408889634)<br>
23.Math.LOG10E : log 10 为底的自然数(0.4342944819032518)<br>
24.Math.PI : π(3.141592653589793)<br>
25.Math.SQRT1_2 : 1/2的平方根(0.7071067811865476)<br>
26.Math.SQRT2 : 2的平方根(1.4142135623730951)</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种CSS积累]]></title>
        <id>https://qinyu312.github.io/post/ge-chong-css-ji-lei/</id>
        <link href="https://qinyu312.github.io/post/ge-chong-css-ji-lei/">
        </link>
        <updated>2019-12-22T08:44:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="隐藏textarea-input等输入框边框和选中出现边框">隐藏textarea input等输入框边框和选中出现边框</h2>
<pre><code>textarea {
    border: solid 0px;
	outline:none;
}
</code></pre>
<h2 id="textarea-输入时光标直接定位到后面且不会展示placeholder文本">textarea 输入时光标直接定位到后面，且不会展示placeholder文本</h2>
<p>这种情况是默认有空格在输入框中，解决方案比较奇葩，需要将<textarea>标签写在同一行即可解决问题</p>
<pre><code>&lt;!-- 错误写法 --&gt;
&lt;textarea placeholder=&quot;请输入文本&quot;&gt;
&lt;/textarea&gt;
&lt;!-- 正确写法 --&gt;
&lt;textarea placeholder=&quot;请输入文本&quot;&gt;&lt;/textarea&gt;
</code></pre>
<h2 id="图片或者页面-bulingbuling闪动效果">图片或者页面 bulingbuling闪动效果</h2>
<pre><code>.flicker {
	    /*width: 300px;  */                                  /* 宽度 */
	    /*height: 300px; */                                   /* 高度 */
	    /*border:#666 1px solid;*/
	    /*border-radius:50%;*/
	    opacity: 0.1;                                   /* 不透明度 */
	    overflow: hidden;                               /* 溢出隐藏 */
	   /* margin: 25% auto; */                              /* 外边距 */
	  
	    /* IE10、Firefox and Opera，IE9以及更早的版本不支持 */
	    animation-name: breath;                         /* 动画名称 */
	    animation-duration: 700ms;                         /* 动画时长3秒 */
	    animation-timing-function: ease-in-out;         /* 动画速度曲线：以低速开始和结束 */
	    animation-iteration-count: infinite;            /* 播放次数：无限 */
	 
	    /* Safari and Chrome */
	    -webkit-animation-name: breath;                 /* 动画名称 */
	    -webkit-animation-duration: 3000ms;                 /* 动画时长3秒 */
	    -webkit-animation-timing-function: ease-in-out; /* 动画速度曲线：以低速开始和结束 */
	    -webkit-animation-iteration-count: infinite;    /* 播放次数：无限 */
	}
	 
	@keyframes breath {
	    from { opacity: 0.1; }                          /* 动画开始时的不透明度 */
	    50%  { opacity:   1; }                          /* 动画50% 时的不透明度 */
	    to   { opacity: 0.1; }                          /* 动画结束时的不透明度 */    
	}
	 
	@-webkit-keyframes breath {
	    from { opacity: 0.1; }                          /* 动画开始时的不透明度 */
	    50%  { opacity:   1; }                          /* 动画50% 时的不透明度 */
	    to   { opacity: 0.1; }                          /* 动画结束时的不透明度 */
	}
</code></pre>
<h2 id="去除textarea右下角角标">去除textarea右下角角标</h2>
<pre><code>textarea {
	resize : none;
} 
</code></pre>
<h2 id="内容溢出显示滚动条">内容溢出显示滚动条</h2>
<pre><code>&lt;!-- x轴上内容超出显示滚动条 --&gt;
overflow-x: auto;
&lt;!-- y轴上内容超出显示滚动条 --&gt;
overflow-y: auto;

&lt;!-- 滚动条设置样式 --&gt;
&lt;!-- 设置滚动条的样式 --&gt;
::-webkit-scrollbar{
  width: 6px;
}
&lt;!-- 滚动槽 --&gt;
::-webkit-scrollbar-track{
  -webkit-box-shadow:inset 0 0 6px rgba(0,0,0,0.3) ;
  border-radius: 10px;
}
 &lt;!-- 滚动条滑块 --&gt;
::-webkit-scrollbar-thumb {
  border-radius: 10px;
  background: rgba(0, 0, 0, 0.1);
  -webkit-box-shadow: inset 0 0 2px #4d4b4b;
}
::-webkit-scrollbar-thumb:window-inactive {
    background: rgba(255, 0, 0, 0.4);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-router 路由守卫]]></title>
        <id>https://qinyu312.github.io/post/vue-router-lu-you-shou-wei/</id>
        <link href="https://qinyu312.github.io/post/vue-router-lu-you-shou-wei/">
        </link>
        <updated>2019-11-25T01:59:18.000Z</updated>
        <content type="html"><![CDATA[<pre><code>有一段时间没有写过 vue 的项目了，最近工作中需要自己搭建，所以简单分享一下vue-router路由守卫!
</code></pre>
<p>项目中很常见的一种场景，需求是，用户打开网址进入线上地址，首先是登录页面，用户需要账号密码验证码等手段通过验证和赋权，才可以进入到包括首页，各种管理等内容页面，未登录之前，通过修改路由来进行跳转，如果确实存在此路由，会跳转到登录页面进行登录，如果没有这个路由，会跳转到 404 页面。而成功完成登录后再进行路由地址修改则可以正常跳转！<br>
这里就需要用到通配符匹配和 路由守卫等操作了</p>
<h2 id="通配符">通配符 *</h2>
<p>一般用于菜单路由匹配的最后面，为什么要放在最后面呢？因为放在前面会把写在它之后的路由菜单全部匹配进去，就相当于在小河的上游筑起水坝蓄水，那下游自然就没水了，所以通配符相当于确保没有漏网之鱼的作用，凡是没有被定义的路由，都会被它拦截，转而跳转到首页或者404等页面。</p>
<pre><code>&lt;!-- router 下的 index.js --&gt;
export default new Router({
  routes: [
    {
      path:'/home',
      name:'home',
      component:home
    },
    //通配符的使用
    {
      path: '/detail-*',
      component:detail
    },
    {
      path: '/*',
      component:notFound
    }
  ]
})
</code></pre>
<h2 id="beforeeach-前置路由守卫">beforeEach() 前置路由守卫</h2>
<p>当你随意修改路由地址上的路由菜单进行跳转，比如在 '/login' 修改为 '/home'却可以正常跳转时，在尚未登录赋权的情况下就可以进入程序主页面，是一种很不安全的操作，就需要用到路由守卫了！全局前置路由守卫用于路由跳转之前执行，他有三个参数 'to' 参数，表示你当前正要跳转到哪里去，也就是目标页面路由， 'from'参数表示，从哪里来的，也就是当前页面， next() 方法，一定需要调用，继续往下执行的函数。</p>
<pre><code>&lt;!-- 在 roter 文件下的路由配置处， 将meta下的 requireAuth 设置为 true作为此菜单不可不登录直接跳转的标记 --&gt;
{
    path: '/home',
    meta:{ requireAuth: true }
}
</code></pre>
<pre><code>&lt;!-- main.js --&gt;
beforeEach((to, form, next) =&gt; {
    console.log(to)
    console.log(from)
    &lt;!-- 如果要去的这个页面的路由配置中 meta.requireAuth 为 true的话 --&gt;
    if(to.meta.requireAuth) {
        &lt;!-- 判断本地存储是否有token令牌，如果有并且令牌合法，调用 next() 方法继续执行 --&gt;
        if(localStorage.getItem('access_token')) {
            next();
        } else {
            &lt;!-- 否则就直接调用next()方法跳转回登录页面重新登录 --&gt;
            next({
                path: '/login'
            })
        }
    } else {
        next();
    }
})
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://qinyu312.github.io/post-images/1606098979481.png" alt="" loading="lazy"></figure>
<p>设置完成之后保存并运行项目就会发现，在路径处修改路由不会直接跳转而是会自动拦截。</p>
]]></content>
    </entry>
</feed>